// ==UserScript==
// @name            KabaListics (DoA Power Tools Plus II modded by Jawz)
// @namespace       http://userscripts.org/scripts/show/118446
// @icon            http://img66.xooimage.com/files/3/6/d/jaws64-2b5041c.png
// @description     Enhanced Power Tools for Dragons of Atlantis, modded by Jawz
// @include         *://apps.facebook.com/dragonsofatlantis/*
// @include         *://*.castle.wonderhill.com/platforms/*/game
// @match           *://apps.facebook.com/dragonsofatlantis/*
// @match           *://*.castle.wonderhill.com/platforms/*/game
// @include         *://plus.google.com/games/659749063556*
// @include         *://plus.google.com/*/games/659749063556*
// @include         *://*.googleusercontent.com/gadgets/ifr?url=app://659749063556*
// @match           *://plus.google.com/games/659749063556*
// @match           *://*.googleusercontent.com/gadgets/ifr?url=app://659749063556*
// @include         *://www.kabam.com/dragons-of-atlantis/play
// @exclude         *://apps.facebook.com/dragonsofatlantis/rubies
// @exclude         *://apps.facebook.com/ai.php*
// @exclude         *://www.facebook.com/plugins/like.php*
// @exclude         *://kabam1-a.akamaihd.net/pixelkabam/*
// @exclude         *://*.akamaihd.net/pixelkabam/*
// @exclude         *://plus.google.com/_/apps-static/*
// @exclude         *://plus.google.com/u/0/_/gadgets/contactPicker*
// @exclude         *://accounts.google.com/*
// @exclude         *://talkgadget.google.com/*
// @exclude         *://www.googleapis.com/static*
// @version         2011.1215b
// ==/UserScript==

(function() {

var scriptVersion	= '2011.1215b';
var scriptId = '118446';

// To remove header bar "play | rubies | ...."
var REMOVE_HD = false;

/********************************************************************************
* Check to see if script is running in an iframe or not and removes            *
* unnecessary elements before continuing with the script.                      *
*                                                                              *
* Current actions:                                                             *
*  - Set width all parent div of 'iframe_canvas' to 100%                       *
*  - Hide 'rightCol' div                                                       *
*  - Hide unwanted objects                                                     *
*  - Set width of 'hd' div to 760px                                            *
*  - Set margin of parent to game object to 0px                                *
*  - Hide unwanted elements in 'hd' div                                        *
*  - Hide 'ft' div                                                             *
********************************************************************************/
var window = unsafeWindow || window;

// Check all iframes where the code should not be executed
if (/(pixelkabam|akamaihd|plugins|ai\.php|talkgadget|apps\-static|notifications|contactPicker|accounts|googleapis\.com\/static)/.test(window.location.href)) return;

// Check if we are in the right sites (in case of the Metadata Blocks don't work)
if ( !( (/apps\.facebook\.com\/dragonsofatlantis/.test(window.location.href) && /rubies/.test(window.location.pathname) == false) ||
 		/castle\.wonderhill\.com\/platforms\/.+\/game/.test(window.location.href) ||
 		/plus\.google\.com.*\/games.*\/659749063556/.test(window.location.href)         || 
 		/googleusercontent\.com\/gadgets\/.*\/659749063556/.test(window.location.href)  || 
 		/kabam.com\/dragons-of-atlantis\/play/.test(window.location.href)
 	)){
 		return;
}
var REALM_URL = '';

if (window.top === window.self) {
	function setWide() {
		if ( window.location.href.indexOf('facebook') !== -1 ) {
			iframe	 = document.getElementById('iframe_canvas');
			platform = 'facebook';
			REALM_URL = 'http://apps.facebook.com/dragonsofatlantis/realm/';
		}
		else if ( window.location.href.indexOf("google") !== -1 ) {
			iframe	 = document.getElementById('oz-gadgets-canvas-iframe-659749063556'); //content').getElementsByTagName('iframe');
			platform = 'google';
		}
		else if ( window.location.href.indexOf("kabam.com") !== -1 ) {
			iframe	 = document.getElementById('game_frame');
			platform = 'kabam';
			REALM_URL = 'https://www.kabam.com/dragons-of-atlantis/play/game/8?path=/realm/';
		}

		if (!iframe || iframe.length < 1) {
			setTimeout (setWide, 1000);
			return;
		}
		var background_118446 = localStorage.getItem( '118446_background' );
		var USE_BACKGROUND = (background_118446 && background_118446 != undefined && background_118446 != null) ? eval(background_118446) : true;
		switch (platform) {
			case 'facebook' :
				while ((iframe = iframe.parentNode) != null) {
					if (iframe.tagName == 'DIV')
						iframe.style.width = '100%';
				}
				// Jawz - 03/10/2011
				document.getElementById('rightCol').style.display = 'none';
				document.getElementById('rightCol').style.display = 'none';
				document.getElementById('blueBarHolder').style.display = 'none';
				document.getElementById('blueBar').style.display = 'none';
				document.getElementById('pageHead').style.display = 'none';
				document.getElementById('jewelContainer').style.display = 'none';
				document.getElementById('headNav').style.display = 'none';
				document.getElementById('contentCol').style.margin = '0px';
				document.getElementById('contentCol').style.background = 'transparent';
				var contentColChild = document.getElementById('contentCol').childNodes;
				for (var i=0; i<contentColChild.length; i++)
					if (contentColChild[i].tagName == 'DIV')
						contentColChild[i].style.margin = '0px';
				// Jawz - 03/10/2011
				document.scrollTop = '42px';
				if (USE_BACKGROUND) {
					var body_elements = document.getElementsByTagName ('body');
					for (var el=0; el < body_elements.length; el++)
						body_elements[el].style.background = '#888 url(https://kabam1-a.akamaihd.net/wwwkabam/cdn/sites/doa/img/bg_doa.jpg)';
				}
				break;
			case 'google' :
				var iframeTag = document.getElementById('content').getElementsByTagName('iframe');
				var iframeId = iframeTag[0].id;
				var iframe = document.getElementById(iframeId);
				while ((iframe = iframe.parentNode) != null) {
					if (iframe.tagName == 'DIV') {
						iframe.style.width = '100%';
						iframe.style.margin = '0';
						iframe.style.border = '0';
						iframe.style.backgroundColor = 'transparent';
					}
					if (iframe.tagName == 'DIV' && iframe.className == "Mca") {
						var found = false;
						var div_elements = iframe.getElementsByTagName('div');
						for (var i=0; i<div_elements.length && !found; i++) {
							if (div_elements[i].className == "Pca") {
								div_elements[i].style.display = 'none';
								found = true;
							}
						}
					}
				}
				var found = false;
				var body_elements = document.getElementsByTagName ('body');
				for (var el=0; el < body_elements.length; el++) {
					var div_elements = body_elements[el].getElementsByTagName('div');
					for (var i=0; i<div_elements.length && !found; i++) {
						if (div_elements[i].className == "c-cb-V c-i-cb-V" || div_elements[i].className == "c-C c-cb-C" || div_elements[i].className == "c-cb-vf-V") {
							div_elements[i].style.display = 'none';
							found = true;
						}
					}
				}
				break;
			case 'kabam' :
				iframe.style.width = '100%';
				iframe.style.margin = '0';
				iframe.style.border = '0';
				if (USE_BACKGROUND)
					iframe.style.backgroundColor = 'transparent';
				else
					iframe.style.backgroundColor = 'white';
				while ((iframe = iframe.parentNode) != null) {
					if (iframe.tagName == 'DIV') {
						iframe.style.width = '100%';
						iframe.style.margin = '0';
						iframe.style.border = '0';
						iframe.style.backgroundColor = 'transparent';
					}
				}
				break;
		}
	}
	setWide();
} else {
	platform = document.body.className.split(' ');
	if (platform && platform[0]){
		platform = platform[0].replace(/(platforms_|_game)/g,'');
	} else {
		platform = 'google';
	}
	var errors = 0;
	function setHigh() {
		clearTimeout;
		var object = document.getElementsByTagName('object');
		if (object.length < 1 || (window.location.hostname.indexOf("realm") == -1 && platform != 'google')) {
			if ( ++errors > 6 ){
				errors = 0;
				window.location =  window.location.href;
			}
			setTimeout (setHigh, 1000);
			return;
		}
		var background_118446 = localStorage.getItem( '118446_background' );
		var USE_BACKGROUND = (background_118446 && background_118446 != undefined && background_118446 != null) ? eval(background_118446) : true;
		//$J('#container').css({width:'760px',height:'860px'});
		switch (platform) {
			case 'facebook' :
				REALM_URL = 'http://apps.facebook.com/dragonsofatlantis/realm/';
				for (var i=0; i<object.length; i++) {
					switch (object[i].parentNode.id) {
						case 'hd' :
							object[i].style.display = 'none'; 
							break;
						default :
							object[i].parentNode.style.margin = '0px';
					}
				}
				document.getElementById('hd').parentNode.style.width = '760px';
				var hdChild = document.getElementById('hd').childNodes;
				for (var i=0; i<hdChild.length; i++)
					if (hdChild[i].tagName == 'DIV') hdChild[i].style.display = 'none';  
				document.getElementById('ft').style.display = 'none';
				document.scrollTop = '42px';
				if (REMOVE_HD) document.getElementById('hd').style.display = 'none'; // Jawz - 03/10/2011
				if (USE_BACKGROUND) {
					var body_elements = document.getElementsByTagName ('body');
					for (var el=0; el < body_elements.length; el++)
						body_elements[el].style.background = 'transparent';
					var html_elements = document.getElementsByTagName ('html');
					for (var el=0; el < html_elements.length; el++)
						html_elements[el].style.background = 'transparent';
				}
				break;
			case 'google' :
				document.getElementById('pane_hd').style.display = 'none';
				if (USE_BACKGROUND) {
					var body_elements = document.getElementsByTagName ('body');
					for (var el=0; el < body_elements.length; el++) {
						body_elements[el].style.background = 'transparent';
						body_elements[el].style.background = '#888 url(https://kabam1-a.akamaihd.net/wwwkabam/cdn/sites/doa/img/bg_doa.jpg)';
					}
				}
				break;
			case 'kabam' :
				REALM_URL = 'https://www.kabam.com/dragons-of-atlantis/play/game/8?path=/realm/';
				var html_elements = document.getElementsByTagName ('html');
				for (var el=0; el < html_elements.length; el++) {
					html_elements[el].style.overflow = 'hidden'
					html_elements[el].style.backgroundColor = 'transparent';
				}
				if (!USE_BACKGROUND) document.body.style.backgroundColor = 'white';
				break;
		}
		initScript(object);
	}
	setHigh();
}



function initScript (SWF_OBJECT) {
/********************************************************************************
* All global variables MUST be set here or they will not be available to all   *
* functions throughout the script.                                             *
********************************************************************************/
var api_version		= 'map_api';
var map_api_version = 'qe2';

// Styles List
var styleList = [
 'bnt_blue',
 'blue',
 'bnt_cyan',
 'bnt_green',
 'btn_on',
 'btn_off',
 'bnt_red',
 'bnt_purple',
 'bnt_red',
 'bnt_yellow',
 'bold_red',
 'compact_table',
 'content',
 'content_table',
 'defending',
 'hiding',
 'popup_bar',
 'popup_close',
 'popup_main',
 'popup_outer',
 'popup_top',
 'row_headers',
 'row_top_headers',
 'row_headers_left',
 'scrollable',
 'status_feedback',
 'status_report',
 'status_ticker',
 'subtitle',
 'support_link',
 'table',
 'table_headers',
 'title',
 'red',
 'green',
 'btn_disabled',
 'title_main',
 'info_protect',
 'info_alerts',
 ];

// Skins
var urlBackgroundImage = ''; //'http://img70.xooimage.com/files/3/8/3/pfdnewbackgroundfix-2b96f19.jpg';
//                       'http://img74.xooimage.com/files/3/a/6/pfdnewbackground-2b861f9.gif';
//                       'http://img72.xooimage.com/files/7/8/0/skinewscript-2b4ed29.jpg';
//                       'http://img66.xooimage.com/files/9/b/e/skin-3-2aac15d.jpg';
var urlBackgroundLogo = 'http://img73.xooimage.com/files/4/3/1/logojaws-2b7e9d0.jpg';

// Alert sound
var DEFAULT_ALERT_SOUND_URL = 'http://koc.god-like.info/alarm.mp3';
var SWF_PLAYER_URL = 'http://koc.god-like.info/player_mp3_multi_1.2.1.swf';

// Tab order
var INFO_TAB_ORDER		= 1;     
var JOBS_TAB_ORDER		= 2;
var WAVE_TAB_ORDER		= 3;
var MULTI_TAB_ORDER		= 80;  // Jawz
var SPY_TAB_ORDER		= 81;  // Jawz
var ATTACK_TAB_ORDER	= 6;
var ALLIANCE_TAB_ORDER	= 7;  // Jawz
var SEARCH_TAB_ORDER	= 8;  // Jawz
var BATTLE_TAB_ORDER	= 9; // Jawz
var TOWER_TAB_ORDER		= 10; // Jawz
var LOG_TAB_ORDER		= 78;
var OPTIONS_TAB_ORDER	= 77;
var DEBUG_TAB_ORDER		= 99;

// Tab enable/disable
var INFO_TAB_ENABLE		= true;     
var WAVE_TAB_ENABLE		= true;
var ATTACK_TAB_ENABLE	= true;
var JOBS_TAB_ENABLE		= true;
var LOG_TAB_ENABLE		= true;
var OPTIONS_TAB_ENABLE	= true;
var DEBUG_TAB_ENABLE	= false;
var MULTI_TAB_ENABLE	= true; // Jawz
var SPY_TAB_ENABLE		= true; // Jawz
var SEARCH_TAB_ENABLE	= true; // Jawz
var BATTLE_TAB_ENABLE	= true; // Jawz
var ALLIANCE_TAB_ENABLE	= true; // Jawz
var TOWER_TAB_ENABLE	= true; // Jawz

// CHECK THESE VARIABLES
var DEBUG_TRACE_AJAX	= 2;
var DEBUG_MARCHES		= false;
var MAP_DELAY			= 1250;
var MIN_DELAY			= 15;
var EMULATE_NET_ERROR	= 0;  // percentage
var ENABLE_WINLOG		= false;
var ALERT_ON_BAD_DATA	= false;
var KABAM_CHECK 		= false;  // Jawz
var MIN_DELAY_BETWEEN_WAVE = 30;

var BUTTON_BGCOLOR		= '#436';
var JOB_BUTTON_BGCOLOR	= '#436'; //'#049C93'; // Jawz

// Jawz - Message handling
var MESSAGES_ALL = 0;
var MESSAGES_ONLY = 1;
var REPORTS_ONLY = 2;
// Jawz - Message types
var MSG_BATTLE_REPORT = 1;
var TRANSPORT_MARCH_REPORT = 2;
var SPY_REPORT = 3;
var SENTINEL_WARNING = 4;
var REINFORCEMENTS_REPORT = 5;
var SYSTEM_MESSAGE = 6;
var PLAYER_MESSAGE = 7;
var ALLIANCE_MESSAGE = 8;

// Jawz - Capital and outposts IDs
var CAPITAL_ID = 0;
var SPECTRAL_OUTPOST_ID = 1;
var WATER_OUTPOST_ID = 2;
var STONE_OUTPOST_ID = 3;
var FIRE_OUTPOST_ID = 4;
var WIND_OUTPOST_ID = 5;

var IsChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

//
// Variables strings
//
// Terrain
var kAnthropusCamp		= 'AnthropusCamp';
var kCity				= 'City';
var kForest				= 'Forest';
var kGrassland			= 'Grassland';
var kHill				= 'Hill';
var kLake				= 'Lake';
var kMountain			= 'Mountain';
var kOutpost			= 'Outpost';
var kPlain				= 'Plain';
var kBog				= 'Bog';
var kWildernesses		= 'Wildernesses';
var kFog				= 'Fog';
var kSwamp				= 'Swamp'
;

// Buildings
var kDragonKeep			= 'DragonKeep';
var kFactory			= 'Factory';
var kFarm				= 'Farm';
var kFortress			= 'Fortress';
var kGarrison			= 'Garrison';
var kHome				= 'Home';
var kLumbermill			= 'Lumbermill';
var kMetalsmith			= 'Metalsmith';
var kMine				= 'Mine';
var kMusterPoint		= 'MusterPoint';
var kOfficerQuarter		= 'OfficerQuarter';
var kQuarry				= 'Quarry';
var kRookery			= 'Rookery';
var kScienceCenter		= 'ScienceCenter';
var kSentinel			= 'Sentinel';
var kSilo				= 'Silo';
var kStorageVault		= 'StorageVault';
var kTheater			= 'Theater';
var kTrainingCamp		= 'TrainingCamp';
var kWall				= 'Wall';
// Jawz - Added for spectral outpost
var kSpectralDragonKeep	= 'SpectralDragonKeep';
var kDarkPortal			= 'DarkPortal';
var kMausoleum			= 'Mausoleum';
var kEnergyCollector	= 'EnergyCollector';

// Research
var kAgriculture		= 'Agriculture';
var kWoodcraft			= 'Woodcraft';
var kMasonry			= 'Masonry';
var kMining				= 'Mining';
var kClairvoyance		= 'Clairvoyance';
var kRapidDeployment	= 'RapidDeployment';
var kBallistics			= 'Ballistics';
var kMetallurgy			= 'Metallurgy';
var kMedicine			= 'Medicine';
var kDragonry			= 'Dragonry';
var kLevitation			= 'Levitation';
var kMercantilism		= 'Mercantilism';
var kAerialCombat		= 'AerialCombat';
// Jawz - Added for spectral outpost
var kEnergyCollection	= 'EnergyCollection';
var kWarriorRevival		= 'WarriorRevival';
var kGuardianRevival	= 'GuardianRevival';

// Troops
var kArmoredTransport	= 'ArmoredTransport';
var kBattleDragon		= 'BattleDragon';
var kConscript			= 'Conscript';
var kFireMirror			= 'FireMirror';
var kGiant				= 'Giant';
var kHalberdsman		= 'Halberdsman';
var kLongbowman			= 'Longbowman';
var kMinotaur			= 'Minotaur';
var kPorter				= 'Porter';
var kSpy				= 'Spy';
var kSwiftStrikeDragon	= 'SwiftStrikeDragon';

// Special Troops
var kAquaTroop			= 'AquaTroop';
var kFireTroop			= 'FireTroop';
var kStoneTroop			= 'StoneTroop';
var kWindTroop			= 'WindTroop';
var kPackDragon			= 'PackDragon';

// Dragons
var kFireDragon			= 'FireDragon';
var kGreatDragon		= 'GreatDragon';
var kStoneDragon		= 'StoneDragon';
var kWaterDragon		= 'WaterDragon';
var kWindDragon			= 'WindDragon';
var kSpectralDragon		= 'SpectralDragon';

// Troop abbreviations
var kATrans		= 'ATrans';
var kWTroop		= 'Banshee';
var kBatDrg		= 'BatDrg';
var kConscr		= 'Conscr';
var kATroop		= 'Fang';
var kFireM		= 'FireM';
var kFireDrg	= 'FireDrg';
var kGrtDrg		= 'GrtDrg';
var kHalbrd		= 'Halbrd';
var kFTroop		= 'Magma';
var kLBM		= 'LBM';
var kMino		= 'Mino';
var kSTroop		= 'Ogre';
var kSSDrg		= 'SSDrg';
var kStnDrg		= 'StnDrg';
var kWatDrg		= 'WatDrg';
var kWndDrg		= 'WndDrg';
var kPackDrg	= 'PackDrg';
var kSpctDrg	= 'SpctDrg';

// Items
var kAquaTroopRespirator	= 'AquaTroopRespirator';
var kStoneTroopItem			= 'StoneTroopItem';
var kFireTroopItem			= 'FireTroopItem';
var kWindTroopItem			= 'WindTroopItem';

var kGDBodyArmor			= 'GreatDragonBodyArmor';
var kGDClawGuards			= 'GreatDragonClawGuards';
var kGDHelmet				= 'GreatDragonHelmet';
var kGDTailGuard			= 'GreatDragonTailGuard';

// Error messages
var kFatalSeedTitle	= 'ERROR WHILST FETCHING DATA FROM SERVER';
var kFatalSeedMsg	= 'Please disable the script and see if you are able to play the game manually. If normal play is possible then enable the script and try again. If the error persists please read the following post before submitting a report. If normal play is not possible then wait until it is and try again.';


// Main arrays used in the script
// Troops arrays
var all_unit_types		= [	kPorter, kConscript, kSpy, kHalberdsman, kMinotaur, kLongbowman, kSwiftStrikeDragon, kBattleDragon, kArmoredTransport, kGiant, kFireMirror,	kPackDragon, kAquaTroop, kStoneTroop, kFireTroop, kWindTroop];
var capital_units		= [	kPorter, kConscript, kSpy, kHalberdsman, kMinotaur, kLongbowman, kSwiftStrikeDragon, kBattleDragon, kArmoredTransport, kGiant, kFireMirror ];
var water_outpost_units	= [	kPorter, kConscript, kSpy, kHalberdsman, kMinotaur, kLongbowman, kSwiftStrikeDragon, kBattleDragon, kArmoredTransport, kGiant, kFireMirror, kAquaTroop];
var stone_outpost_units	= [	kPorter, kConscript, kSpy, kHalberdsman, kMinotaur, kLongbowman, kSwiftStrikeDragon, kBattleDragon, kArmoredTransport, kGiant, kFireMirror, kStoneTroop];
var fire_outpost_units	= [	kPorter, kConscript, kSpy, kHalberdsman, kMinotaur, kLongbowman, kSwiftStrikeDragon, kBattleDragon, kArmoredTransport, kGiant, kFireMirror, kFireTroop];
var wind_outpost_units	= [	kPorter, kConscript, kSpy, kHalberdsman, kMinotaur, kLongbowman, kSwiftStrikeDragon, kBattleDragon, kArmoredTransport, kGiant, kFireMirror, kWindTroop];
var all_trainable_units	= [	kPorter, kConscript, kSpy, kHalberdsman, kMinotaur, kLongbowman, kSwiftStrikeDragon, kBattleDragon, kArmoredTransport, kGiant, kFireMirror, kAquaTroop, kStoneTroop, kFireTroop, kWindTroop];
var attack_unit_types	= [	kPorter, kConscript, kSpy, kHalberdsman, kMinotaur, kLongbowman, kSwiftStrikeDragon, kBattleDragon, kArmoredTransport, kPackDragon,	kGiant, kFireMirror, kAquaTroop, kStoneTroop, kFireTroop, kWindTroop];
var wave_unit_types		= [	kSpy, kArmoredTransport, kPackDragon, kLongbowman, kSwiftStrikeDragon, kBattleDragon, kGiant, kFireMirror, kAquaTroop, kStoneTroop, kFireTroop, kWindTroop];
var spy_unit_types		= [	kSpy ];
var transport_unit_types= [	kPorter, kATrans, kPackDrg ]; // Beware : Use abbreviations here
// Resources arrays
var all_resource_types				= [	'gold', 'food', 'wood', 'ore', 'stone', 'blue_energy'];
var transportable_resource_types	= [	'gold', 'food', 'wood', 'ore', 'stone'];
// Buildings arrays
var capital_buildings	= [	kHome, kGarrison, kScienceCenter, kMetalsmith, kOfficerQuarter, kMusterPoint, kRookery, kStorageVault, kTheater, kSentinel, kFactory, kFortress, kDragonKeep, kWall];
var outpost_buildings	= [	kTrainingCamp, kHome, kSilo, kMusterPoint, kDragonKeep, kWall];
var field_buildings		= [	kMine, kFarm, kLumbermill, kQuarry];
var spectral_buildings	= [	kDarkPortal, kMausoleum, kSpectralDragonKeep];
var spectral_fields		= [	kEnergyCollector];
// Research arrays
var research_list		= {	Agriculture:'Agriculture', Woodcraft:kWoodcraft, Masonry:'Masonry', Mining:kMining, Clairvoyance:'Clairvoyance', RapidDeployment:'RapidDeployment', Ballistics:'Ballistics', Metallurgy:'Metallurgy', Medicine:'Medicine', Dragonry:kDragonry, Levitation:kLevitation, Mercantilism:'Mercantilism', AerialCombat:'AerialCombat', EnergyCollection:'EnergyCollection', WarriorRevival:'WarriorRevival', GuardianRevival:'GuardianRevival'};
var research_name		= [	kAgriculture, kWoodcraft, kMasonry, kMining, kClairvoyance, kRapidDeployment, kBallistics, kMetallurgy, kMedicine, kDragonry, kLevitation, kMercantilism, kAerialCombat, kEnergyCollection, kWarriorRevival, kGuardianRevival];
// Items arrays
var resource_item_list  = ['Wood500K', 'Wood250K', 'Wood80K', 'Wood50K', 'Wood25K', 'Wood10K', 'Stone500K', 'Stone250K', 'Stone80K', 'Stone50K', 'Stone25K', 'Stone10K', 
							'Food500K', 'Food250K', 'Food80K', 'Food50K', 'Food25K', 'Food10K', 'Ore500K', 'Ore250K', 'Ore80K', 'Ore50K', 'Ore25K', 'Ore10K', 
							'Gold200K', 'Gold50K', 'Gold25K', 'Gold10K'];
var time_item_list       = ['Blink', 'Hop', 'Skip', 'Jump', 'Leap', 'Bounce', 'Bore', 'Bolt', 'Blast', 'Blitz', 'TestroniusPowder', 'ForcedMarchDrops', 'TranceMarchDrops' ];
var production_item_list = ['AtlagenHarvestNanosDay', 'AtlagenHarvestNanosWeek', 'DryadForestNanosDay', 'DryadForestNanosWeek', 'OreadStoneNanosDay', 'OreadStoneNanosWeek', 
							'EpeoradMetalsNanosDay', 'EpeoradMetalsNanosWeek', 'DoubleTaxDayDeclaration', 'DoubleTaxWeekDeclaration', 'NanoCollectorWeek', 'NanoCollectorDay' ];
var general_item_list    = ['MassNullifier', 'CompletionGrant', 'DragonHearts', 'GlowingShields', 'CeaseFireTreaty', 'DarkWarpDevice', 'ChartedWarpDevice', 'PseudonymGrant', 
							'RenameProclamation', 'PurpleBones', 'CrimsonBull', 'FortunasTicket', 'FortunasGoldenTicket', 'OutpostWarp', 'DivineLigth', 'AncestralSeal',
							'RaceChangeItem', 'NomadicRecruits', 'DivineRations', 'MomentaryTruce', 'ArmisticeAgreement' ];
var chest_item_list      = ['NanoCanisters', 'CompletionGrantPortfolio', 'NanoCrates', 'TimeTrickstersBag'];
var arsenal_item_list    = ['AquaTroopRespirator', 'AquaTroopRespiratorStack100', 'AquaTroopRespiratorStack500', 'AquaTroopRespiratorStack1000',
							'StoneTroopItem', 'StoneTroopItemStack100', 'StoneTroopItemStack500', 'StoneTroopItemStack1000',
							'FireTroopItem', 'FireTroopItemStack100', 'FireTroopItemStack500', 'FireTroopItemStack1000',
							'WindTroopItem', 'WindTroopItemStack100', 'WindTroopItemStack500', 'WindTroopItemStack1000',
							'CurseWorms', 'CurseFrogs', 'CurseBats', 'CurseLocusts', 'PackDragon1000TroopPrizeItem',
							'AnthropusTalisman', 'AnthropusTalisman50K' ];



/*******************************************************************************
***************************      TRANSLATIONS      ****************************
*******************************************************************************/
var LANG_CODE = navigator.language.substring(0,2).toLowerCase();
var IS_NOT_NATIVE_LANG = (LANG_CODE !== 'en');
var TRANSLATION_ARRAY = {};

function setLanguage ( user_language ) {
LANG_CODE = user_language || LANG_CODE;
switch ( LANG_CODE ){
	/*******************************************************************************
		German  (by Northlight & rosebandit)
	*******************************************************************************/
case 'de':
	TRANSLATION_ARRAY = {
		'</B> and <B>' : '</B> und <B>',
		'<B>Attacker\'s move turn</B>' : '<B>Bewegungszug des Angreifers</B>',
		'<B>Attacker\'s attack turn</B>' : '<B>Angriffszug des Angreifers</B>',
		'<b>Bad request!</b>' : '<b>Ungültige Anfrage</b>',
		'<B>Defender\'s move turn</B>' : '<B>Bewegungszug des Verteidigers</B>',
		'<B>Defender\'s attack turn</B>' : '<B>Angriffszug des Verteidigers</B>',
		'<b>Rate Limit Exceeded</b>, too many requests!' : '<b>Serveranfragenlimit überschritten</b>',
		'Action Log' : 'Aktions Log',
		'Actions' : 'Aktionen',
		'Activate Attacks Logs' : 'Angriffslogs aktivieren',
		'Alerts log' : 'Alarmlog',
		'Alives' : 'Überlebt',
		'All alliances' : 'Alle Allianzen',
		'All players' : 'Alle Spieler',
		'All types' : 'Alle',
		'Alliance features' : 'Allianzinformation',
		'Alliance members list retrieved' : 'Mitgliederliste',
		'Alliance messages' : 'Allianznachrichten',
		'and' : 'und',
		'Another march request is pending' : 'Eine andere Marschanforderung ist unerledigt',
		'Arrival time' : 'Ankunftszeit',
		'at' : 'an',
		' at ' : ' an ',
		' at range' : ' in Reichweite',
		'Attack One Target in Waves' : 'Wellenangriff auf ein Ziel',
		'Attack sent to' : 'Angriff gesendet an',
		'Attack One Target in Multiple waves' : 'Multiwellenangriff auf ein Ziel',
		'Attacker' : 'Angreifer',
		'Attacking' : 'Angriff',
		'Attacks Configuration' : 'Angriffseinstellung',
		'Attacks Stats' : 'Angriffsstats',
		'Attacks' : 'Angriffe',
		'attempted' : 'versuche',
		'Attempted' : 'Versuche',
		'attempt for' : 'versuch für',
		'Auto harvest resources from outposts every' : 'Ressourcen einsammeln vom Aussenposten',
		'Auto refresh info tab data every' : 'automatisches Auffrischen des Info-Reiters alle',
		'Automatically' : 'Automatisch',
		'Automatically recall transport 1 minute before delivery' : 'Automatisches Zurückrufen 1 Min vor Lieferung',
		'Available troops' : 'Verfügbare Truppen',
		'Awaiting task completion notification' : 'erwarte Fertigmeldung',
		'Battle' : 'Kampf',
		'Battle calculator' : 'Kampf-Simulator',
		'Battle forces' : 'Streitkräfte',
		'Battle log' : 'Kampfbericht',
		'Battle lost !!' : 'Kampf verloren !!',
		'Battle mechanics' : 'Kampfmechaniken',
		'Battle won !!' : 'Kampf gewonnen !!',
		'blue_energy' : 'Blaue Energie',
		'Building' : 'Gebäude',
		'Busy' : 'Beschäftigt',
		'by' : 'von',
		'Calculate' : 'Simuliere',
		'Camps/wilds attack reports' : 'Anthro/Wildnis Kampfbericht',
		'Capital data' : 'Hauptstadtdaten',
		'Capital data successfully fetched' : 'Hauptstadtdaten erfolgreich eingelesen',
		'Check sentinel reports every ' : 'Überprüfe den Sentinelbericht alle',
		'Check to use UTC time instead of local time' : 'prüfe, ob UTC Zeit anstatt der eigenen Zeitzone verwendet werden soll',
		'Claim' : 'Holen',
		'Claimed' : 'Abgeholt',
		'Claiming quest' : 'Quest abholen',
		'Clear all data' : 'Alle Daten löschen',
		'Clear last attack on all maps' : 'Lösche die letzten Angriffe auf allen Karten',
		'Clear last attack on current map' : 'Lösche die letzten Angriffe auf der aktuellen Karte',
		'Clear log' : 'Log löschen',
		'Clear Stats' : 'Statistik löschen',
		'Collected resources at outpost' : 'eingesammelte Resourcen im Aussenposten',
		'Completing...' : 'Fertigstellen...',
		'Config' : 'Einstellung',
		'Console Log' : 'Konsolen Log',
		'Console' : 'Konsole',
		'Coordinates' : 'Koordinaten',
		'Coords' : 'Koords',
		' damages taken' : ' Schaden genommen',
		' damages to ' : ' Schaden verursacht am ',
		'data' : 'Daten',
		'data successfully fetched' : 'Daten erfolgreich eingesammelt',
		'Date range' : 'Daten Reichweite',
		'Day' : 'Tag',
		'Days' : 'Tage',
		' deal ' : ' Deal ',
		'Defender' : 'Verteigiger',
		'Defending' : 'Verteidigen',
		'Delay before script startup' : 'Verzögerung vor Scriptstart',
		'Delay Between Attacks' : 'Verzögerung zwischen Angriffen',
		'delayed due to' : 'Verzögerung, weil',
		'delayed due to march limit reached' : 'Verzögerung, weil Anzahl max Märsche erreicht wurde',
		'delayed due to muster point full' : 'Verzögerung, weil Truppensammelplatz voll ist',
		'delayed due to no available generals' : 'Verzögerung, weil keine Generäle verfügbar sind',
		'delayed due to no available Great Dragon' : 'Verzögerung, weil keine Drachen verfügbar sind',
		'delayed due to pending march request' : 'Verzögerung, weil die Anbrage zum Marsch hängt',
		'delayed due to insufficient troops' : 'Verzögerung, weil keine passenden Truppen verfügbar sind',
		'Delete now' : 'jetzt löschen',
		'Delete Battle Reports' : 'Kampfberichte löschen',
		'Delete messages' : 'Nachrichten löschen',
		'Delete messages of this type' : 'Nachrichten diesen Types löschen',
		'Delete spy reports' : 'Spion-Berichte löschen',
		'Disable <B>Alliance</B> tab' : 'Deaktivieren <B>Allianz</B> Reiter',
		'Disable <B>Battle</B> tab' : 'Deaktivieren <B>Kampf-Simulator</B> Reiter',
		'Disable <B>Multi</B> tab' : 'Deaktivieren <B>Multi</B> Reiter',
		'Disable <B>Search</B> tab' : 'Deaktivieren <B>Suche</B> Reiter',
		'Disable <B>Spy</B> tab' : 'Deaktivieren <B>Spio</B> Reiter',
		'Disable <B>Wave</B> tab' : 'Deaktivieren <B>Welle</B> Reiter',
		'Disable <B>Log</B> tab' : 'Deaktivieren <B>Log</B> Reiter',
		'Disabled' : 'Deaktiviert',
		'Dist' : 'Distanz',
		'Distance must be between' : 'Entfernung muß liegen zwischen',
		'Distance' : 'Distanz',
		'Dragon healing' : 'Drachen Heilung',
		'Dragons' : 'Drachen',
		'Do not show alerts obsolete since' : 'Keine Alarme anzeigen vor',
		'Enable use of speed-ups in attacks waves' : 'Beschleuniger in Attacken und Wellen benutzen',
		'Enable verbose logging' : 'Aktiviere ausführlichen Log',
		'Enable window drag' : 'Fensterverschiebung aktivieren',
		'Enable' : 'Aktivieren',
		'Enable the sentinel tower' : 'Aktiviere Sentinelturm',
		'Enabled' : 'Aktiviert',
		'End' : 'Ende',
		'Ennemy General' : 'Feindlicher General',
		'Ennemy research levels' : 'Feindlicher Forschungslevel',
		'Error' : 'Fehler',
		'Error while retrieving the list of members' : 'Fehler beim Empfang der Mitgliederliste',
		'Evol' : 'Evol',
		'Except' : 'außer',
		'Exception' : 'Ausnahme',
		'failed' : 'gescheitert',
		'failed and returned error' : 'gescheitert mit Fehler',
		'Features' : 'Features',
		'Fetching' : 'Auslesen',
		'Fetching Capital data' : 'Hauptstadtdaten auslesen',
		'Fetching Manifest' : 'Manifest auslesen',
		'Fetching Outpost #' : 'Aussenposten auslesen #',
		'Fetching Seed' : 'Seed auslesen',
		'Fetching Translation matrix' : 'Übersetzungsmatrix auslesen',
		'Fire' : 'Feuer',
		'First value must be between' : 'Erster Wert muß liegen zwischen ',
		'Game messages' : 'Spielnachrichten',
		'Game Options' : 'Spieloptionen',
		'Generals' : 'Generäle',
		'Getting basic data...' : 'Grunddaten abholen...',
		'Getting cities data...' : 'Städtedaten abholen...',
		'Getting game data...' : 'Spieldaten abholen... ',
		'Great dragons' : 'Gross-/Elementdrachen',
		'Hide spy alerts' : 'Verstecke Spionagealarme',
		'Hiding' : 'Verstecken',
		'History' : 'Zielespeicher',
		'h' : 'std',
		'Hour' : 'Stunde',
		'Hours' : 'Stunden',
		'Idle pop' : 'Freie Bürger',
		'Idle' : 'inaktiv',
		'idle' : 'inaktiv',
		' in melee' : ' im Nahkampf',
		'in progress' : 'in Barbeitung',
		'Include Great Dragon' : 'Groß-/Elementdrachen einschließen',
		'Info' : 'Info',
		'Initialization' : 'Initalisierung',
		'Initializing...' : 'initialisiere',
		'Initializing map, auto-collect, ...' : 'Initialisierung Karte, Auto-Einsammeln , ...',
		'Invalid date' : 'Falsches Datum',
		'Invalid Date From' : 'Falsches Datumsformat von',
		'Invalid Date To' : 'Falsches Datumsformat bis',
		'Invalid date range' : 'Falsche Datumsangabe',
		'Invalid delays' : 'Falsche Verzögerung',
		'Invalid number of troops' : 'ungültige Truppengröße',
		'Invalid Range Date' : 'Falschre Datumsbereich',
		'Inventory' : 'Inventar',
		'Keep battle reports of attacks from other players' : 'Kampfberichte anderer Spieler behalten',
		'Keep battle reports of my attacks on other players' : 'Meine Kampfberichte gegen andere Spieler behalten',
		' (kill ' : ' (töte ',
		'Killed' : 'Getötet',
		'Last Attack' : 'Letzter Angriff',
		'leader' : 'Anführer',
		'life lost' : 'Leben verloren',
		'Loaded' : 'Geladen',
		'Loading basic data' : 'Grunddaten laden',
		'Locale data was Successfully requested from the server' : 'Lokale Daten erfolgreich vom Server abgerufen',
		'Logs' : 'Log',
		'Log' : 'Log',
		'lord' : 'Lord',
		'Manifest not available, using defaults' : 'Manifest nicht verfügbar, nutze Standardeinstellungen',
		'Manifest Successfully initialized' : 'Manifest erfolgreich initialisiert',
		'Manifest was Successfully requested from the server' : 'Manifest erfolgreich vom Server abgerufen',
		'Manual attack sent to' : 'Manueller Angriff gesendet zu',
		'March limit reached' : 'Marschlimit erreicht',
		'Max level' : 'Max Level',
		'Map Search' : 'Kartensuche',
		'Maximum level reached' : 'Maximal-Level erreicht',
		'Maximum simultaneous marches' : 'Maximal gleichzeitige Märsche',
		'Maximum training queues possible per city, according to available resources' : 'Maximale Anzahl an Ausbildungsschleifen pro Stadt, bezogen auf die verfügbaren Ressourcen',
		'Members' : 'Mitglieder',
		'Members list ' : 'Mitgliederliste ',
		'Message(s) deleted' : 'Nachricht(en) gelöscht',
		'Message(s) deletion in progress' : 'Nachrichtenlöschung in Verarbeitung',
		'miles' : 'Meilen',
		'Min level' : 'Min Level',
		'Minute' : 'Minute',
		'Minutes' : 'Minuten',
		'minutes' : 'minuten',
		' move to ' : ' gehe zu ',
		'Multi' : 'Multi',
		'Muster Point Full' : 'Truppensammelplatz',
		'Need' : 'Benötigt',
		'New Version Available' : 'Neue Version verfügbar',
		'No Generals Available' : 'Keine Generäle verfügbar',
		'No great dragon available' : 'Keine Groß-/Elementdrachen verfügbar',
		'no max' : 'kein Maximum',
		'No resources to transport defined' : 'Keine Rohstoffe für Transport ausgewählt',
		'No targets or troops available' : 'Keine Ziele oder Truppen verfügbar',
		'No troops available' : 'Keine Truppen verfügbar',
		'No Troops Defined' : 'Keine Truppen ausgewählt',
		'Not enough' : 'Nicht genug',
		'Not' : 'nicht',
		'Not ready' : 'Nicht bereit',
		'of' : 'von',
		' of ' : ' von ',
		'one attack' : 'ein Angriff',
		'one spy' : 'ein Spion',
		'Only one training queue per city' : 'Nur eine Ausbildungsschleife pro Stadt ',
		'Options' : 'Optionen',
		'Opts' : 'Opts',
		'Outpost' : 'Aussenposten',
		'Outpost 1' : 'Wasseraussenposten',
		'Outpost 2' : 'Steinaussenposten',
		'Outpost 3' : 'Feueraussenposten',
		'Outpost 4' : 'Windaussenposten',
		'Outpost damages' : 'Schaden am Aussenposten',
		'overlord' : 'Oberster Lord',
		'Overview' : 'Übersicht',
		'Owner' : 'Besitzer',
		'Play for' : 'abspielen für',
		'Play sound on incoming sentinel report' : 'Sound bei eingehendem Sentinelbericht abspielen',
		'Player cities' : 'Spieler Städte',
		'Player cities list' : 'Liste Spieler Städte',
		'Player data was Successfully requested from the server' : 'Spielerdaten wurden erfolgreich vom Server abgefragt',
		'Player messages' : 'Spieler Nachrichten',
		'Player name' : 'Spielername',
		'Primary attack to ' : 'Primär Angriff auf ',
		'Putting build job in persistent data' : 'Bauauftrag in permante Daten erfassen',
		'Putting research job in persistent data' : 'Ausbildungsauftrag in permante Daten erfassen',
		'Putting resurrect job in persistent data' : 'Wiederbelebungauftrag in permante Daten erfassen',
		'Quest' : 'Quest',
		'Quest claim Error' : 'Fehler beim Quest abgeben',
		'Rate Limit Exceeded because there were too many requests' : 'Zulässige Anfragenzahl überschritten',
		'Read page ' : 'Seite auslesen ',
		'Ready' : 'Bereit',
		'Recipient' : 'Empfänger',
		'Refresh' : 'Auffrischen',
		'Refresh list' : 'Liste auffrischen',
		'Refresh map data' : 'Kartendaten auffrischen',
		'Reinforcement' : 'Verstärkung',
		'Reinforcement reports' : 'Verstärkungsbericht',
		'Reinforcement sent to' : 'Verstärkung von',
		'Reload' : 'Neuladen',
		'Remind me later' : 'Erinnere mich später',
		'Repairing' : 'Reparieren',
		'Repeat every' : 'Wiederholen alle',
		'Researching' : 'Forschen',
		'Reset Stats' : 'Statistik zurücksetzen',
		'Resources stock levels update failed' : 'Kapazitätenupdate gescheitert',
		'Resources to transport' : 'Rohstoffe zum Transportieren',
		'Resurrect' : 'Auferstehen',
		'Retry in' : 'Wiederholen in',
		'Reviving' : 'Wiederbelebung',
		'Role' : 'Rolle',
		'Rules' : 'Regeln',
		'Run Time' : 'Laufzeit',
		'Safe Mode' : 'Sicherheitsmodus',
		'Save Attaque' : 'Speichern',
		'Scanning Map' : 'Karte scannen',
		'Scanning map for cities/wildernesses<BR>This should take about couple minutes<BR>according to the radius entered' : 'scanne Karte <BR>Das dauert ein paar Minuten<BR> im angegeben Radius',
		'Script Options' : 'Script Optionen',
		'Search coords' : 'Koords suchen',
		'Search for alliance members' : 'Allianzmitglieder suchen',
		'Search max radius' : 'Max. Suchradius',
		'Search Radius' : 'Suchradius',
		'Second' : 'Sekunde',
		'Seconds' : 'Sekunden',
		'seconds' : 'Sekunden',
		'Secondary attack to ' : 'Zweite Attacke auf ',
		'Seed Successfully initialized' : 'Seed erfolgreich eingelesen',
		'Select at least one type of message or report to delete' : 'wähle mind. eine Nachricht oder einen Bericht zum Löschen',
		'Send reinforcement' : 'Verstärkung senden',
		'Send transport' : 'Transport senden',
		'Sending reinforcement' : 'Verstärkung senden',
		'Sending transport' : 'Transport senden',
		'Sentinel messages' : 'Sentinelnachricht',
		'Sentinel tower' : 'Sentinelturm',
		'several attacks' : 'einige Attacken',
		'several spies' : 'einige Spios',
		'Souls' : 'Seelen',
		'Sound configuration' : 'Soundeinstellung',
		'Sound file' : 'Sounddatei',
		'spectral_dragon outpost' : 'Spektral Ruine',
		'Spectral' : 'Spektral',
		'SpectralDragonKeep' : 'Drachenaltar',
		' spent. 1 min timeout (defense respawn)' : ' warte 1 min timeout (Verteidiger Respawn)',
		' spent. 2 min timeout (defense respawn)' : ' warte 2 min timeout (Verteidiger Respawn)',
		'Spies done' : 'Spione erledigt',
		'Spies number' : 'Anzahl Spione',
		'Spy One Target' : 'Ein Ziel spionieren',
		'Spy reports' : 'Spiobericht',
		'Spy to ' : 'Spion zu ',
		'Stars' : 'Sterne',
		'Start' : 'Start',
		'Start Date' : 'Startdatum',
		'Starting...' : 'Starten...',
		'Stone' : 'Stein',
		'Stop if any troops lost' : 'Stopp bei Truppenverlust',
		'succeeded' : 'gelungen',
		'Successfully initialized' : 'Erfolgreich initialisiert',
		'Successfully' : 'Erfolgreich',
		'Summary' : 'Zusammenfassung',
		' survivals)' : ' überlebt)',
		'Swamp' : 'Sumpf',
		'Tabs Options' : 'Tab Optionen',
		'Target' : 'Ziel',
		'Targets' : 'Ziele',
		'Task Completed' : 'Aufgabe komplett',
		'Tasks' : 'Aufgaben',
		'Terrain length set to ' : 'Gebietsgröße gesetzt auf ',
		'To be refreshed' : 'aktualiert',
		'Too many errors,  disabling auto train' : 'Zuviele Fehler, Autotraining abgestellt',
		'Too many troops for muster point level' : 'Zuviele Truppen für Truppensammelplatzstufe',
		'Total souls' : 'Seelen total',
		'Tower' : 'Wachturm',
		'Tower configuration' : 'Wachturmeinstellung',
		'Training Configuration' : 'Ausbildungseinstellung',
		'Training queue' : 'Ausbildungsschleife',
		'Translation Matrix Successfully initialized' : 'Übersetzung erfolgreich initialisiert ',
		'Transport reports' : 'Transportbericht',
		'Transport sent to' : 'Transport zu',
		'Troops Capped' : 'Truppen gestoppt',
		'Troops for reinforcement' : 'Truppen für Verstärkung',
		'Troops for Primary Attack' : 'Truppenauswahl für erste Attacke',
		'Troops for Secondary Attacks' : 'Truppenauswahl für zweite Attacke',
		'Troops for transport' : 'Truppen für Transport',
		'Troops for Wave Attack' : 'Truppen für Welle',
		'Troops lost' : 'Truppen verloren',
		'Troops Not Defined' : 'Truppen nicht defeniert',
		'Troops statistics for' : 'Truppenstatistik',
		'Turned Off' : 'Abgeschaltet',
		'Unowned only' : 'Nur unbesetzte Wildnisse',
		'Updating City values' : 'Stadteinstellungen aktualisieren',
		'Upgrading items' : 'Verbesserungs-Items',
		'Use the Levels Tab to select attack areas' : 'benutze den Level-Reiter, um das Angriffsgebiet auszuwählen',
		'Userset maximum marches reached' : 'Maximal eingestellte Märsche erreicht',
		'waiting' : 'warten',
		'Warnings' : 'Warnungen',
		'Warning for ' : 'Warnung für ',
		'was returned with a status of' : 'Status zurückgegeben',
		'Water' : 'Wasser',
		'Wave attack to ' : 'Wellenangriff auf ',
		'Wave' : 'Welle',
		'Wildernesses list' : 'Wildnissliste',
		'Wind' :'Wind',
		'You are' : 'Du bist',
		'Yoyo functionality' : 'Jo-Jo Funktion',
		'ATrans' : 'Luftis',    /* abbr Armored Transport */
		'Fang' : 'Giftis',      /* abbr Aqua Troop */
		'BatDrg' : 'KampfDr',   /* abbr Battle Dragon */
		'Conscr' : 'Rekrut',    /* abbr Conscript */
		'FireDrg' : 'FeuerDr',  /* abbr Fire Dragon */
		'FireM' : 'FeuerSp',    /* abbr Fire Mirror */
		'Magma' : 'Pyro',       /* abbr Fire Troop - Magmasaurus */
		'GrtDrg' : 'GroßDr',       /* abbr Great Dragon */
		'Halbrd' : 'Helle',     /* abbr Halberdsman */
		'LBM' : 'Bogi',         /* abbr Longbowman */
		'Mino' : 'Mino',        /* abbr Minotaur */
		'PackDrg' : 'TransportDr',  /* abbr Pack dragons */
		'SSDrg' : 'kFD',        /* abbr Swift Strike Dragon */
		'StnDrg' : 'SteinDr',   /* abbr Stone Dragon */
		'Ogre' : 'Oger',        /* abbr Stone Troop - Ogre */
		'WatDrg' : 'WasserDr',  /* abbr Water Dragon */
		'WndDrg' : 'WindDr',        /* abbr Wind Dragon */
		'Banshee' : 'Banshee',  /* abbr Wind Troop - Banshee */
		// Objects
		'WaterEgg' : 'Wasserdrachen-Ei',
		'StoneEgg' : 'Steindrachen- Ei',
		'FireEgg' : 'Feuerdrachen-Ei',
		'WindEgg' : 'Winddrachen-Ei',
		'GD Body' : 'GD-Körperschutz',
		'GD Helmet' : 'GD-Helm',
		'GD Tail' : 'GD-Schweif',
		'GD Claw' : 'GD-Klauenschutz',
		'WD Body' : 'WaD-Körperschutz',
		'WD Helmet' : 'WaD-Helm',
		'WD Tail' : 'WaD-Schweif',
		'WD Claw' : 'WaD-Klauenschutz',
		'SD Body' : 'SD-Körperschutz',
		'SD Helmet' : 'SD-Helm',
		'SD Tail' : 'SD-Schweif',
		'SD Claw' : 'SD-Klauen-Schutz',
		'FD Body' : 'FD-Körperschutz',
		'FD Helmet' : 'FD-Helm',
		'FD Tail' : 'FD-Schweif',
		'FD Claw' : 'FD-Klauenschutz',
		'WiD Body' : 'WiD-Körperschutz',
		'WiD Helmet' : 'WiD-Helm',
		'WiD Tail' : 'WiD-Schweif',
		'WiD Claw' : 'WiD-Klauenschutz',
		'Respirators' : 'Atemgeräte',
		'Respirator-100' : '100 Atemgeräte',
		'Respirator-500' : '500 Atemgräte',
		'Respirator-1000' : '1000 Atemgeräte',
		'Mandrakes' : 'Zauberwurzeln',
		'Mandrakes-100' : '100 Zauberwurzeln',
		'Mandrakes-500' : '500 Zauberwurzeln',
		'Mandrakes-1000' : '1000 Zauberwurzeln',
		'Runes' : 'Runen',
		'Runes-100' : '100 Runen',
		'Runes-500' : '500 Runen',
		'Runes-1000' : '1000 Runen',
		'Talons' : 'Krallen',
		'Talons-100' : '100 Krallen',
		'Talons-500' : '500 Krallen',
		'Talons-1000' : '1000 Krallen',
		'Zzz' : 'Zzz'
		//'Scanning map for cities/wildernesses' : 'Scanne die Karte nach Städten und Wildnissen',
	};
	break;
	/*******************************************************************************
		Español (by Phantomas)
	*******************************************************************************/
case 'es':
	TRANSLATION_ARRAY = {
		'</B> and <B>' : '</B> y <B>',
		'<B>Attacker\'s move turn</B>' : '<B>Turno de movimiento del Atacante</B>',
		'<B>Attacker\'s attack turn</B>' : '<B>Turno de ataque del Atacante</B>',
		'<b>Bad request!</b>' : '<b>Solicitud incorrecta!</b>',
		'<B>Defender\'s move turn</B>' : '<B>Turno de movimiento del Defensor</B>',
		'<B>Defender\'s attack turn</B>' : '<B>Turno de ataque del Defensor</B>',
		'<b>Rate Limit Exceeded</b>, too many requests!' : '<b>Excedió el límite de las solicitudes</b>, demasiado muchas solicitudes enviadas',
		'Action Log' : 'Reporte de Acciones',
		'Actions' : 'Acciones',
		'Activate Attacks Logs' : 'Activar Registro de Ataques',
		'Alerts log' : 'Log alertas',
		'Alives' : 'Sobrevivientes',
		'All alliances' : 'Todas la alianzas',
		'All players' : 'Todos los Jugadores',
		'All types' : 'Todos',
		'Alliance features' : 'Informacion de Alianzas',
		'Alliance members list retrieved' : 'Listado de Miembros de la alianza',
		'Alliance messages' : 'Mensajes de Alianza',
		'and' : 'y',
		'Another march request is pending' : 'Otra solicitud de marcha encuentra pendiente',
		'Arrival time' : 'Tiempo de Arrivo',
		'at' : 'a',
		' at ' : ' a ',
		' at range' : ' à distancia',
		'Attack One Target in Waves' : 'Atacar un Objetivo en olas',
		'Attack sent to' : 'Ataque enviado a',
		'Attack One Target in Multiple waves' : 'Ataque en Olas Multiple',
		'Attacker' : 'Atacante',
		'Attacking' : 'Atacando',
		'Attacks Configuration' : 'Configuración de Ataques',
		'Attacks Stats' : 'Estadísticas de Ataques',
		'Attacks' : 'Ataques',
		'Attempted' : 'Intentado',
		'attempted' : 'intentado',
		'attempt for' : 'intento de',
		'Auto harvest resources from outposts every' : 'Auto-Recolectar recursos de Avanzadas cada',
		'Auto refresh info tab data every' : 'Auto-Refrescar de datos de la info tab cada',
		'Automatically' : 'Automáticamente',
		'Automatically recall transport 1 minute before delivery' : 'Regresar el envio 1 minuto despues de ser enviado',
		'Available troops' : 'tropas disponibles',
		'Awaiting task completion notification' : 'En espera de la notificación de finalización de la tarea',
		'Battle' : 'Simul',
		'Battle calculator' : 'Simulacion de Batalla',
		'Battle forces' : 'Fuerzas de Batalla',
		'Battle log' : 'Log Simulacion',
		'Battle lost !!' : 'Batalla Perdida !!',
		'Battle mechanics' : 'Mecanica de Batallas',
		'Battle won !!' : 'Batalla Ganada !!',
		'blue_energy' : 'Energy azul',
		'Building' : 'Construccion',
		'Busy' : 'Ocupado',
		'by' : 'por',
		'Calculate' : 'Inicie la simulación',
		'Camps/wilds attack reports' : 'Reportes de ataques a Paramos',
		'Capital data' : 'Datos de la capital',
		'Capital data successfully fetched' : 'Datos de la capital a buscar con éxito',
		'Check sentinel reports every ' : 'Verificar reportes de sentinela cada ',
		'Check to use UTC time instead of local time' : 'Marque la casilla para utilizar la hora UTC en lugar de la hora local',
		'Claim' : 'Reclamo',
		'Claimed' : 'Reclamada',
		'Claiming quest' : 'Reclamar de la misión',
		'Clear all data' : 'Borrar Todo',
		'Clear last attack on all maps' : 'Borrar todos los registros de últimos ataques',
		'Clear last attack on current map' : 'Borrar registro de últimos ataques actuales',
		'Clear log' : 'Borrar Log',
		'Clear Stats' : 'Borrar Estadísticas',
		'Collected resources at outpost' : 'Recursos recolectados de avanzada',
		'Completing...' : 'Finalizando...',
		'Config' : 'Config',
		'Console Log' : 'Registros de Consola',
		'Console' : 'Consola',
		'Coordinates' : 'Coordenadas',
		'Coords' : 'Coords',
		' damages taken' : ' daños sufridos',
		' damages to ' : ' daños à ',
		'data' : 'datos',
		'data successfully fetched' : 'datos con éxito a buscar',
		'Date range' : 'Rango de tiempo',
		'Day' : 'Dia',
		'Days' : 'Dias',
		' deal ' : ' daño ',
		'Defender' : 'Defensor',
		'Defending' : 'En defensa',
		'Delay before script startup' : 'Retraso inicial antes arranque del script',
		'Delay Between Attacks' : 'Tiempo de retraso entre ataques',
		'delayed due to' : 'retrasado,',
		'delayed due to march limit reached' : 'retrasado, alcanzó el número máximo de marchas',
		'delayed due to muster point full' : 'retrasado, punto de encuentro completo',
		'delayed due to no available generals' : 'retrasado, no hay geneal disponible',
		'delayed due to no available Great Dragon' : 'retrasado, Gran Dragon no disponible',
		'delayed due to pending march request' : 'retrasado, otra solicitud de marcha encuentra pendiente',
		'delayed due to insufficient troops' : 'retrasado debido a las tropas insuficientes',
		'Delete now' : 'Borrar',
		'Delete Battle Reports' : 'Borrar reportes de batalla',
		'Delete messages' : 'Borrar Mensajes',
		'Delete messages of this type' : 'Borrar mensajes de este tipo',
		'Delete spy reports' : 'Suprimir reportes de Espias',
		'Disable <B>Alliance</B> tab' : 'Desactivar <B>Alianza</B>',
		'Disable <B>Battle</B> tab' : 'Desactivar <B>Simulador</B>',
		'Disable <B>Multi</B> tab' : 'Desactivar <B>Multi</B>',
		'Disable <B>Search</B> tab' : 'Desactivar <B>Busqueda</B>',
		'Disable <B>Spy</B> tab' : 'Desactivar <B>Espias</B>',
		'Disable <B>Wave</B> tab' : 'Desactivar <B>Oleadas</B>',
		'Disable <B>Log</B> tab' : 'Desactivar <B>Log</B>',
		'Disabled' : 'Desactivado',
		'Dist' : 'Dist',
		'Distance must be between' : 'La distancia debe estar entre',
		'Distance' : 'Distancia',
		'Dragon healing' : 'Curando Dragon',
		'Dragons' : 'Dragones',
		'Do not show alerts obsolete since' : 'No mostrar alertas obsoletas desde',
		'Enable use of speed-ups in attacks waves' : 'Permitir el uso de aceleraciones de las ondas de ataque',
		'Enable verbose logging' : 'Activar el registro detallado',
		'Enable window drag' : 'Permiten arrastrar la ventana',
		'Enable' : 'Activar',
		'Enable the sentinel tower' : 'Activar Torre Sentinela',
		'Enabled' : 'Activado',
		'End' : 'Finalizar',
		'Ennemy General' : 'General Enemigo',
		'Ennemy research levels' : 'Niveles de investigacion del enemigo',
		'Error' : 'Error',
		'Error while retrieving the list of members' : 'Error al buscar Miembro',
		'Evol' : 'Evol',
		'Exception' : 'Exepto',
		'failed' : 'fracasado',
		'failed and returned error' : 'fracasado y devolvió el error',
		'Features' : 'Funcionalidades',
		'Fetching' : 'Obtención',
		'Fetching Capital data' : 'Obtención de datos de la capital',
		'Fetching Manifest' : 'Obtención de manifiesto',
		'Fetching Outpost #' : 'Obtención de Outpost #',
		'Fetching Seed' : 'Obtención de datos del jugador',
		'Fire' : 'Fuego',
		'First value must be between' : 'El primer valor debe ser de',
		'Game messages' : 'Mensajes de Juego',
		'Game Options' : 'Opciones del Juego',
		'Generals' : 'Generales',
		'Getting basic data...' : 'Obtención de datos básicos',
		'Getting cities data...' : 'Obtención de datos de las ciudades',
		'Getting game data...' : 'Obtención de datos del juego',
		'Great dragons' : 'Dragones Elementales',
		'Hide spy alerts' : 'Esconder alertas de espias',
		'Hiding' : 'Santuario',
		'History' : 'Historia',
		'h' : 'h',
		'Hour' : 'Hora',
		'Hours' : 'Horas',
		'Idle pop' : 'Población inactiva',
		'Idle' : 'Inactivo',
		'idle' : 'esperando',
		' in melee' : ' cuerpo a cuerpo',
		'in progress' : 'en progreso',
		'Include Great Dragon' : 'Enviar Gran Dragon en el Ataque',
		'Info' : 'Info',
		'Initialization' : 'inicialización',
		'Initializing...' : 'inicializar...',
		'Initializing map, auto-collect, ...' : 'Inicializar el mapa, la recopilación automática, ...',
		'Invalid date' : 'Dato invalido',
		'Invalid Date From' : 'Formato de fecha de inicio invalido',
		'Invalid Date To' : 'Formato de fecha de finalizacion invalido',
		'Invalid date range' : 'Rango de datos invalido',
		'Invalid delays' : 'Intervalo de retraso invalido',
		'Invalid number of troops' : 'Cantidad de tropas invalida',
		'Invalid Range Date' : 'Rango de fecha invalido',
		'Inventory' : 'Inventario',
		'Keep battle reports of attacks from other players' : 'Guardar los reportes de ataque de otros jugadores al mio',
		'Keep battle reports of my attacks on other players' : 'Guardas los reportes de ataques mios hacia otro jugador',
		' (kill ' : ' (asesinado ',
		'Killed' : 'Asesinados',
		'Last Attack' : 'Ultimo ataque',
		'leader' : 'Lider',
		'life lost' : 'vida perdida',
		'Loaded' : 'Script cargado',
		'Loading basic data' : 'Carga de datos básicos',
		'Locale data was Successfully requested from the server' : 'Solicitud para los datos de traducción ha sido procesada correctamente por el servidor',
		'Logs' : 'Log',
		'Log' : 'Log',
		'lord' : 'Señor',
		'Manifest not available, using defaults' : 'Manifiesto no disponible, utilizando los valores predeterminados',
		'Manifest Successfully initialized' : 'Manifiesto inicializado correctamente',
		'Manifest was Successfully requested from the server' : 'Solicitud para el Manifiesto ha sido procesada correctamente por el servidor',
		'Manual attack sent to' : 'Ataque manual enviado a',
		'March limit reached' : 'Alcanzó el número máximo de marchas',
		'Max level' : 'Nivel max',
		'Map Search' : 'Buscando en mapa',
		'Maximum level reached' : 'Nivel máximo alcanzado',
		'Maximum simultaneous marches' : 'Maximo de marchas simultaneas',
		'Maximum training queues possible per city, according to available resources' : 'Máximas posible de formación por la ciudad, según los recursos disponibles',
		'Members' : 'Miembros',
		'Members list ' : 'Listado de miembros ',
		'Message(s) deleted' : 'Mensajes Borrados',
		'Message(s) deletion in progress' : 'Borrando mensajes',
		'miles' : 'millas',
		'Min level' : 'Nivel min',
		'Minute' : 'Minuto',
		'Minutes' : 'Minutos',
		'minutes' : 'minutos',
		' move to ' : ' mover a ',
		'Multi' : 'Multi',
		'Muster Point Full' : 'Punto de encuentro completo',
		'Need' : 'Req',
		'New Version Available' : 'Nueva Versión Disponible',
		'No Generals Available' : 'No hay geneal disponible',
		'No great dragon available' : 'Gran Dragon no disponible',
		'no max' : 'sin limite',
		'No resources to transport defined' : 'no se definieron recursos a transportar',
		'No targets or troops available' : 'No hay objetivos o tropas disponibles',
		'No troops available' : 'No hay suficientes tropas',
		'No Troops Defined' : 'No hay tropas definidas',
		'Not enough' : 'No hay suficiente',
		'Not' : 'No',
		'Not ready' : 'No listo',
		'of' : 'de',
		' of ' : ' de ',
		'one attack' : 'un ataque',
		'one spy' : 'un espia',
		'Only one training queue per city' : 'Sólo una cola de formación por ciudad',
		'Options' : 'Opciones',
		'Opts' : 'Opcs',
		'Outpost' : 'Puesto de Avanzada',
		'Outpost 1' : 'Ciudad del Agua',
		'Outpost 2' : 'Ciudad de la Piedra',
		'Outpost 3' : 'Ciudad del Fuego',
		'Outpost 4' : 'Ciudad del Viento',
		'Outpost damages' : 'Daños causados en avanzada',
		'overlord' : 'Señor Feudal',
		'Overview' : 'Resumen General',
		'Owner' : 'Propietario',
		'Play for' : 'Sonar para',
		'Play sound on incoming sentinel report' : 'Sonar alarma cuando entre reporte de sentinela',
		'Player cities' : 'Ciudades',
		'Player cities list' : 'Lista de Ciudades de jugador',
		'Player data was Successfully requested from the server' : 'Solicitud para los datos del jugador ha sido procesada correctamente por el servidor',
		'Player messages' : 'Mensajes de Jugador',
		'Player name' : 'Nombre del jugador',
		'Primary attack to ' : 'Primario ataque a ',
		'Putting build job in persistent data' : 'Guardando tareas de edificación en datos persistentes',
		'Putting research job in persistent data' : 'Guardando tareas de investigación en datos persistentes',
		'Putting resurrect job in persistent data' : 'Guardando tareas de resurrección en datos persistentes',
		'Quest' : 'Misión',
		'Quest claim Error' : 'Error de reclamación',
		'Rate Limit Exceeded because there were too many requests' : 'Excedió el límite de las solicitudes, demasiado muchas solicitudes se han enviadas',
		'Read page ' : 'Lectura de la pagina ',
		'Ready' : 'Listo',
		'Recipient' : 'Destinatario',
		'Refresh' : 'Refrescar',
		'Refresh list' : 'Refrescar lista',
		'Refresh map data' : 'Refrescar datos del mapa',
		'Reinforcement' : 'Refuerzos',
		'Reinforcement reports' : 'Reportes de refuerzosr',
		'Reinforcement sent to' : 'Refuerzos enviados a',
		'Reload' : 'Actualizar DOA',
		'Remind me later' : 'Recordarmelo luego',
		'Repairing' : 'Reparando',
		'Repeat every' : 'Repetir cada',
		'Researching' : 'Investigando',
		'Reset Stats' : 'Borrar Estadisticas',
		'Resources stock levels update failed' : 'Actualización de los niveles de inventario de los recursos ha fracasado',
		'Resources to transport' : 'Recursos a transportar',
		'Resurrect' : 'Resucitar',
		'Retry in' : 'Reintentando en',
		'Reviving' : 'Reviviendo',
		'Role' : 'Rol',
		'Rules' : 'Reglas',
		'Run Time' : 'Tiempo de ejecucion',
		'Safe Mode' : 'Modo Seguro',
		'Save Attaque' : 'Guardar Ataque',
		'Scanning Map' : 'Buscando datos en $NUM$ millas a la redonda<BR>Este proceso puede demorar un tiempo',
		'Scanning map for cities/wildernesses<BR>This should take about couple minutes<BR>according to the radius entered' : 'Buscando Ciudades y Paramos en el mapa<BR>esto puede demorar unos minutos<BR>En funcion del radio ingresado',
		'Script Options' : 'Opciones del script',
		'Search coords' : 'Buscando coords',
		'Search for alliance members' : 'Buscador de miembro de alianza',
		'Search max radius' : 'Radio Max. Busqueda',
		'Search Radius' : 'Radio de Busqueda',
		'Second' : 'Segundo',
		'Seconds' : 'Segundos',
		'seconds' : 'segundos',
		'Secondary attack to ' : 'Secundario ataque a ',
		'Seed Successfully initialized' : 'Datos del jugador inicializado correctamente',
		'Select at least one type of message or report to delete' : 'Seleccion por lo menos un tipo de mensaje o reporte para borrar',
		'Send reinforcement' : 'Enviar refuerzos',
		'Send transport' : 'Enviar Transportes',
		'Sending reinforcement' : 'Enviando refuerzos',
		'Sending transport' : 'Enviando Transporte',
		'Sentinel messages' : 'Alertas de Sentinela',
		'Sentinel tower' : 'Torre de Sentinela',
		'several attacks' : 'muchos ataques',
		'several spies' : 'muchos espias',
		'Souls' : 'Almas',
		'Sound configuration' : 'Configuracion de Sonido',
		'Sound file' : 'Sonido',
		'spectral_dragon outpost' : 'Ruinas Espectrales',
		'Spectral' : 'Espectral',
		'SpectralDragonKeep' : 'Altar del Dragón',
		' spent. 1 min timeout (defense respawn)' : ' Demora de 1 minutos para restablecer defensa',
		' spent. 2 min timeout (defense respawn)' : ' Demora de 2 minutos para restablecer defensa',
		'Spies done' : 'Espionajes efectuados',
		'Spies number' : 'Numero de Espias',
		'Spy One Target' : 'Espias un objetivo',
		'Spy reports' : 'Reportes de espionaje',
		'Spy to ' : 'Espias enviados a ',
		'Stars' : 'Estrellas',
		'Start' : 'Iniciar',
		'Start Date' : 'Fecha de Inicio',
		'Starting...' : 'Puesta en marcha...',
		'Stone' : 'Piedra',
		'Stop if any troops lost' : 'Detener si pierdo tropas',
		'succeeded' : 'se las arregló',
		'Successfully initialized' : 'Inicializado correctamente',
		'Successfully' : 'Exitosamente',
		'Summary' : 'Detalles',
		' survivals)' : ' sobrevivientes)',
		'Swamp' : 'Pantano',
		'Tabs Options' : 'Opciones de Tabs',
		'Target' : 'Objetivo',
		'Targets' : 'Objetivos',
		'Task Completed' : 'Tarea Finalizada',
		'Tasks' : 'Tareas',
		'Terrain length set to ' : 'Largo de terreno en ',
		'To be refreshed' : 'a Refrescar',
		'Too many errors,  disabling auto train' : 'Demasiados errores, desactivado adiestramientos',
		'Too many troops for muster point level' : 'Demasiadas tropas para el Nivel actual del Punto de Encuentro',
		'Total souls' : 'Total de las almas',
		'Tower' : 'Torres',
		'Tower configuration' : 'Configuracion de Sentinela',
		'Training Configuration' : 'Configuracion de entrenamiento',
		'Training queue' : 'Encolando Adistramientos',
		'Translation Matrix Successfully initialized' : 'Traducción Matrix inicializado correctamente',
		'Transport reports' : 'Reportes de Transporte',
		'Transport sent to' : 'Transporte enviado a',
		'Troops Capped' : 'Las tropas tope',
		'Troops for reinforcement' : 'Tropas para reforzar',
		'Troops for Primary Attack' : 'Tropas para ataque principal',
		'Troops for Secondary Attacks' : 'Tropas para ataque secundario',
		'Troops for transport' : 'Tropas para Transporte',
		'Troops for Wave Attack' : 'Tropas para ataque en olas',
		'Troops lost' : 'Tropas perdidas',
		'Troops Not Defined' : 'No hay tropas definidas',
		'Troops statistics for' : 'Estadísticas para',
		'Turned Off' : 'Desactivado',
		'Unowned only' : 'Libres solamente',
		'Updating City values' : 'Actualización de los datos de la ciudad',
		'Upgrading items' : 'Items especiales',
		'Use the Levels Tab to select attack areas' : 'Usar la solapa de Niveles para seleccionar el rango de ataque',
		'Userset maximum marches reached' : 'Numero maximo de marchas alcanzado',
		'waiting' : 'esperando',
		'Warnings' : 'Advertencias',
		'Warning for ' : 'Esperando para ',
		'was returned with a status of' : 'ha devolvió el estado de',
		'Water' : 'Aqua',
		'Wave attack to ' : 'Ataque en Oleada a ',
		'Wave' : 'Oleadas',
		'Wildernesses list' : 'Listado de Paramos',
		'Wind' : 'Viento',
		'You are' : 'Tu eres',
		'Yoyo functionality' : 'Funcionalidad Yoyo',
		'ATrans' : 'Globo',		/* abbr Armored Transport */
		'Fang' : 'Tritón',		/* abbr Aqua Troop */
		'BatDrg' : 'DrgComb',	/* abbr Battle Dragon */
		'Conscr' : 'Conscr',	/* abbr Conscript */
		'FireDrg' : 'DrgFue',	/* abbr Fire Dragon */
		'FireM' : 'EFuego',		/* abbr Fire Mirror */
		'Magma' : 'Magma',		/* abbr Fire Troop - Magmasaurus */
		'GrtDrg' : 'GrnDrg',	/* abbr Great Dragon */
		'Halbrd' : 'Alabar',	/* abbr Halberdsman */
		'LBM' : 'Arcos',		/* abbr Longbowman */
		'Mino' : 'Mino',		/* abbr Minotaur */
		'PackDrg' : 'DrgTrans',	/* abbr Pack dragons */
		'SSDrg' : 'DRapid',		/* abbr Swift Strike Dragon */
		'StnDrg' : 'DrgPie',	/* abbr Stone Dragon */
		'Ogre' : 'Ogro',		/* abbr Stone Troop - Ogre */
		'WatDrg' : 'DrgAgua',	/* abbr Water Dragon */
		'WndDrg' : 'DraCef',	/* abbr Wind Dragon */
		'Banshee' : 'Banshee',	/* abbr Wind Troop - Banshee */
		// Objects
		'WaterEgg' : 'Huevo Agua',
		'StoneEgg' : 'Huevo Piedra',
		'FireEgg' : 'Huevo Fuego',
		'WindEgg' : 'Huevo Cefiro',
		'GD Body' : 'Armadura GD',
		'GD Helmet' : 'Casco GD',
		'GD Tail' : 'Protector GD',
		'GD Claw' : 'Garras GD',
		'WD Body' : 'Armadura DAg',
		'WD Helmet' : 'Casco DAg',
		'WD Tail' : 'Protector DAg',
		'WD Claw' : 'Garras DAg',
		'SD Body' : 'Armadura DdP',
		'SD Helmet' : 'Casco DdP',
		'SD Tail' : 'Protector DdP',
		'SD Claw' : 'Garras DdP',
		'FD Body' : 'Armadura DdF',
		'FD Helmet' : 'Casco DdF',
		'FD Tail' : 'Protector DdF',
		'FD Claw' : 'Garras DdF',
		'WiD Body' : 'Armadura DCe',
		'WiD Helmet' : 'Casco DCe',
		'WiD Tail' : 'Protector DCe',
		'WiD Claw' : 'Garras DCe',
		'Respirators' : 'Respiradores',
		'Respirator-100' : '100 Respiradores',
		'Respirator-500' : '500 Respiradores',
		'Respirator-1000' : '1000 Respiradores',
		'Mandrakes' : 'Mandragoras',
		'Mandrakes-100' : '100 Mandragoras',
		'Mandrakes-500' : '500 Mandragoras',
		'Mandrakes-1000' : '1000 Mandragoras',
		'Runes' : 'Runas',
		'Runes-100' : '100 Runas',
		'Runes-500' : '500 Runas',
		'Runes-1000' : '1000 Runas',
		'Talons' : 'Garras',
		'Talons-100' : '100 Garras',
		'Talons-500' : '500 Garras',
		'Talons-1000' : '1000 Garras',
		'Zzz' : 'Zzz'
	};
	break;
	/**********************************************************************
	     Français  (by Jawz)
	***********************************************************************/
case 'fr':
	TRANSLATION_ARRAY = {
		'</B> and <B>' : '</B> et <B>',
		'<B>Attacker\'s move turn</B>' : '<B>Déplacement des unités offensives</B>',
		'<B>Attacker\'s attack turn</B>' : '<B>Attaque des unités offensives</B>',
		'<b>Bad request!</b>' : '<b>Mauvaise requête!</b>',
		'<B>Defender\'s move turn</B>' : '<B>Déplacement des unités défensives</B>',
		'<B>Defender\'s attack turn</B>' : '<B>Riposte des unités défensives</B>',
		'<b>Rate Limit Exceeded</b>, too many requests!' : '<b>Limitation des Requêtes Dépassée</b>, Trop de requêtes envoyées!',
		'Action Log' : 'Journal d\'évenements',
		'Actions' : 'Actions',
		'Activate Attacks Logs' : 'Activer journalisation des attaques',
		'Alerts log' : 'Log alertes',
		'Alives' : 'Survécu',
		'All alliances' : 'Toutes alliances',
		'All players' : 'Tous les joueurs',
		'All types' : 'Tous les types',
		'Alliance features' : 'Fonctionnalités Alliance',
		'Alliance members list retrieved' : 'Liste des membres de l\'alliance récupérée',
		'Alliance messages' : 'Message de l\'alliance',
		'and' : 'et',
		'Another march request is pending' : 'Une autre demande de marche est en attente',
		'Arrival time' : 'Heure arrivée',
		'at' : 'à',
		' at ' : ' à ',
		' at range' : ' à distance',
		'Attack One Target in Waves' : 'Attaquer une cible en Vagues',
		'Attack sent to' : 'Attaque envoyée sur',
		'Attack One Target in Multiple waves' : 'Attaquer une cible en Vagues successives',
		'Attacker' : 'Attaquant',
		'Attacking' : 'Attaque',
		'Attacks Configuration' : 'Configuration Attaques',
		'Attacks Stats' : 'Statistiques attaques',
		'Attacks' : 'Attaques',
		'Attempted' : 'Tenté',
		'attempted' : 'tenté',
		'attempt for' : 'tentative pour',
		'Auto harvest resources from outposts every' : 'Collecte automatique des outposts chaque',
		'Auto refresh info tab data every' : 'Rafraîchissement auto des données de l\'onglet info chaque',
		'Automatically' : 'Automatiquement',
		'Automatically recall transport 1 minute before delivery' : 'Rappel automatique du transport une minute avant livraison',
		'Available troops' : 'Troupes disponibles',
		'Awaiting task completion notification' : 'En attente de la notification de fin de tâche',
		'Battle' : 'Simul',
		'Battle calculator' : 'Simulation bataille',
		'Battle forces' : 'Forces de bataille',
		'Battle log' : 'Log de bataille',
		'Battle lost !!' : 'Bataille perdue !!',
		'Battle mechanics' : 'Mécanique des bataille',
		'Battle won !!' : 'Bataille gagnée !!',
		'blue_energy' : 'Energie bleue',
		'Building' : 'Construction',
		'Busy' : 'Occupé',
		'by' : 'par',
		'Calculate' : 'Lancer simulation',
		'Camps/wilds attack reports' : 'Rapports d\'attaque de camps/ES',
		'Capital data' : 'Données de la ville principale',
		'Capital data successfully fetched' : 'Données de la ville principale chargée avec succès',
		'Check sentinel reports every ' : 'Contrôler les rapports de sentinelle chaque ',
		'Check to use UTC time instead of local time' : 'Cocher pour afficher l\'heure UTC à la place de l\'heure locale',
		'Claim' : 'Réclame',
		'Claimed' : 'Réclamé',
		'Claiming quest' : 'Réclamation',
		'Clear all data' : 'Réinitialiser données',
		'Clear last attack on all maps' : 'Réinitialiser toutes les cartes',
		'Clear last attack on current map' : 'Réinitialiser les attaques sur la carte',
		'Clear log' : 'Effacer log',
		'Clear Stats' : 'Effacer stats',
		'Collected resources at outpost' : 'Ressources collectées sur l\'avant-poste',
		'Completing...' : 'Finalisation...',
		'Config' : 'Config',
		'Console Log' : 'Log Console',
		'Console' : 'Console',
		'Coordinates' : 'Coordonnées',
		'Coords' : 'Coords',
		' damages taken' : ' dommages subis',
		' damages to ' : ' dommages à ',
		'data' : 'données',
		'data successfully fetched' : 'données chargées avec succès',
		'Date range' : 'Plage de dates',
		'Day' : 'Jour',
		'Days' : 'Jours',
		' deal ' : ' infligent ',
		'Defender' : 'Défenseur',
		'Defending' : 'En défense',
		'Delay before script startup' : 'Délai initial avant chargement du script',
		'Delay Between Attacks' : 'Délai entre les attaques',
		'delayed due to' : 'retardé,',
		'delayed due to march limit reached' : 'retardé, nombre maximum de marches atteint',
		'delayed due to muster point full' : 'retardé, caserne complète',
		'delayed due to no available generals' : 'retardé, aucun général disponible',
		'delayed due to no available Great Dragon' : 'retardé, aucun Grand Dragon disponible',
		'delayed due to pending march request' : 'retardé, une autre demande de marche est en attente',
		'delayed due to insufficient troops' : 'retardé, nombre de troupes insuffisant',
		'Delete now' : 'Supprimer',
		'Delete Battle Reports' : 'Supprimer les rapports de bataille',
		'Delete messages' : 'Suppression des messages',
		'Delete messages of this type' : 'Suppression des messages de ce type',
		'Delete spy reports' : 'Supprimer les rapports d\'espionnage',
		'Disable <B>Alliance</B> tab' : 'Désactiver l\'onglet <B>Alliance</B>',
		'Disable <B>Battle</B> tab' : 'Désactiver l\'onglet <B>Simu</B>',
		'Disable <B>Multi</B> tab' : 'Désactiver l\'onglet <B>Multi</B>',
		'Disable <B>Search</B> tab' : 'Désactiver l\'onglet <B>Carte</B>',
		'Disable <B>Spy</B> tab' : 'Désactiver l\'onglet <B>Espionnage</B>',
		'Disable <B>Wave</B> tab' : 'Désactiver l\'onglet <B>Vague</B>',
		'Disable <B>Log</B> tab' : 'Désactiver l\'onglet <B>Log</B>',
		'Disabled' : 'Désactivé',
		'Dist' : 'Dist',
		'Distance must be between' : 'La distance doit être comprise entre',
		'Distance' : 'Distance',
		'Dragon healing' : 'Dégâts causés au dragon',
		'Dragons' : 'Dragons',
		'Do not show alerts obsolete since' : 'Ne pas afficher les alertes obsolètes depuis',
		'Enable use of speed-ups in attacks waves' : 'Activer l\'utilisation des accélérateurs de temps dans les vagues d\'attaque',
		'Enable verbose logging' : 'Activer la journalisation d\'évenements',
		'Enable window drag' : 'Autoriser le déplacement de la fenêtre',
		'Enable' : 'Activer',
		'Enable the sentinel tower' : 'Activer la sentinelle',
		'Enabled' : 'Activé',
		'End' : 'Fin',
		'Ennemy General' : 'Général ennemi',
		'Ennemy research levels' : 'Niveaux de recherche de l\'ennemi',
		'Error' : 'Erreur',
		'Error while retrieving the list of members' : 'Erreur lors de la récuparation de la liste des membres',
		'Evol' : 'Evol',
		'Exception' : 'Exception',
		'failed' : 'a échoué',
		'failed and returned error' : 'a échoué et a retourné l\'erreur',
		'Features' : 'Fonctionalités',
		'Fetching' : 'Récupération',
		'Fetching Capital data' : 'Chargement des données de la ville principale',
		'Fetching Manifest' : 'Chargement du Manifeste',
		'Fetching Outpost #' : 'Chargement de l\'outpost n°',
		'Fetching Seed' : 'Chargement des données joueur',
		'Fire' : 'Feu',
		'First value must be between' : 'La première valeur du délai doit être comprise entre',
		'Game messages' : 'Message du jeu',
		'Game Options' : 'Options de jeu',
		'Generals' : 'Généraux',
		'Getting basic data...' : 'Récupération des données de base',
		'Getting cities data...' : 'Récupération des données des cités',
		'Getting game data...' : 'Récupération des données de jeu',
		'Great dragons' : 'Grands Dragons',
		'Hide spy alerts' : 'Masquer les alertes d\'espionnage',
		'Hiding' : 'Sanctuaire',
		'History' : 'Historique',
		'h' : 'h',
		'Hour' : 'Heure',
		'Hours' : 'Heures',
		'Idle' : 'Inactif',
		'Idle pop' : 'Inactifs',
		'idle' : 'inoccupé',
		' in melee' : ' en corps-à-corps',
		'in progress' : 'en cours',
		'Include Great Dragon' : 'Envoyer un grand dragon avec chaque attaque',
		'Info' : 'Info',
		'Initialization' : 'Initialisation',
		'Initializing...' : 'Initialisation...',
		'Initializing map, auto-collect, ...' : 'Initialisation de la carte, collecte automatique, ...',
		'Invalid date' : 'Date invalide',
		'Invalid Date From' : 'Date non valide de',
		'Invalid Date To' : 'Date non valide pour',
		'Invalid date range' : 'Plage de dates invalide',
		'Invalid delays' : 'Délais invalides',
		'Invalid number of troops' : 'Nombre d\'unités invalide',
		'Invalid Range Date' : 'Format de la date incorrect',
		'Inventory' : 'Inventaire',
		'Keep battle reports of attacks from other players' : 'Gardez les rapports de bataille des attaques d\'autres joueurs',
		'Keep battle reports of my attacks on other players' : 'Gardez les rapports de bataille de mes attaques contre d\'autres joueurs',
		' (kill ' : ' (tuent ',
		'Killed' : 'Tués',
		'Last Attack' : 'Dernière attaque',
		'leader' : 'Leader',
		'life lost' : 'vie perdue',
		'Loaded' : 'Script chargé',
		'Loading basic data' : 'Chargement des données de base',
		'Locale data was Successfully requested from the server' : 'La requête pour les traductions a bien été traitée par le serveur',
		'Logs' : 'Logs',
		'Log' : 'Log',
		'lord' : 'Seigneur',
		'Manifest not available, using defaults' : 'Manifeste non disponible, utilisation des stats par défaut',
		'Manifest Successfully initialized' : 'Manifeste initialisé avec succès',
		'Manifest was Successfully requested from the server' : 'La requête pour le Manifeste a bien été traitée par le serveur',
		'Manual attack sent to' : 'Attaque manuelle envoyé sur',
		'March limit reached' : 'Nombre maximum de marches atteint',
		'Max level' : 'Niveau max',
		'Map Search' : 'Recherche sur la carte',
		'Maximum level reached' : 'niveau maximum atteint',
		'Maximum simultaneous marches' : 'Nombre maximum de marches simultanées',
		'Maximum training queues possible per city, according to available resources' : 'Maximum de formations possibles par ville, en fonction des ressources disponibles',
		'Members' : 'Membres',
		'Members list ' : 'Liste des membres ',
		'Message(s) deleted' : 'Message(s) supprimé(s)',
		'Message(s) deletion in progress' : 'Message(s) en cours de suppression',
		'miles' : 'miles',
		'Min level' : 'Niveau min',
		'Minute' : 'Minute',
		'Minutes' : 'Minutes',
		'minutes' : 'minutes',
		' move to ' : ' vont à la position ',
		'Multi' : 'Multi',
		'Muster Point Full' : 'Caserne complète',
		'Need' : 'Requiert',
		'New Version Available' : 'Nouvelle version disponible',
		'No Generals Available' : 'Aucun général disponible',
		'No great dragon available' : 'Aucun grand dragon disponible',
		'no max' : 'pas de limite',
		'No resources to transport defined' : 'Aucune ressource à envoyer n\'est définie',
		'No targets or troops available' : 'Aucune cible ou troupe disponible',
		'No troops available' : 'Aucune troupe disponible',
		'No Troops Defined' : 'Aucune troupe définie',
		'Not enough' : 'Pas assez de',
		'Not' : 'Non',
		'Not ready' : 'Non prêt',
		'of' : 'sur',
		' of ' : ' sur ',
		'one attack' : 'une attaque',
		'one spy' : 'un espionnage',
		'Only one training queue per city' : 'Une seule formation de troupe par ville',
		'Options' : 'Options',
		'Opts' : 'Opts',
		'Outpost' : 'Poste Extérieur',
		'Outpost 1' : 'Avant-poste aquatique',
		'Outpost 2' : 'Avant-poste de pierre',
		'Outpost 3' : 'Avant-poste de feu',
		'Outpost 4' : 'Avant-poste éolien',
		'Outpost damages' : 'Dégâts causés au poste extérieur',
		'overlord' : 'Grand Seigneur',
		'Overview' : 'Vue d\'ensemble',
		'Owner' : 'Propriétaire',
		'Play for' : 'Jouer pendant',
		'Play sound on incoming sentinel report' : 'Jouer un son à l\'arrivée de nouvelles alertes sentinelle',
		'Player cities' : 'Cités joueurs',
		'Player cities list' : 'Liste des cités des joueurs',
		'Player data was Successfully requested from the server' : 'La requête pour les données joueur a bien été traitée par le serveur',
		'Player messages' : 'Messages de joueurs',
		'Player name' : 'Nom joueur',
		'Primary attack to ' : 'Vague principale envoyée à ',
		'Putting build job in persistent data' : 'Sauvegarde de la construction dans les données persistantes',
		'Putting research job in persistent data' : 'Sauvegarde de la recherche dans les données persistantes',
		'Putting resurrect job in persistent data' : 'Sauvegarde de la résurrection dans les données persistantes',
		'Quest' : 'Mission',
		'Quest claim Error' : 'Erreur de réclamation',
		'Rate Limit Exceeded because there were too many requests' : 'Limitation des requêtes dépassée, trop de requêtes ont été envoyées',
		'Read page ' : 'Lecture de la page ',
		'Ready' : 'Prêt',
		'Recipient' : 'Destinataire',
		'Refresh' : 'Actualiser',
		'Refresh list' : 'Rafraîchir la liste',
		'Refresh map data' : 'Rafraîchir données carte',
		'Reinforcement' : 'Renforcement',
		'Reinforcement reports' : 'Rapports de renforcement',
		'Reinforcement sent to' : 'Renforcement envoyé à',
		'Reload' : 'Recharger DOA',
		'Remind me later' : 'Me rappeler plus tard',
		'Repairing' : 'Réparation',
		'Repeat every' : 'Répéter chaque',
		'Researching' : 'Recherche',
		'Reset Stats' : 'Réinitialiser Stats',
		'Resources stock levels update failed' : 'Mise à jour des niveaux de stock des ressources a échoué',
		'Resources to transport' : 'Ressources à envoyer',
		'Resurrect' : 'Résurrection',
		'Retry in' : 'Nouvel essai dans',
		'Reviving' : 'Résurrection',
		'Role' : 'Rôle',
		'Rules' : 'Règles',
		'Run Time' : 'Temps d\'exécution',
		'Safe Mode' : 'Mode Sans échec',
		'Save Attaque' : 'Sauvegarder',
		'Scanning Map' : 'Balayage de la carte sur $NUM$ miles<BR>Attendez la fin de la recherche',
		'Scanning map for cities/wildernesses<BR>This should take about couple minutes<BR>according to the radius entered' : 'Scanne de la carte pour cités/ES<BR>Cela devrait prendre quelques minutes<BR>en fonction du radius saisi',
		'Script Options' : 'Options du script',
		'Search coords' : 'Coords recherche',
		'Search for alliance members' : 'Recherche des membres de l\'alliance',
		'Search max radius' : 'Rayon rech. max',
		'Search Radius' : 'Rayon de balayage',
		'Second' : 'Seconde',
		'Seconds' : 'Secondes',
		'seconds' : 'secondes',
		'Secondary attack to ' : 'Vague secondaire envoyée à ',
		'Seed Successfully initialized' : 'Données joueur initialisée avec succès',
		'Select at least one type of message or report to delete' : 'Sélectionnez au moins un type de message ou de rapport à supprimer',
		'Send reinforcement' : 'Envoyer les renforts',
		'Send transport' : 'Envoyer le transport',
		'Sending reinforcement' : 'Envoi de renforts',
		'Sending transport' : 'Envoi de transport',
		'Sentinel messages' : 'Alertes sentinelle',
		'Sentinel tower' : 'Sentinelle / Tour de guet',
		'several attacks' : 'plusieurs attaques',
		'several spies' : 'plusieurs espionnages',
		'Souls' : 'Âmes',
		'Sound configuration' : 'Configuration du son',
		'Sound file' : 'Fichier son',
		'Spectral' : 'Spectral',
		'SpectralDragonKeep' : 'Autel du Dragon',
		'spectral_dragon outpost' : 'Ruines Spectrales',
		' spent. 2 min timeout (defense respawn)' : ' écoulé. Temporisation de 2 min (retour défense)',
		' spent. 1 min timeout (defense respawn)' : ' écoulé. Temporisation de 1 min (retour défense)',
		'Spies done' : 'Espionnages effectués',
		'Spies number' : 'Nombre d\'espions',
		'Spy One Target' : 'Espionner une cible en rafale',
		'Spy reports' : 'Rapports d\'espionnage',
		'Spy to ' : 'Espion(s) envoyé à ',
		'Stars' : 'Etoiles',
		'Start' : 'Début',
		'Start Date' : 'Date de début',
		'Starting...' : 'Démarrage...',
		'Stone' : 'Pierre',
		'Stop if any troops lost' : 'Désactiver en cas de pertes',
		'succeeded' : 'a réussi',
		'Successfully initialized' : 'initialisé avec succès',
		'Successfully' : 'Avec succès',
		'Summary' : 'Général',
		' survivals)' : ' survivants)',
		'Swamp' : 'Marais',
		'Tabs Options' : 'Options des onglets',
		'Target' : 'Cible',
		'Targets' : 'Cibles',
		'Task Completed' : 'Tâche éffectuée',
		'Tasks' : 'Tâches',
		'Terrain length set to ' : 'Longueur du terrain initialisée à ',
		'To be refreshed' : 'A rafraîchir',
		'Too many errors,  disabling auto train' : 'Trop d\'erreurs, entrainement automatique désactivé',
		'Too many troops for muster point level' : 'Déploiement maximal atteint',
		'Total souls' : 'Âmes total',
		'Tower' : 'Guet',
		'Tower configuration' : 'Configuration sentinelle',
		'Training Configuration' : 'Configuration de la formation',
		'Training queue' : 'File d\'attente des formations',
		'Translation Matrix Successfully initialized' : 'Matrice de traduction initialisée avec succès',
		'Transport reports' : 'Rapports de transport',
		'Transport sent to' : 'Transport envoyé à',
		'Troops Capped' : 'Troupes plafonnées',
		'Troops for reinforcement' : 'Troupes pour le renforcement',
		'Troops for Primary Attack' : 'Troupes pour Attaque principale',
		'Troops for Secondary Attacks' : 'Troupes pour Attaques secondaires',
		'Troops for transport' : 'Troupes pour le transport',
		'Troops for Wave Attack' : 'Troupes pour Attaque en Vague',
		'Troops lost' : 'Troupes perdues',
		'Troops Not Defined' : 'Troupes non définies',
		'Troops statistics for' : 'Statistiques pour',
		'Turned Off' : 'Désactivé',
		'Unowned only' : 'Libres seulement',
		'Updating City values' : 'Mise à jour des données de la ville',
		'Upgrading items' : 'Objets d\'amélioration',
		'Use the Levels Tab to select attack areas' : 'Utilisez l\'onglet "Niveaux" pour sélectionner les cibles',
		'Userset maximum marches reached' : 'Nombre maximum de marches simultanées atteind',
		'waiting' : 'en attente',
		'Warnings' : 'Avertissements',
		'Warning for ' : 'Alerte pour ',
		'was returned with a status of' : 'a retourné le statut',
		'Water' : 'Eau',
		'Wave attack to ' : 'Attaque en vagues sur ',
		'Wave' : 'Vague',
		'Wildernesses list' : 'Liste des étendues sauvages',
		'Wind' : 'Vent',
		'You are' : 'Vous êtes',
		'Yoyo functionality' : 'Fonctionalité Yoyo',
		'ATrans' : 'Ballons',	/* abbr Armored Transport */
		'Fang' : 'GueAqua',		/* abbr Aqua Troop */
		'BatDrg' : 'DG',		/* abbr Battle Dragon */
		'Conscr' : 'Conscr',	/* abbr Conscript */
		'FireDrg' : 'DrgFeu',	/* abbr Fire Dragon */
		'FireM' : 'Miroir',		/* abbr Fire Mirror */
		'Magma' : 'Magma',		/* abbr Fire Troop - Magmasaurus */
		'GrtDrg' : 'GrdDrag',	/* abbr Great Dragon */
		'Halbrd' : 'Halbrd',	/* abbr Halberdsman */
		'LBM' : 'Archer',		/* abbr Longbowman */
		'Mino' : 'Mino',		/* abbr Minotaur */
		'PackDrg' : 'DrgTrans',	/* abbr Pack dragons */
		'SSDrg' : 'Rapide',		/* abbr Swift Strike Dragon */
		'StnDrg' : 'DrgPier',	/* abbr Stone Dragon */
		'Ogre' : 'Ogre',		/* abbr Stone Troop - Ogre */
		'WatDrg' : 'DrgAqua',	/* abbr Water Dragon */
		'WndDrg' : 'DrgEol',	/* abbr Wind Dragon */
		'Banshee' : 'Banshee',	/* abbr Wind Troop - Banshee */
		// Objects
		'WaterEgg' : 'Oeuf Aqua',
		'StoneEgg' : 'Oeuf Pierres',
		'FireEgg' : 'Oeuf Feu',
		'WindEgg' : 'Oeuf Eol',
		'GD Body' : 'Armure GD',
		'GD Helmet' : 'Casque GD',
		'GD Tail' : 'Queue GD',
		'GD Claw' : 'Griffes GD',
		'WD Body' : 'Armure Aqua',
		'WD Helmet' : 'Casque Aqua',
		'WD Tail' : 'Queue Aqua',
		'WD Claw' : 'Griffes Aqua',
		'SD Body' : 'Armure DdP',
		'SD Helmet' : 'Casque DdP',
		'SD Tail' : 'Queue DdP',
		'SD Claw' : 'Griffes DdP',
		'FD Body' : 'Armure DdF',
		'FD Helmet' : 'Casque DdF',
		'FD Tail' : 'Queue DdF',
		'FD Claw' : 'Griffes DdF',
		'WiD Body' : 'Armure DEo',
		'WiD Helmet' : 'Casque DEo',
		'WiD Tail' : 'Queue DEo',
		'WiD Claw' : 'Griffes DEo',
		'Respirators' : 'Recycleurs',
		'Respirator-100' : '100 Recycleurs',
		'Respirator-500' : '500 Recycleurs',
		'Respirator-1000' : '1000 Recycleurs',
		'Mandrakes' : 'Mandragores',
		'Mandrakes-100' : '100 Mandragores',
		'Mandrakes-500' : '500 Mandragores',
		'Mandrakes-1000' : '1000 Mandragores',
		'Runes' : 'Runes',
		'Runes-100' : '100 Runes',
		'Runes-500' : '500 Runes',
		'Runes-1000' : '1000 Runes',
		'Talons' : 'Serres',
		'Talons-100' : '100 Serres',
		'Talons-500' : '500 Serres',
		'Talons-1000' : '1000 Serres',
		'Zzz' : 'Zzz'
	};
	break;
	/*******************************************************************************
		Dutch  (by Kaas)
	*******************************************************************************/
case 'nl':
	TRANSLATION_ARRAY = {
		'</B> and <B>' : '</B> en <B>',
		'<B>Attacker\'s move turn</B>' : '<B>Beurt van de aanvaller</B>',
		'<B>Attacker\'s attack turn</B>' : '<B>Aanvalsbeurt van de aanvaller</B>',
		'<b>Bad request!</b>' : '<b>Ongeldige aanvraag</b>',
		'<B>Defender\'s move turn</B>' : '<B>Beurt van de verdediger</B>',
		'<B>Defender\'s attack turn</B>' : '<B>Aanvalsbeurt van de verdediger</B>',
		'<b>Rate Limit Exceeded</b>, too many requests!' : '<b>Limiet Serveraanvragen overschreden</b>',
		'Action Log' : 'Actie Logs',
		'Actions' : 'Acties',
		'Activate Attacks Logs' : 'Aanvalslog activeren',
		'Alerts log' : 'Alarmlog',
		'Alives' : 'Overleefd',
		'All alliances' : 'Alle Allianties',
		'All players' : 'Alle spelers',
		'All types' : 'Alle types',
		'Alliance features' : 'Kenmerken van allianties ',
		'Alliance members list retrieved' : 'Ledenlijst van alliantie',
		'Alliance messages' : 'Alliantieberichten',
		'and' : 'en',
		'Another march request is pending' : 'Een ander marsaanvraag is al onderweg',
		'Arrival time' : 'Aankomsttijd',
		'at' : 'bij',
		' at ' : ' bij ',
		' at range' : ' in bereik',
		'Attack One Target in Waves' : 'Aanval van één doel via één Wave',
		'Attack sent to' : 'Aanval gedaan naar',
		'Attack One Target in Multiple waves' : 'Aanval van één doel via meerdere Waves',
		'Attacker' : 'Aanvaller',
		'Attacking' : 'Aanval',
		'Attacks Configuration' : 'Aanvalconfiguratie',
		'Attacks Stats' : 'Aanvalstatistieken',
		'Attacks' : 'Aanvallen',
		'attempted' : 'geprobeerd',
		'Attempted' : 'Geprobeerd',
		'attempt for' : 'Geprobeerd voor',
		'Auto harvest resources from outposts every' : 'Automatisch oogsten van buitenposten elke',
		'Auto refresh info tab data every' : 'Autoverversen van Infotab elke',
		'Automatically' : 'Automatisch',
		'Automatically recall transport 1 minute before delivery' : 'Automatisch terugroepen van transport 1 min voor levering',
		'Available troops' : 'Beschikbare troepen',
		'Awaiting task completion notification' : 'In afwachtig van klaarmelding',
		'Battle' : 'Strijd',
		'Battle calculator' : 'Strijdrekenaar',
		'Battle forces' : 'Strijdkrachten',
		'Battle log' : 'Strijd log',
		'Battle lost !!' : 'Verloren !!',
		'Battle mechanics' : 'Strijdleer',
		'Battle won !!' : 'Strijd gewonnen !!',
		'blue_energy' : 'Blauwe Energie',
		'Building' : 'Aan het bouw',
		'Busy' : 'Bezig',
		'by' : 'door',
		'Calculate' : 'Berekenen',
		'Camps/wilds attack reports' : 'Athros strijdbericht',
		'Capital data' : 'Informatie van de hoofdstad',
		'Capital data successfully fetched' : 'Informatie van de hoofdstad geladen',
		'Check sentinel reports every ' : 'Controleren van helderziendebericht elke',
		'Check to use UTC time instead of local time' : '?????',
		'Claim' : 'Vorderen',
		'Claimed' : 'Gevorderd',
		'Claiming quest' : 'Quest gevorderd',
		'Clear all data' : 'Alle info verwijderen',
		'Clear last attack on all maps' : 'Laatst aanval op alle kaarten verwijderen',
		'Clear last attack on current map' : 'Laatst aanval op actuele kaart verwijderen',
		'Clear log' : 'Log verwijderen',
		'Clear Stats' : 'Statistieken verwijderen',
		'Collected resources at outpost' : 'Verzamelde rijkdommen bij buitenpost',
		'Completing...' : 'Bezig met ...',
		'Config' : 'Config',
		'Console Log' : 'Console Log',
		'Console' : 'Console',
		'Coordinates' : 'Coordinaten',
		'Coords' : 'Coords',
		' damages taken' : ' Schade',
		' damages to ' : ' Schade aan ',
		'data' : 'Gegevens',
		'data successfully fetched' : 'Het laden van gegevens is geslaagd ',
		'Date range' : 'Gegevensbereik',
		'Day' : 'Dag',
		'Days' : 'Dagen',
		' deal ' : ' overeenkomst ',
		'Defender' : 'Verdediger',
		'Defending' : 'Verdedigen',
		'Delay before script startup' : 'Vertraging voordat script wordt opgestart',
		'Delay Between Attacks' : 'Vertraging tussen aanvalgolven',
		'delayed due to' : 'vertraging veroorzaakt door,',
		'delayed due to march limit reached' : 'vertraging omdat limiet van aantal marsen is bereikt',
		'delayed due to muster point full' : 'vertraging omdat verzamelplaats vol is',
		'delayed due to no available generals' : 'vertraging omdat generaals niet beschikbaar zijn',
		'delayed due to no available Great Dragon' : 'vertraging omdat Grote Draak niet beschikbaar is',
		'delayed due to pending march request' : 'vertraging omdat er al een mars is begonnen',
		'delayed due to insufficient troops' : 'vertraging omdat er geen troepen beschikbaar zijn',
		'Delete now' : 'Nu verwijderen',
		'Delete Battle Reports' : 'Strijdrapporten verwijderen',
		'Delete messages' : 'Berichten verwijderen',
		'Delete messages of this type' : 'Berichten van dit type verwijderen',
		'Delete spy reports' : 'Spionberichten verwijderen',
		'Disable <B>Alliance</B> tab' : 'Uitschakelen <B>Alliantie</B> tab',
		'Disable <B>Battle</B> tab' : 'Uitschakelen <B>Strijd</B> tab',
		'Disable <B>Multi</B> tab' : 'Uitschakelen <B>Multi</B> tab',
		'Disable <B>Search</B> tab' : 'Uitschakelen <B>Zoek</B> tab',
		'Disable <B>Spy</B> tab' : 'Uitschakelen <B>Spion</B> tab',
		'Disable <B>Wave</B> tab' : 'Uitschakelen <B>Wave</B> tab',
		'Disable <B>Log</B> tab' : 'Uitschakelen <B>Log</B> tab',
		'Disabled' : 'Uitgeschakeld',
		'Dist' : 'Afst',
		'Distance must be between' : 'Afstand moet zijn tussen',
		'Distance' : 'Afstand',
		'Dragon healing' : 'Draak genezing',
		'Dragons' : 'Draken',
		'Do not show alerts obsolete since' : 'Laat geen waarschuwing zien sinds',
		'Enable use of speed-ups in attacks waves' : 'Aanzetten van het gebruik van speed-ups in aanvalWaves',
		'Enable verbose logging' : 'Aanzetten van log',
		'Enable window drag' : 'Aanzetten van slepen van venster',
		'Enable' : 'Aanzetten',
		'Enable the sentinel tower' : 'Aanzetten van Helderziendetoren',
		'Enabled' : 'Aangezet',
		'End' : 'Einde',
		'Ennemy General' : 'Vijandige generaal',
		'Ennemy research levels' : 'Vijandig onderzoekniveaus',
		'Error' : 'Fout',
		'Error while retrieving the list of members' : 'Fout bij het ophalen van ledenlijst',
		'Evol' : 'Evol',
		'Exception' : 'Uitzondering',
		'failed' : 'mislukt',
		'failed and returned error' : 'mislukt met foutmelding',		
		'Features' : 'Functies',
		'Fetching' : 'Bezig met laden',
		'Fetching Capital data' : 'Bezig met ophalen van hoofdstad gegevens',
		'Fetching Manifest' : 'Bezig met ophalen van Manisfest',
		'Fetching Translation matrix' : 'Bezig met ophalen van vertaalmatrix',
		'Fetching Outpost #' : 'Bezig met ophalen van Buitenpost #',
		'Fetching Seed' : 'Bezig met ophalen van Seed',		
		'Fire' : 'Vuur',
		'First value must be between' : 'Eerste waarde moet liggen tussen',
		'Game messages' : 'Spelberichten',
		'Game Options' : 'Spelopties',
		'Generals' : 'Generaals',
		'Getting basic data...' : 'Bezig met ophalen van basisgegevens',
		'Getting cities data...' : 'Bezig met ophalen van stadgegevens',
		'Getting game data...' : 'Bezig met ophalen van spelgegevens',
		'Great Dragons' : 'Grote Draken',
		'Hide spy alerts' : 'Verbergen spionwaarschuwingen',
		'Hiding' : 'Verbergen',
		'History' : 'Geschiedenis',
		'h' : 'u',
		'Hour' : 'Uur',
		'Hours' : 'Uren',
		'Idle pop' : 'Werkloze Bevolking',
		'Idle' : 'Niet aktief',
		'idle' : 'Niet aktief',
		' in melee' : ' bezig met strijd',
		'in progress' : 'bezig',
		'Include Great Dragon' : 'Grote Draak toevoegen',
		'Info' : 'Info',
		'Initialization' : 'Initialisatie',
		'Initializing...' : 'Bezig met Initialisatie',
		'Initializing map, auto-collect, ...' : 'Initialisatie kaart, Auto-inzamelen , ...',
		'Invalid date' : 'Verkeerde datum',
		'Invalid Date From' : 'Verkeerde datum van',
		'Invalid Date To' : 'Verkeerde datum tot',
		'Invalid date range' : 'Verkeerde datumreeks',
		'Invalid delays' : 'Verkeerde vertraging',
		'Invalid number of troops' : 'Verkeerde aantal troepen',
		'Invalid Range Date' : 'Verkeerde gegevensreeks',
		'Inventory' : 'Inventaris',
		'Keep battle reports of attacks from other players' : 'Behoud strijdrapporten van aanvallen van andere spelers',
		'Keep battle reports of my attacks on other players' : 'Behoud strijdrapporten van mijn aanvallen met andere spelers',
		' (kill ' : ' (dood ',
		'Killed' : 'Gedood',
		'Last Attack' : 'Laatste aanval',
		'leader' : 'leider',
		'life lost' : 'Verloren levens',
		'Loaded' : 'Geladen',
		'Loading basic data' : 'Laden van algemene gegevens',
		'Locale data was Successfully requested from the server' : 'Lokale Data zijn succesvol geladen',		
		'Logs' : 'Logbestanden',
		'Log' : 'Log',
		'lord' : 'Meester',
		'Manifest not available, using defaults' : 'Manifest niet beschikbaar, gebruikt standaardgegevens',
		'Manifest Successfully initialized' : 'Manifest succesvol geinitialiseerd',
		'Manifest was Successfully requested from the server' : 'Manifest is succesvol van server opgevraagd',
		'Manual attack sent to' : 'Handmatige aanval gestuurd naar',
		'March limit reached' : 'Marsenlimiet bereikt',
		'Max level' : 'Max niveau',
		'Map Search' : 'Zoeken van kaarten',
		'Maximum level reached' : 'Maximal niveau bereikt',
		'Maximum simultaneous marches' : 'Maximaal aantal gelijktijde marsen',
		'Maximum training queues possible per city, according to available resources' : 'Maximaal aantal trainings per stad vergelekeb met beschikbare middelen',
		'Members' : 'Leden',
		'Members list ' : 'Ledenlijst ',
		'Message(s) deleted' : 'Bericht(en) verwijderd',
		'Message(s) deletion in progress' : 'Bericht(en)verwijdering aan de gang',
		'miles' : 'Mijlen',
		'Min level' : 'Min niveau',
		'Minute' : 'Minuut',
		'Minutes' : 'Minuten',
		'minutes' : 'minuten',
		' move to ' : ' gaan naar ',
		'Multi' : 'Multi',
		'Muster Point Full' : 'Verzamelplaats is vol',
		'Need' : 'Nodig',
		'New Version Available' : 'Nieuwe Versie beschikbaar',
		'No Generals Available' : 'Geen generaals beschikbaar',
		'No great dragon available' : 'Geen Grote Draak beschikbaar',
		'no max' : 'Geen maximum',
		'No resources to transport defined' : 'Geen middelen voor transport gedefinieerd',
		'No targets or troops available' : 'Geen doel of troepen beschikbaar',
		'No troops available' : 'Geen troepen beschikbaar',
		'No Troops Defined' : 'Geen troepen gedefinieerd',
		'Not enough' : 'Niet genoeg',
		'Not' : 'Niet',
		'Not ready' : 'Niet klaar',
		'of' : 'van',
		' of ' : ' van ',
		'one attack' : 'één aanval',
		'one spy' : 'één spion',
		'Only one training queue per city' : 'Slechts één training per stad',
		'Options' : 'Opties',
		'Opts' : 'Opts',
		'Outpost' : 'Buitenpost',
		'Outpost 1' : 'Buitenpost 1',
		'Outpost 2' : 'Buitenpost 2',
		'Outpost 3' : 'Buitenpost 3',
		'Outpost 4' : 'Buitenpost 4',
		'Outpost damages' : 'Schade aan buitenpost',
		'overlord' : 'Opperheer',
		'Overview' : 'Overzicht',
		'Owner' : 'Eigenaar',
		'Play for' : 'Spelen voor',
		'Play sound on incoming sentinel report' : 'Speel geluid bij in komend Helderziende rapport',
		'Player cities' : 'Steden van speler',
		'Player cities list' : 'Stedenlijst van speler',
		'Player data was Successfully requested from the server' : 'Spelergegevens van succesvol van server aangevraagd',
		'Player messages' : 'Berichten van speler',
		'Player name' : 'Spelernaam',
		'Primary attack to ' : 'Voornaamste aanval naar ',
		'Putting build job in persistent data' : 'Bezig met bouwtaak ',
		'Putting research job in persistent data' : 'Bezig met onderzoekstaak',
		'Putting resurrect job in persistent data' : 'Bezig met herrijzen van levens',
		'Quest' : 'Opdracht',
		'Quest claim Error' : 'Opdracht foutmelding',
		'Rate Limit Exceeded because there were too many requests' : 'Teveel aanvragen voor taken',
		'Read page ' : 'Laden van pagina ',
		'Ready' : 'Klaar',
		'Recipient' : 'Ontvanger',
		'Refresh' : 'Verversen',
		'Refresh list' : 'Te verversenlijst',
		'Refresh map data' : 'Verversen kaart',
		'Reinforcement' : 'Versterking',
		'Reinforcement reports' : 'Versterkingsrapporten',
		'Reinforcement sent to' : 'Versterking zenden naar',
		'Reload' : 'Opnieuw laden',
		'Remind me later' : 'Stuur me een herinnering',
		'Repairing' : 'Aan het repareren',
		'Repeat every' : 'Herhaal elke',
		'Researching' : 'Aan het onderzoeken',
		'Reset Stats' : 'Reset statistieken',
		'Resources stock levels update failed' : 'Verversen van voorraadgegevens mislukt',
		'Resources to transport' : 'Middelen voor transport',
		'Resurrect' : 'Herrijzen',
		'Retry in' : 'Opnieuw proberen in',
		'Reviving' : 'Herleving',
		'Role' : 'Rol',
		'Rules' : 'Regels',
		'Run Time' : 'Looptijd',
		'Safe Mode' : 'Beveligingswijze',
		'Save Attaque' : 'Aanval opslaan',
		'Scanning Map' : 'Scannen van kaart',
		'Scanning map for cities/wildernesses<BR>This should take about couple minutes<BR>according to the radius entered' : 'Scannen van kaart op steden/wildernissen<BR>Dit duurt een paar minuten<BR> al naar gelang de aangeven straal',
		'Script Options' : 'Script Opties',
		'Search coords' : 'Zoeken van coördinaten',
		'Search for alliance members' : 'Zoeken naar leden van allianties',
		'Search max radius' : 'Zoeken naar maximale straal',
		'Search Radius' : 'Zoeken naar straal',
		'Second' : 'Seconde',
		'Seconds' : 'Seconden',
		'seconds' : 'seconden',
		'Secondary attack to ' : 'Tweede aanval naar ',
		'Seed Successfully initialized' : 'Seed succesvol geinitialiseerd',
		'Select at least one type of message or report to delete' : 'Selecteren tenminste één bericht om te verwijderen',
		'Send reinforcement' : 'Versterking sturen',
		'Send transport' : 'Transport sturen',
		'Sending reinforcement' : 'Bezig met verzenden van versterking',
		'Sending transport' : 'Bezig met verzending van transport',
		'Sentinel messages' : 'Helderziende berichten',
		'Sentinel tower' : 'Helderziendetoren',
		'several attacks' : 'meerdere aanvallen',
		'several spies' : 'meerdere spionnen',
		'Souls' : 'Zielen',
		'Sound configuration' : 'Geluidsinstelling',
		'Sound file' : 'Geluidsbestand',
		'spectral_dragon outpost' : 'Spookruïne buitenpost',
		'Spectral' : 'Spectral',
		'SpectralDragonKeep' : 'Sprookruïnedraak',
		' spent. 1 min timeout (defense respawn)' : ' gebruik 1 min timeout (Verdediger Respawn)',
		' spent. 2 min timeout (defense respawn)' : ' gebruik 2 min timeout (Verdediger Respawn)',
		'Spies done' : 'Aantal bespionneringen',
		'Spies number' : 'Aantal spionnen',
		'Spy One Target' : 'Eén doel bespionneren',
		'Spy reports' : 'Spionberichten',
		'Spy to ' : 'Spion naar ',
		'Stars' : 'Sterren',
		'Start' : 'Begin',
		'Start Date' : 'Startdatum',
		'Starting...' : 'Beginnen...',
		'Stone' : 'Steen',
		'Stop if any troops lost' : 'Stoppen in geval van troepverlies',
		'succeeded' : 'geslaagd',
		'Successfully initialized' : 'Inlezen geslaagd',
		'Successfully' : 'Geslaagd',
		'Summary' : 'Samenvatting',
		' survivals)' : ' overlevenden)',
		'Swamp' : 'Moeras',
		'Tabs Options' : 'Tab Opties',
		'Target' : 'Opdrachten',
		'Targets' : 'Opdrachten',
		'Task Completed' : 'Taak gereed',
		'Tasks' : 'Taken',
		'Terrain length set to ' : 'Gebiedsgrootte gezet tot ',
		'To be refreshed' : 'Verversen aanzetten',
		'Too many errors,  disabling auto train' : 'Teveel foutmeldingen, autotrainen wordt uitgezet',
		'Too many troops for muster point level' : 'Teveel troepen voor troepenverzamelplaats',
		'Total souls' : 'Totaalaantal zielen',
		'Tower' : 'Toren',
		'Tower configuration' : 'Torenconfiguratie',
		'Training Configuration' : 'Trainingconfiguratie',
		'Training queue' : 'Opleidingswachtrij',
		'Translation Matrix Successfully initialized' : 'Vertalingsmatrix met succes ingelezen', 
		'Transport reports' : 'Transportbericht',
		'Transport sent to' : 'Transport verzonden naar',
		'Troops Capped' : 'Troepenstop',
		'Troops for reinforcement' : 'Troepen voor versterking',
		'Troops for Primary Attack' : 'Troepen voor eerste aanval',
		'Troops for Secondary Attacks' : 'Troepen voor tweede aanval',
		'Troops for transport' : 'Troepen voor transport',
		'Troops for Wave Attack' : 'Troepen voor Waveaanval',
		'Troops lost' : 'Verloren troepen',
		'Troops Not Defined' : 'Troepen niet gedefinieerd',
		'Troops statistics for' : 'Statistieken van troepen voor',
		'Turned Off' : 'Uit',
		'Unowned only' : 'Alleen niet in bezit',
		'Updating City values' : 'Stadinstellingen verversen',
		'Upgrading items' : 'Verbeteringsobjecten',
		'Use the Levels Tab to select attack areas' : 'Gebruik de Level tab om aanvalsgebieden te kiezen',
		'Userset maximum marches reached' : 'Maximale ingestelde marsen bereikt',
		'waiting' : 'wachten',
		'Warnings' : 'Waarschuwingen',
		'Warning for ' : 'Waarschuwing voor ',
		'was returned with a status of' : 'teruggekomen met status',
		'Water' :'Water',
		'Wave attack to ' : 'Waveaanvaal naar',
		'Wave' : 'Wave',
		'Wildernesses list' : 'Wildernissenlijst',
		'Wind' :'Wind',
		'You are' : 'Je bent',
		'Yoyo functionality' : 'Yoyo functie',
		'ATrans' : 'GepTrn',	/* abbr Armored Transport */
		'Fang' : 'SnijVis',		/* abbr Aqua Troop */
		'BatDrg' : 'StrDrk',	/* abbr Battle Dragon */
		'Conscr' : 'Rekr',  	/* abbr Conscript */
		'FireDrg' : 'VuuDrk',	/* abbr Fire Dragon */
		'FireM' : 'VuuSpi', 	/* abbr Fire Mirror */
		'Magma' : 'Pyro',		/* abbr Fire Troop - Magmasaurus */
		'GrtDrg' : 'GD',		/* abbr Great Dragon */
		'Halbrd' : 'HBD',		/* abbr Halberdsman */
		'LBM' : 'BooS',			/* abbr Longbowman */
		'Mino' : 'Mino',		/* abbr Minotaur */
		'PackDrg' : 'TrnDrK',	/* abbr Pack dragons */
		'SSDrg' : 'SnelADrK',	/* abbr Swift Strike Dragon */
		'StnDrg' : 'SteenD',	/* abbr Stone Dragon */
		'Ogre' : 'Graniet',		/* abbr Stone Troop - Ogre */
		'WatDrg' : 'WatDrK',	/* abbr Water Dragon */
		'WndDrg' : 'WindDrK',	/* abbr Wind Dragon */
		'Banshee' : 'Banshee',	/* abbr Wind Troop - Banshee */
		// Objects
		'WaterEgg' : 'WaterEi',
		'StoneEgg' : 'SteenEi',
		'FireEgg' : 'VuurEi',
		'WindEgg' : 'WindEi',
		'GD Body' : 'GD Lichaam',
		'GD Helmet' : 'GD Helm',
		'GD Tail' : 'GD Staart',
		'GD Claw' : 'GD Klauw',
		'WD Body' : 'WaD Body',
		'WD Helmet' : 'WaD Helm',
		'WD Tail' : 'WaD Staart',
		'WD Claw' : 'WaD Klauw',
		'SD Body' : 'SD Lichaam',
		'SD Helmet' : 'SD Helm',
		'SD Tail' : 'Sd Staart',
		'SD Claw' : 'SD Klauw',
		'FD Body' : 'FD Lichaam',
		'FD Helmet' : 'FD Helm',
		'FD Tail' : 'FD Staart',
		'FD Claw' : 'FD Klauw',
		'WiD Body' : 'WD Lichaam',
		'WiD Helmet' : 'WD Helm',
		'WiD Tail' : 'WD Staart',
		'WiD Claw' : 'WD Klauw',
		'Respirators' : 'Ademmaskers',
		'Respirator-100' : '100 Ademmaskers',
		'Respirator-500' : '500 Ademmaskers',
		'Respirator-1000' : '1000 Ademmaskers',
		'Mandrakes' : 'Alruinen',
		'Mandrakes-100' : '100 Alruinen',
		'Mandrakes-500' : '500 Alruinen',
		'Mandrakes-1000' : '1000 Alruinen',
		'Runes' : 'Runes',
		'Runes-100' : '100 Runes',
		'Runes-500' : '500 Runes',
		'Runes-1000' : '1000 Runes',
		'Talons' : 'Klauwen',
		'Talons-100' : '100 Klauwen',
		'Talons-500' : '500 Klauwen',
		'Talons-1000' : '1000 Klauwen',
		'Zzz' : 'Zzz'
	};
	break;
	/**********************************************************************
	     Turkish  (by RedSoldier)
	***********************************************************************/
case 'tr':
case 'tk':
	TRANSLATION_ARRAY = {
		'</B> and <B>' : '</B> ve <B>',
		'<B>Attacker\'s move turn</B>' : '<B>Saldırganın Hareket Sırası</B>',
		'<B>Attacker\'s attack turn</B>' : '<B>Saldırganın Saldırı Sırası</B>',
		'<b>Bad request!</b>' : '<b>Kötü Istek</b>',
		'<B>Defender\'s move turn</B>' : '<B>Savunanın Saldırı Sırası</B>',
		'<B>Defender\'s attack turn</B>' : '<B>Savunanın Hareket Sırası</B>',
		'<b>Rate Limit Exceeded</b>, too many requests!' : '<b>Limite Ulasildi</b>, Çok Fazla Istek Var!',
		'Action Log' : 'Faaliyet Logları',
		'Actions' : 'Faaliyet',
		'Activate Attacks Logs' : 'Saldırı Loglarını Aktifleştir',
		'Alerts log' : 'Alarm Logları',
		'Alives' : 'Hayatta Kalan',
		'All alliances' : 'Tüm İttifaklar',
		'All players' : 'Tüm Oyuncular',
		'All types' : 'Tüm Türler',
		'Alliance features' : 'İttifak Sekmesi',
		'Alliance members list retrieved' : 'İttifak Üyeleri Listesi',
		'Alliance messages' : 'İttifak Mesajları',
		'and' : 've',
		'Another march request is pending' : 'Bir Baska Yürüyüs Istegi Beklemede',
		'Arrival time' : 'Varış Süresi',
		'at' : 'Şurda',
		' at ' : ' Şurda ',
		' at range' : ' Şurda Mesafe',
		'Attack One Target in Waves' : 'Spam Saldırısı',
		'Attack sent to' : 'Saldırı Yollandı :',
		'Attack One Target in Multiple waves' : 'Aynı Hedefe Çoklu Saldırı',
		'Attacker' : 'Saldırgan',
		'Attacking' : 'Saldırılıyor',
		'Attacks Configuration' : 'Saldırı Yapılandırması',
		'Attacks Stats' : 'Saldırı İstatisliği',
		'Attacks' : 'Saldırılar',
		'Attempted' : 'Girişimi',
		'attempted' : 'Girişimi',
		'attempt for' : 'Girisim',
		'Auto harvest resources from outposts every' : 'Kasabalardaki Malzemeleri Topla Her :',
		'Auto refresh info tab data every' : 'İnfo Sekmesi İstatistiklerini Yenile Her :',
		'Automatically' : 'Otomatikman',
		'Automatically recall transport 1 minute before delivery' : 'Ele geçirdikten 1 Dakika Sonra geri Çağır',
		'Available troops' : 'Kullanılabilir Askerler',
		'Awaiting task completion notification' : 'Görev Tamamlama Bildirimi Bekleniyor',
		'Battle' : 'Simülatör',
		'Battle calculator' : 'Saldırı Simülatörü',
		'Battle forces' : 'Savaç Birliklerie',
		'Battle log' : 'Simülasyon Log.e',
		'Battle lost !!' : 'Savaş Kaybedildi !!',
		'Battle mechanics' : 'Savaç Tekniği',
		'Battle won !!' : 'Savaç Kazanıldı !!',
		'blue_energy' : 'Mavi Enerji',
		'Building' : 'İnşaat',
		'Busy' : 'Yoğun',
		'by' : 'By',
		'Calculate' : 'Hesapla',
		'Camps/wilds attack reports' : 'Kamp/Bozkır Saldırı Raporları',
		'Capital data' : 'Sermaye Veri',
		'Capital data successfully fetched' : 'Sermaye Veri Basariyla alindi',
		'Check sentinel reports every ' : 'Gözcü Raporlarını Kontrol Et Her :',
		'Check to use UTC time instead of local time' : 'UTC Saatini Yerel saat Olarak Kontrol Et',
		'Claim' : 'Al',
		'Claimed' : 'Alındı',
		'Claiming quest' : 'Görev Alınıyor',
		'Clear all data' : 'Tüm verileri Temizle',
		'Clear last attack on all maps' : 'Tüm haritalardaki Son Saldırıları Sil',
		'Clear last attack on current map' : 'Şuanki haritada Son Saldırıyı Sil',
		'Clear log' : 'Günlüğü Temizle',
		'Clear Stats' : 'İst. Temizle',
		'Collected resources at outpost' : 'Kasabadaki Malzeme Toplandı',
		'Completing...' : 'Tamamlaniyor...',
		'Config' : 'Yapılandırma',
		'Console Log' : 'Günlük Konsolu',
		'Console' : 'Konsol',
		'Coordinates' : 'Kordinat',
		'Coords' : 'Koord',
		' damages taken' : ' Alınan Zarar',
		' damages to ' : ' Verilen Zarar ',
		'data' : 'Veri',
		'data successfully fetched' : 'Veri Basariyla Alindi',
		'Date range' : 'Gün Aralığı',
		'Day' : 'Gün',
		'Days' : 'Gün',
		' deal ' : ' Zarar ',
		'Defender' : 'Savunan',
		'Defending' : 'Savunuluyor',
		'Delay before script startup' : 'Scriptin Devreye girme Gecikmesi',
		'Delay Between Attacks' : 'Saldırılar Arası Süre farkı',
		'delayed due to' : 'Nedeniyle Gecikti',
		'delayed due to march limit reached' : 'Yürüyüs Limitne Ulasildigi Için Gecikti',
		'delayed due to muster point full' : 'Içtima Meydani Dolu Oldugu Için Geçikti',
		'delayed due to no available generals' : 'Kullanilabilir gEneral Olmadigi Için Gecikti',
		'delayed due to no available Great Dragon' : 'Kullanilabilir Ejderha Olmadigi Için gecikti',
		'delayed due to pending march request' : 'Baska Bir Yürüyüs Istegi nedeniyle Gecikti',
		'delayed due to insufficient troops' : 'Yetersiz brlik Nedeniyle Gecikti',
		'Delete now' : 'Şimdi Sil',
		'Delete Battle Reports' : 'Saldırı Raporlarını Sil',
		'Delete messages' : 'Mesajları Sil',
		'Delete messages of this type' : 'Bu Türdeki Mesajları Sil',
		'Delete spy reports' : 'Casus Raporlarını Sil',
		'Disable <B>Alliance</B> tab' : '<B>İttifakı</B> Devre Dışı Bırak',
		'Disable <B>Battle</B> tab' : '<B>Simülatörü</B> Devre Dışı Bırak',
		'Disable <B>Multi</B> tab' : '<B>Multi</B> Devre Dışı Bırak',
		'Disable <B>Search</B> tab' : '<B>Aramayı</B> Devre Dışı Bırak',
		'Disable <B>Spy</B> tab' : '<B>Casus Sekmesini</B> Devre Dışı Bırak',
		'Disable <B>Wave</B> tab' : '<B>Spami</B> Devre Dışı Bırak',
		'Disable <B>Log</B> tab' : '<B>Günlüğü</B> Devre Dışı Bırak',
		'Disabled' : 'Devredışı',
		'Dist' : 'Msfe',
		'Distance must be between' : 'Mesafe Bunların Arasında Olmalı :',
		'Distance' : 'Mesafe',
		'Dragon healing' : 'İyileştirme',
		'Dragons' : 'Ejderhalar',
		'Do not show alerts obsolete since' : 'Bundan Eski Alarmları Gösterme :',
		'Enable use of speed-ups in attacks waves' : 'Saldirilarda Kisaltmalari Aktive Et',
		'Enable verbose logging' : 'Ayrıntılı Günlüğü Etkinleştir',
		'Enable window drag' : 'Pencerenin Kaydırılmasını Etkinleştir',
		'Enable' : 'Etkin',
		'Enable the sentinel tower' : 'Gözcüyü Etkinleştir',
		'Enabled' : 'Etkinleştirildi',
		'End' : 'Son',
		'Ennemy General' : 'Düşman General',
		'Ennemy research levels' : 'Düşman Araştırma Seviyeleri',
		'Error' : 'Hata',
		'Error while retrieving the list of members' : 'Üyelerin Listesi Oluşturuurken Hata',
		'Evol' : 'Evol',
		'Exception' : 'İstisna',
		'failed' : 'Basarisiz',
		'failed and returned error' : 'Basarisiz ve Hata Döndü',
		'Features' : 'Özellikler',
		'Fetching' : 'Aliniyor',
		'Fetching Capital data' : 'Ana bilgi Aliniyor',
		'Fetching Manifest' : 'Menifest Aliniyor',
		'Fetching Outpost #' : 'Kasabalar Aliniyor',
		'Fetching Seed' : 'Seed Aliniyor',
		'Fire' : 'Ates',
		'First value must be between' : 'İlk Değer Bunların Arasında Olmalı',
		'Game messages' : 'Oyun Mesajları',
		'Game Options' : 'Oyun Ayarları',
		'Generals' : 'Generaller',
		'Getting basic data...' : 'Temel Veri Alınıyor',
		'Getting cities data...' : 'Şehir verileri Alınıyor',
		'Getting game data...' : 'Oyun Verileri Alınıyor',
		'Great dragons' : 'Ejderhalar',
		'Hide spy alerts' : 'Casus Alarmalrını Gizle',
		'Hiding' : 'Saklanılıyor',
		'History' : 'Geçmiş',
		'h' : 'saat',
		'Hour' : 'Saat',
		'Hours' : 'Saat',
		'Idle' : 'Boş',
		'Idle pop' : 'Boş Nüfus',
		'idle' : 'Boş',
		' in melee' : ' in melee',
		'in progress' : 'İşlemde',
		'Include Great Dragon' : 'Büyük Dragon Yolla',
		'Info' : 'Info',
		'Initialization' : 'Yükleme',
		'Initializing...' : 'Yükleniyor...',
		'Initializing map, auto-collect, ...' : 'Harita,Oto Toplama,.... Yükleniyor...',
		'Invalid date' : 'Geçersiz Tarih',
		'Invalid Date From' : 'Geçersiz Başlangıç Tarihi',
		'Invalid Date To' : 'Geçersiz Bitiş Tarihi',
		'Invalid date range' : 'Geçersiz Tarih Aralığı',
		'Invalid delays' : 'Geçersiz Gecikmeler',
		'Invalid number of troops' : 'Geçersiz asker Sayısı',
		'Invalid Range Date' : 'Geçersiz Aralık Tarihi',
		'Inventory' : 'Ögeler',
		'Keep battle reports of attacks from other players' : 'Başkalarından Gelen Saldırıları Sakla',
		'Keep battle reports of my attacks on other players' : 'Benim Saldırdığım Raporları Sakla',
		' (kill ' : ' (Öldürülmüş ',
		'Killed' : 'Öldürüldü',
		'Last Attack' : 'Son Saldırı',
		'leader' : 'Lider',
		'life lost' : 'Hayatını Kaybetti',
		'Loaded' : 'Yüklendi',
		'Loading basic data' : 'Temel Bilgi Yükleniyor',
		'Locale data was Successfully requested from the server' : 'Yerel Data Basariyla Dünyadan Istendi',
		'Logs' : 'Log',
		'Log' : 'Log',
		'lord' : 'Lord',
		'Manifest not available, using defaults' : 'Değiştirilmiş Kullanılamaz, Varsayılanları Kullan',
		'Manifest Successfully initialized' : 'Manifest basariyla Yüklendi',
		'Manifest was Successfully requested from the server' : 'Manifest Basariyla Dünyadan Istendi',
		'Manual attack sent to' : 'Manuel Saldırı Yollandı',
		'March limit reached' : 'Saldiri Limitine Ulasildi',
		'Max level' : 'max Level',
		'Map Search' : 'Harita Arama',
		'Maximum level reached' : 'Maks. Levele Ulasildi',
		'Maximum simultaneous marches' : 'Aynı Anda Grçklştirilcek Saldırı Sayısı',
		'Maximum training queues possible per city, according to available resources' : '?????',
		'Members' : 'Üyeler',
		'Members list ' : 'Üye Listesi ',
		'Message(s) deleted' : 'Mesaj(lar) Silindi',
		'Message(s) deletion in progress' : 'Mesaj(lar) Siliniyor',
		'miles' : 'Mil',
		'Min level' : 'min Level',
		'Minute' : 'Dakika',
		'Minutes' : 'Dakika',
		'minutes' : 'Dakika',
		' move to ' : ' Hareket Ediliyor ',
		'Multi' : 'Multi',
		'Muster Point Full' : 'İçtima Meydanı Full',
		'Need' : 'Gerekli',
		'New Version Available' : 'Yeni versiyon Kullanılabilir',
		'No Generals Available' : 'Kullanılabilir General Yok',
		'No great dragon available' : 'Büyük Ejderha Kullanılamaz',
		'no max' : 'Limitli',
		'No resources to transport defined' : 'Nakliye İçin Malzeme Belirtilmedi',
		'No targets or troops available' : 'Hedef/Asker Kullanılamaz',
		'No troops available' : 'Asker Kullanılamaz',
		'No Troops Defined' : 'Asker Belirtilmemiş',
		'Not enough' : 'Yeterli değil',
		'Not' : 'Değil',
		'Not ready' : 'Hazir Degil',
		'of' : ',',
		' of ' : ', ',
		'one attack' : '1 Saldırı',
		'one spy' : '1 Casus',
		'Only one training queue per city' : 'Her SEhir Için 1 Sira Asker Egit',
		'Options' : 'Ayarlar',
		'Opts' : 'Ayrlr',
		'Outpost' : 'Kasaba',
		'Outpost 1' : 'Su Kasabası',
		'Outpost 2' : 'Taş Kasabası',
		'Outpost 3' : 'Ateş Kasabası',
		'Outpost 4' : 'Rüzgar Kasabası',
		'Outpost damages' : 'Kasaba Hasarı',
		'overlord' : 'Feodal Beyi',
		'Overview' : 'Genel Bakış',
		'Owner' : 'Sahip',
		'Play for' : 'Bunun İçin Çal',
		'Play sound on incoming sentinel report' : 'Gözcü Alarmı Gelince Alarm Çal',
		'Player cities' : 'Oyuncu Şehirleri',
		'Player cities list' : 'Oyuncu Şehir Listesi',
		'Player data was Successfully requested from the server' : 'Oyuncu datasi Basariyla Dünyadan Istendi',
		'Player messages' : 'Oyuncu Mesajalrı',
		'Player name' : 'Oyuncu Adı',
		'Primary attack to ' : 'İlk saldırı : ',
		'Putting build job in persistent data' : 'Bina Görevlerinin Kalıcı Tutulması',
		'Putting research job in persistent data' : 'Araştırma Görevlerinin Kalıcı Tutulması',
		'Putting resurrect job in persistent data' : 'Diriltme Görevlerinin Kalici Tutulmasi',
		'Quest' : 'K.Seferi',
		'Quest claim Error' : 'K.Seferi Alım Hatası',
		'Rate Limit Exceeded because there were too many requests' : 'Rate Limiti Asildi Çünkü Çok Fazla Istek Var',
		'Read page ' : 'Sayfa Okuma ',
		'Ready' : 'Hazir',
		'Recipient' : 'Alıcı',
		'Refresh' : 'Yenile',
		'Refresh list' : 'Listeyi Yenile',
		'Refresh map data' : 'Harita Verilerini Yenile',
		'Reinforcement' : 'Tahkim',
		'Reinforcement reports' : 'Tahkim Raporları',
		'Reinforcement sent to' : 'Tahkim Buraya Yollandı :',
		'Reload' : 'Yenile(F5)',
		'Remind me later' : 'Daha Sonra Hatırlat',
		'Repairing' : 'Tamir',
		'Repeat every' : 'Tekrar Et Her',
		'Researching' : 'Araştırılıyor',
		'Reset Stats' : 'İst. Sıfırla',
		'Resources stock levels update failed' : 'Kaynak Stok Levelleri Güncellemesi Basarisiz',
		'Resources to transport' : 'Nakliye İçin Kaynaklar',
		'Resurrect' : 'Diriltmek',
		'Retry in' : 'Tekrar :',
		'Reviving' : 'Canlandiriliyor',
		'Role' : 'Rol',
		'Rules' : 'Kurallar',
		'Run Time' : 'Çalışma Süresi',
		'Safe Mode' : 'Güvenli Mod',
		'Save Attaque' : 'Saldırıyı Kaydet',
		'Scanning Map' : '$NUM$ Mesafede Harita taranıyor<BR>Bu İşlem Biraz zaman Alabilir',
		'Scanning map for cities/wildernesses<BR>This should take about couple minutes<BR>according to the radius entered' : 'Harita taranıyor..<BR>Bir Kaç dakika Alabilir',
		'Script Options' : 'Script Ayarları',
		'Search coords' : 'Arama Kordinatları',
		'Search for alliance members' : 'İttifak Üyeleri İçin Ara',
		'Search max radius' : 'Arama Maximum Uzaklığı',
		'Search Radius' : 'Arama Mesafesi',
		'Second' : 'Saniye',
		'Seconds' : 'Saniye',
		'seconds' : 'Saniye',
		'Secondary attack to ' : '2 Saldırı Buraya: ',
		'Seed Successfully initialized' : 'Tohumlar Basariyla Yüklendi',
		'Select at least one type of message or report to delete' : 'Silinmesi İçin ir Mesaj Tipi Seç',
		'Send reinforcement' : 'Tahkimle',
		'Send transport' : 'Nakliye Et',
		'Sending reinforcement' : 'Tahkim Yollanıyor',
		'Sending transport' : 'Nakliye Yollanıyor',
		'Sentinel messages' : 'Gözcü Mesajı',
		'Sentinel tower' : 'Gözcü',
		'several attacks' : 'Birkaç Saldırı',
		'several spies' : 'Birkaç Casus',
		'Souls' : 'Ruhlar',
		'Sound configuration' : 'Ses Kofigürasyonu',
		'Sound file' : 'Ses Dosyası',
		'Spectral' : 'Hayali',
		'SpectralDragonKeep' : 'Ejderha Sunagi',
		'spectral_dragon outpost' : 'Hayalet Kasabası',
		' spent. 2 min timeout (defense respawn)' : ' Korumanın Kalkmasına 2 Dakika Kldı',
		' spent. 1 min timeout (defense respawn)' : ' Korumanın Kalkmasına 1 Dakika Kldı',
		'Spies done' : 'Casuslama Başarılı',
		'Spies number' : 'Casus Numarası',
		'Spy One Target' : '1 Hedefi Casusla',
		'Spy reports' : 'Casus Raporları',
		'Spy to ' : 'Casus Buraya : ',
		'Stars' : 'Yıldızlar',
		'Start' : 'Başlangıç',
		'Start Date' : 'Başlangıç Tarihi',
		'Starting...' : 'Baslatiliyor...',
		'Stone' : 'Tas',
		'Stop if any troops lost' : 'Asker Kaybında Durdur',
		'succeeded' : 'Basarili',
		'Successfully initialized' : 'Basariyla Yüklendi',
		'Successfully' : 'Başarılı',
		'Summary' : 'Özet',
		' survivals)' : ' Hayatta Kalan)',
		'Swamp' : 'Bataklık',
		'Tabs Options' : 'Ayarlar Sekmesi',
		'Target' : 'Hedef',
		'Targets' : 'Hedefler',
		'Task Completed' : 'Tarea Finalizada',
		'Tasks' : 'Görevler',
		'Terrain length set to ' : 'Terrain Uzaklığı ayarlandı : ',
		'To be refreshed' : 'Yenilendi',
		'Too many errors,  disabling auto train' : 'Bir Çok Hata Oyo Eğitimi engelledi',
		'Too many troops for muster point level' : 'İçtima Alanı seviyesi Yetersiz',
		'Total souls' : 'Toplam Ruh',
		'Tower' : 'Gözcü',
		'Tower configuration' : 'Gözcü Yapılandırması',
		'Training Configuration' : 'Eğitim Konfigrasyonu',
		'Training queue' : 'Eğitim Sırası',
		'Translation Matrix Successfully initialized' : 'Matrix Çvirisi basariyla Yüklendi',
		'Transport reports' : 'Nakliye Raporu',
		'Transport sent to' : 'Nakliye Yollandı :',
		'Troops Capped' : 'Askerler Kepli',
		'Troops for reinforcement' : 'Tahkim İçin Askerler',
		'Troops for Primary Attack' : 'Ana Saldırı İçin Askerler',
		'Troops for Secondary Attacks' : 'İkincil Saldırı İçin Askerler',
		'Troops for transport' : 'Nakliye İçin Askerler',
		'Troops for Wave Attack' : 'Spam saldırısı İçin Askerler',
		'Troops lost' : 'Asker Kaybedildi',
		'Troops Not Defined' : 'Asker Tanımlanmadı',
		'Troops statistics for' : 'Bnun İçn Asker İst. :',
		'Turned Off' : 'Kapatıldı',
		'Unowned only' : 'Sadece Sahipsiz',
		'Updating City values' : 'Sehir degierleri Güncelleniyor',
		'Upgrading items' : 'İnşaa edilenler',
		'Use the Levels Tab to select attack areas' : 'Level Skmsine Geri Dön ve Sald. Lvlleri Seç',
		'Userset maximum marches reached' : 'Maks. Yürüyüşe Ulaşıldı',
		'waiting' : 'Bekleniyor',
		'Warnings' : 'Uyarılar',
		'Warning for ' : 'Uyarı.Bunun İçin : ',
		'was returned with a status of' : 'Durumu Ile geri Döndü',
		'Water' : 'Su',
		'Wave attack to ' : 'Spam saldırısı : ',
		'Wave' : 'Spam',
		'Wildernesses list' : 'Bozkır Listesi',
		'Wind' : 'Rüzgar',
		'You are' : 'Sen',
		'Yoyo functionality' : 'İşlevsellik',
		'ATrans' : 'ZeplinZeplin',	/* abbr Armored Transport */
		'Fang' : 'Zehirli Pençe',	/* abbr Aqua Troop */
		'BatDrg' : 'Savaş Dragonu',	/* abbr Battle Dragon */
		'Conscr' : 'Acemi Er',		/* abbr Conscript */
		'FireDrg' : 'Ateş E.',		/* abbr Fire Dragon */
		'FireM' : 'Ayna',			/* abbr Fire Mirror */
		'Magma' : 'Lav Dino',		/* abbr Fire Troop - Magmasaurus */
		'GrtDrg' : 'B Ejderha',		/* abbr Great Dragon */
		'Halbrd' : 'Baltacı',		/* abbr Halberdsman */
		'LBM' : 'Okçu',				/* abbr Longbowman */
		'Mino' : 'Mino',			/* abbr Minotaur */
		'PackDrg' : 'Yük Dr',		/* abbr Pack dragons */
		'SSDrg' : 'Çevik Dr',		/* abbr Swift Strike Dragon */
		'StnDrg' : 'Taş E',			/* abbr Stone Dragon */
		'Ogre' : 'Granit',			/* abbr Stone Troop - Ogre */
		'WatDrg' : 'Su E',			/* abbr Water Dragon */
		'WndDrg' : 'Rüzgar E',		/* abbr Wind Dragon */
		'Banshee' : 'Ö Meleği',		/* abbr Wind Troop - Banshee */
		// Objects
		'WaterEgg' : 'Yumurta- Su E.',
		'StoneEgg' : 'Yumurta- Taş E.',
		'FireEgg' : 'Yumurta- Ateş E.',
		'WindEgg' : 'Yumurta- Rüzgar E.',
		'GD Body' : 'Gövde Koruyucu- B.Dr.',
		'GD Helmet' : 'Miğfer- B.Dr.',
		'GD Tail' : 'Kuyruk Zırhı- B.Dr.',
		'GD Claw' : 'Pençe Zırhı- B.Dr',
		'WD Body' : 'Gövde Koruyucu- Su E.',
		'WD Helmet' : 'Miğfer- Su E.',
		'WD Tail' : 'Kuyruk Zırhı- Su E.',
		'WD Claw' : 'Pençe Zırhı- Su E.',
		'SD Body' : 'Gövde Koruyucu- Taş E.',
		'SD Helmet' : 'Miğfer- Taş E.',
		'SD Tail' : 'Kuyruk Zırhı- Taş E.',
		'SD Claw' : 'Pençe Zırhı- Taş E.',
		'FD Body' : 'Gövde Koruyucu- Ateş E.',
		'FD Helmet' : 'Miğfer- Ateş E.',
		'FD Tail' : 'Kuyruk Zırhı- Ateş E.',
		'FD Claw' : 'Pençe Zırhı- Ateş E.',
		'WiD Body' : 'Gövde Koruyucu- Rüzgar E.',
		'WiD Helmet' : 'Miğfer- Rüzgar E.',
		'WiD Tail' : 'Kuyruk Zırhı- Rüzgar E.',
		'WiD Claw' : 'Pençe Zırhı- Rüzgar E.',
		'Respirators' : 'Nefes Aleti',
		'Respirator-100' : '100 Nefes Aleti',
		'Respirator-500' : '500 Nefes Aleti',
		'Respirator-1000' : '1000 Nefes Aleti',
		'Mandrakes' : 'Kök',
		'Mandrakes-100' : '100 Kök',
		'Mandrakes-500' : '500 Kök',
		'Mandrakes-1000' : '1000 Kök',
		'Runes' : 'Run',
		'Runes-100' : '100 Run',
		'Runes-500' : '500 Run',
		'Runes-1000' : '1000 Run',
		'Talons' : 'Pençe',
		'Talons-100' : '100 Pençe',
		'Talons-500' : '500 Pençe',
		'Talons-1000' : '1000 Pençe',
		'Zzz' : 'Zzz'
	};
	break;
	/**********************************************************************
	     Swedish  (by Toruk & Robert)
	***********************************************************************/
case 'sv':
	TRANSLATION_ARRAY = {
		'</B> and <B>' : '</B> och <B>',
		'<B>Attacker\'s move turn</B>' : '<B>Försvara med offensiva enheter</B>',
		'<B>Attacker\'s attack turn</B>' : '<B>Attackera med offensiva enheter</B>',
		'<b>Bad request!</b>' : '<B>Bad begäran!</b>',
		'<B>Defender\'s move turn</B>' : '<B>Försvara med defensiva enheter</B>',
		'<B>Defender\'s attack turn</B>' : '<B>Attackera med defensiva enheter</B>',
		'<b>Rate Limit Exceeded</b>, too many requests!' : '<b>Begränsa fråga överstiger</b>, alltför många förfrågningar skickats!',
		'Action Log' : 'Händelselogg',
		'Actions' : 'Actions',
		'Activate Attacks Logs' : 'Aktivera attackloggning',
		'Alerts log' : 'Varning log',
		'Alives' : 'Överlevande',
		'All alliances' : 'Samtliga allianser',
		'All players' : 'Alla spelare',
		'All types' : 'Alla typer',
		'Alliance features' : 'Alliansen funktioner',
		'Alliance members list retrieved' : 'Förteckning över medlemmar i alliansen återvinns',
		'Alliance messages' : 'Alliance inlägg',
		'and' : 'och',
		'Another march request is pending' : 'En annan begäran av marcha är avvaktan på',
		'Arrival time' : 'Ankomsttid',
		'at' : 'vid',
		' at ' : ' hos ',
		' at range' : ' på distans',
		'Attack One Target in Waves' : 'Attackera ett mål I vågor',
		'Attack sent to' : 'Attack skickad till',
		'Attack One Target in Multiple waves' : 'Attackera ett mål I flera vågor',
		'Attacker' : 'Anfallare',
		'Attacking' : 'Attackerar',
		'Attacks Configuration' : 'Konfigurera attacker',
		'Attacks Stats' : 'Attack Stats',
		'Attacks' : 'Attacker',
		'Attempted' : 'Försökt',
		'attempted' : 'försökt',
		'attempt for' : 'försök för',
		'Auto harvest resources from outposts every' : 'Automatisk insamling av resurser från utpost(erna) varje',
		'Auto refresh info tab data every' : 'Auto uppdatering data av fliken info varje',
		'Automatically' : 'Automatiskt',
		'Automatically recall transport 1 minute before delivery' : 'Automatiskt hämta transport 1 minut före leverans',
		'Available troops' : 'Tillgängliga trupper',
		'Awaiting task completion notification' : 'Väntar på anmälan om utgången av uppdrag',
		'Battle' : 'Strid',
		'Battle calculator' : 'Strids simulator',
		'Battle forces' : 'Stridande trupper',
		'Battle log' : 'Strids log',
		'Battle lost !!' : 'Förlorade strider !!',
		'Battle mechanics' : 'Strids mekanism',
		'Battle won !!' : 'Vunna strider !!',
		'blue_energy' : 'Blue energy',
		'Building' : 'Konstruktionsförlopp',
		'Busy' : 'Upptagen',
		'by' : 'av',
		'Calculate' : 'Lanseringen beräkningen',
		'Camps/wilds attack reports' : 'Rapporter om läger/vildmarker attack',
		'Capital data' : 'Största staden data',
		'Capital data successfully fetched' : 'Största staden data hämtade med framgång',
		'Check sentinel reports every ' : 'Kontrollera portvakt rapporter varje ',
		'Check to use UTC time instead of local time' : 'Kontrollera för använda UTC-tid i stället för lokal tid',
		'Claim' : 'Hävdar',
		'Claimed' : 'Hävdade',
		'Claiming quest' : 'Quest anspråk',
		'Clear all data' : 'Rensa all info',
		'Clear last attack on all maps' : 'Rensa senaste attacker på alla kartor',
		'Clear last attack on current map' : 'Rensa senaste attacker på aktuella kartan',
		'Clear log' : 'Rensa loggen',
		'Clear Stats' : 'Radera stats',
		'Collected resources at outpost' : 'Resurser samlas från utpost',
		'Completing...' : 'Slutförandet...',
		'Config' : 'Konfig',
		'Console Log' : 'Console Log',
		'Console' : 'Console',
		'Coordinates' : 'koordinater',
		'Coords' : 'Kords',
		' damages taken' : ' tagen skada',
		' damages to ' : ' skada till ',
		'data' : 'data',
		'data successfully fetched' : 'data hämtas med framgång',
		'Date range' : 'Datumintervall',
		'Day' : 'Dag',
		'Days' : 'Dagar',
		' deal ' : ' göra skada ',
		'Defender' : 'Försvarare',
		'Defending' : 'Försvarar',
		'Delay before script startup' : 'Initial fördröjning innan lastning manuset',
		'Delay Between Attacks' : 'Fördröjning mellan attacker',
		'delayed due to' : 'försenad,',
		'delayed due to march limit reached' : 'försenad, max. antal marcher uppnådda',
		'delayed due to muster point full' : 'försenad, träningskö full',
		'delayed due to no available generals' : 'försenad, generaler ej tillgängliga',
		'delayed due to no available Great Dragon' : 'försenad, ingen stor drake tillgängliga',
		'delayed due to pending march request' : 'försenad, begäran av marcha avvaktan',
		'delayed due to insufficient troops' : 'försenad, otillräckligt trupper',
		'Delete now' : 'Radera nu',
		'Delete Battle Reports' : 'Radera Battle rapports',
		'Delete messages' : 'Ta bort inlägg',
		'Delete messages of this type' : 'Ta bort inlägg av denna typ',
		'Delete spy reports' : 'Radera spionrapporter',
		'Disable <B>Alliance</B> tab' : 'Inaktivera <B>Allians</B>',
		'Disable <B>Battle</B> tab' : 'Inaktivera <B>Strid</B>',
		'Disable <B>Multi</B> tab' : 'Inaktivera <B>Multi</B>',
		'Disable <B>Search</B> tab' : 'Inaktivera <B>Sök</B>',
		'Disable <B>Spy</B> tab' : 'Inaktivera <B>Spionage</B>',
		'Disable <B>Wave</B> tab' : 'Inaktivera <B>Våg</B>',
		'Disable <B>Log</B> tab' : 'Inaktivera <B>Logg</B>',
		'Disabled' : 'Inaktiverad',
		'Dist' : 'Avstånd',
		'Distance must be between' : 'Avståndet måste vara mellan',
		'Distance' : 'Avstånd',
		'Dragon healing' : 'Drakhälsa',
		'Dragons' : 'Dragons',
		'Do not show alerts obsolete since' : 'visa ej äldre varningar än',
		'Enable verbose logging' : 'Aktivera detaljerad loggning',
		'Enable window drag' : 'Aktivera fönsterdrag',
		'Enable' : 'Aktivera',
		'Enable the sentinel tower' : 'Aktivera vakttorn',
		'Enable use of speed-ups in attacks waves' : 'Aktivera användning av hastighetsbegränsande upp attackerna',
		'Enabled' : 'Aktiverad',
		'End' : 'Stopp',
		'Ennemy General' : 'Fiende General',
		'Ennemy research levels' : 'Fiendens forsknings nivå',
		'Error' : 'Fel',
		'Error while retrieving the list of members' : 'Fel vid hämtning av den förteckning över ledamöter',
		'Evol' : 'Evol',
		'Exception' : 'Undantag',
		'failed' : 'misslyckades',
		'failed and returned error' : 'misslyckades och återvände error',
		'Features' : 'Funktioner',
		'Fetching' : 'Laddar',
		'Fetching Capital data' : 'Laddar av största staden data',
		'Fetching Manifest' : 'Laddar Manifesto',
		'Fetching Outpost #' : 'Laddar Outpost Nej ',
		'Fetching Seed' : 'Laddar av spelare data',
		'Fire' : 'Eld',
		'First value must be between' : 'Första värdet måste ligga mellan',
		'Game messages' : 'Meddelande av spelet',
		'Game Options' : 'Spelalternativ',
		'Generals' : 'Generaler',
		'Getting basic data...' : 'Återvinning av grund data',
		'Getting cities data...' : 'Återvinning av städer data',
		'Getting game data...' : 'Återvinning av speldata',
		'Great dragons' : 'Jätte Drakar',
		'Hide spy alerts' : 'Dölj spion varningar',
		'Hiding' : 'Göm',
		'History' : 'Historia',
		'h' : 't',
		'Hour' : 'Timme',
		'Hours' : 'Timma',
		'Idle pop' : 'Tomgång folk',
		'Idle' : 'Inaktiva',
		'idle' : 'overksam',
		' in melee' : ' i närstrid',
		'in progress' : 'pågår',
		'Include Great Dragon' : 'Skicka en stor drake med varje attack',
		'Info' : 'Info',
		'Initialization' : 'Initierar',
		'Initializing...' : 'Initierar...',
		'Initializing map, auto-collect, ...' : 'Initiera kartan, automatisk insamling, ...',
		'Invalid date' : 'Ogiltigt datum',
		'Invalid Date From' : 'Ogiltigt datum Från',
		'Invalid Date To' : 'Ogiltigt datum Till',
		'Invalid date range' : 'Ogiltigt datumintervall',
		'Invalid delays' : 'Ogiltigt intervall',
		'Invalid number of troops' : 'Inkorrekt antal av trupper',
		'Invalid Range Date' : 'Inkorrekt datumintervall',
		'Inventory' : 'Föremål',
		'Keep battle reports of attacks from other players' : 'Håll slaget rapporter om attacker från andra aktörer',
		'Keep battle reports of my attacks on other players' : 'Håll stridsrapporter av mina attacker på andra spelare',
		' (kill ' : ' (Döda ',
		'Killed' : 'Förlust',
		'Last Attack' : 'Senaste attack',
		'leader' : 'Ledare',
		'life lost' : 'Förlorat liv',
		'Loaded' : 'Script laddas',
		'Loading basic data' : 'Återvinning av grunddata',
		'Locale data was Successfully requested from the server' : 'Den begäran om översättning data har behandlat av servern',
		'Logs' : 'Log',
		'Log' : 'Log',
		'lord' : 'Herre',
		'Manifest not available, using defaults' : 'Manifestet finns inte, använd default statistik',
		'Manifest Successfully initialized' : 'Manifesto initieras framgångsrikt',
		'Manifest was Successfully requested from the server' : 'Den begäran om Manifestet har behandlat av servern',
		'Manual attack sent to' : 'Manuellattack skickad till',
		'March limit reached' : 'Max. antal marcher uppnådda',
		'Max level' : 'Nivå max',
		'Map Search' : 'Kart sök',
		'Maximum level reached' : 'Maximinivån uppnådde',
		'Maximum simultaneous marches' : 'Max. antal marcher',
		'Maximum training queues possible per city, according to available resources' : 'Högsta tillåtna utbildning köer efter staden, enligt tillgängliga resurser',
		'Members' : 'Medlem',
		'Members list ' : 'Medlemslista ',
		'Message(s) deleted' : 'Meddelande(n) borttagna',
		'Message(s) deletion in progress' : 'Meddelande(n) radering pågår',
		'miles' : 'miles',
		'Min level' : 'Nivå min',
		'Minute' : 'Minut',
		'Minutes' : 'Minuter',
		'minutes' : 'minuter',
		' move to ' : ' flytta till ',
		'Multi' : 'Flera',
		'Muster Point Full' : 'Träningskö full',
		'Need' : 'Behöver',
		'New Version Available' : 'Ny version tillgänglig',
		'No Generals Available' : 'Generaler ej tillgängliga',
		'No great dragon available' : 'Ingen stor drake tillgängliga',
		'no max' : 'ingen gräns',
		'No resources to transport defined' : 'Ej tillräckligt med resurser',
		'No targets or troops available' : 'Inga mål eller trupper tillgängliga',
		'No troops available' : 'Inga trupper tillgängliga',
		'No Troops Defined' : 'Inga trupper tagna',
		'Not enough' : 'Ej tillräckligt',
		'Not ready' : 'Inte redo',
		'Not' : 'Inte',
		'of' : 'av',
		' of ' : ' av ',
		'one attack' : 'en attack',
		'one spy' : 'en spion',
		'Only one training queue per city' : 'En enda utbildning efter stad',
		'Options' : 'Inställningar',
		'Opts' : 'Inställ',
		'Outpost' : 'Utpost',
		'Outpost 1' : 'Utpost 1',
		'Outpost 2' : 'Utpost 2',
		'Outpost 3' : 'Utpost 3',
		'Outpost 4' : 'Utpost 4',
		'Outpost damages' : 'Skada på utpost',
		'overlord' : 'Overlord',
		'Overview' : 'Översyn',
		'Owner' : 'Ägare',
		'Play for' : 'Spela i',
		'Play sound on incoming sentinel report' : 'Spela upp ljud på ny varning från Sentinel',
		'Player cities' : 'Stad',
		'Player cities list' : 'Förteckning av spelarstäder',
		'Player data was Successfully requested from the server' : 'Den begäran om spelare data har behandlat av servern',
		'Player messages' : 'Meddelanden av spelare',
		'Player name' : 'Spelar namn',
		'Primary attack to ' : 'Huvudattacken till ',
		'Putting build job in persistent data' : 'Registrering av byggnation i den ihållande uppgifter',
		'Putting research job in persistent data' : 'Registrering av forskning i den ihållande uppgifter',
		'Putting resurrect job in persistent data' : 'Registrering av återuppståndelse i den ihållande uppgifter',
		'Quest' : 'Quest',
		'Quest claim Error' : 'Quest anspråk Fel',
		'Rate Limit Exceeded because there were too many requests' : 'Begränsa fråga överstiger, alltför många förfrågningar skickats',
		'Read page ' : 'Läs sidan ',
		'Ready' : 'Redo',
		'Recipient' : 'Mottagare',
		'Refresh' : 'Uppdatera',
		'Refresh list' : 'Uppdatera lista',
		'Refresh map data' : 'Uppdatera kartdata',
		'Reinforcement' : 'Förstärkning',
		'Reinforcement reports' : 'Förstärkning rapporter',
		'Reinforcement sent to' : 'Förstärkning skickat till',
		'Reload' : 'Uppdaterar DOA',
		'Remind me later' : 'Påminn mig senare',
		'Repairing' : 'Reparerar',
		'Repeat every' : 'Upprepa varje',
		'Researching' : 'Forska',
		'Reset Stats' : 'Nollställ statistik',
		'Resources stock levels update failed' : 'Uppdatera av lagernivåer av resurser har misslyckades',
		'Resources to transport' : 'Resurser för att skicka',
		'Resurrect' : 'Återuppliva',
		'Retry in' : 'Fortsätta igen',
		'Reviving' : 'Återuppliva',
		'Role' : 'Roll',
		'Rules' : 'Regler',
		'Run Time' : 'Tidsförlopp',
		'Safe Mode' : 'Felsäkert läge',
		'Save Attaque' : 'Spara attack',
		'Scanning Map' : 'Skannar kartan till $NUM$ miles<BR>Vänta till slutet av sökningen',
		'Scanning map for cities/wildernesses<BR>This should take about couple minutes<BR>according to the radius entered' : 'Skanna kartan efter städer/vildmarker<BR>Detta bör ta någon minut<BR>enligt den angivna radien',
		'Script Options' : 'Script alternativ',
		'Search coords' : 'Sök kords',
		'Search for alliance members' : 'Sök efter alliansens medlemmar',
		'Search max radius' : 'Sök max. avstånd',
		'Search Radius' : 'Sök avstånd',
		'Second' : 'Sekund',
		'Seconds' : 'Sekunder',
		'seconds' : 'sekunder',
		'Secondary attack to ' : 'Påföljande attacken till ',
		'Seed Successfully initialized' : 'Spelare data initieras framgångsrikt',
		'Select at least one type of message or report to delete' : 'Välj minst en typ av meddelande eller rapport ta bort',
		'Send reinforcement' : 'Skicka förstärkning',
		'Send transport' : 'skicka transporter',
		'Sending reinforcement' : 'Skickar förstärkning',
		'Sending transport' : 'Skickar transporter',
		'Sentinel messages' : 'Varningar från Sentinel',
		'Sentinel tower' : 'Vakttorn',
		'several attacks' : 'flera attacker',
		'several spies' : 'flera spioner',
		'Souls' : 'Själar',
		'Sound configuration' : 'Ljudinställning',
		'Sound file' : 'Ljudfil',
		'Spectral' : 'Spectral',
		'spectral_dragon outpost' : 'Spöklika Ruiner',
		'SpectralDragonKeep' : 'Dragon Altar',
		' spent. 2 min timeout (defense respawn)' : ' Spenderat abort efter 2 min (försvar återskapat)',
		' spent. 1 min timeout (defense respawn)' : ' Spenderat abort efter 1 min (försvar återskapat)',
		'Spies done' : 'Spion klar',
		'Spies number' : 'Antal spioner',
		'Spy One Target' : 'Speja av 1 mål',
		'Spy reports' : 'Spion rapporter',
		'Spy to ' : 'Spion skickad till ',
		'Stars' : 'Stjärnor',
		'Start' : 'Start',
		'Start Date' : 'Startdatum',
		'Starting...' : 'Starta...',
		'Stone' : 'Sten',
		'Stop if any troops lost' : 'Avbryt vågor vid truppförlust',
		'succeeded' : 'lyckades',
		'Successfully initialized' : 'Framgångsrikt initierats',
		'Successfully' : 'Framgångsrikt',
		'Summary' : 'Sammandrag',
		' survivals)' : ' överlevande)',
		'Swamp' : 'Träsk',
		'Tabs Options' : 'Flikar alternativ',
		'Target' : 'Mål',
		'Targets' : 'Mål',
		'Task Completed' : 'Utförd uppgift',
		'Tasks' : 'Uppgifter',
		'Terrain length set to ' : 'Terräng avstånd inställd på ',
		'To be refreshed' : 'Att uppdatera',
		'Too many errors,  disabling auto train' : 'För många fel, avbryter autoträning',
		'Too many troops for muster point level' : 'Maximal utplacering nått',
		'Total souls' : 'Total själar',
		'Tower' : 'Torn',
		'Tower configuration' : 'Konfigurera Vakttorn',
		'Training Configuration' : 'Konfig av autoträning',
		'Training queue' : 'Utbildning kö',
		'Translation Matrix Successfully initialized' : 'Översättning Matrix initieras framgångsrikt',
		'Transport reports' : 'Transport rapporter',
		'Transport sent to' : 'Transport skickat till',
		'Troops Capped' : 'Capped trupper',
		'Troops for reinforcement' : 'Trupper för förstärkning',
		'Troops for Primary Attack' : 'Trupper I Huvudanfallet',
		'Troops for Secondary Attacks' : 'Trupper I påföljande anfallsvågor',
		'Troops for transport' : 'Trupper för transport',
		'Troops for Wave Attack' : 'Trupper för vågattacker',
		'Troops statistics for' : 'Statistik för',
		'Troops lost' : 'Trupper förlorade',
		'Troops Not Defined' : 'Trupper Inte definierade',
		'Turned Off' : 'Avstängd',
		'Unowned only' : 'Bara lediga',
		'Updating City values' : 'Uppdatera data av stadens',
		'Upgrading items' : 'Uppgradera saker',
		'Use the Levels Tab to select attack areas' : 'Använd fliken "Nivåer" för att välja mål',
		'Userset maximum marches reached' : 'Maximalt antal marcher uppnådda',
		'waiting' : 'väntan',
		'Warnings' : 'Varningar',
		'Warning for ' : 'Varning för ',
		'was returned with a status of' : 'returnerades med status',
		'Water' : 'Vatten',
		'Wave attack to ' : 'Vågor skickade till ',
		'Wave' : 'Vågor',
		'Wildernesses list' : 'Vildmarks lista',
		'Wind' : 'Vind',
		'You are' : 'Du är',
		'Yoyo functionality' : 'Yoyo funktionalitet',
		'ATrans' : 'AT',		/* abbr Armored Transport */
		'Fang' : 'Fisk',		/* abbr Aqua Troop */
		'BatDrg' : 'BD',		/* abbr Battle Dragon */
		'Conscr' : 'Conscr',	/* abbr Conscript */
		'FireDrg' : 'DrgEld',	/* abbr Fire Dragon */
		'FireM' : 'FM',			/* abbr Fire Mirror */
		'Magma' : 'Lava',		/* abbr Fire Troop - Magmasaurus */
		'GrtDrg' : 'GrdDrag',	/* abbr Great Dragon */
		'Halbrd' : 'Halbrd',	/* abbr Halberdsman */
		'LBM' : 'LBM',			/* abbr Longbowman */
		'Mino' : 'Mino',		/* abbr Minotaur */
		'PackDrg' : 'PckDrg',	/* abbr Pack dragons */
		'SSDrg' : 'SSD',		/* abbr Swift Strike Dragon */
		'StnDrg' : 'DrgSten',	/* abbr Stone Dragon */
		'Ogre' : 'Troll',		/* abbr Stone Troop - Ogre */
		'WatDrg' : 'DrgVatten',	/* abbr Water Dragon */
		'WndDrg' : 'DrgVind',	/* abbr Wind Dragon */
		'Banshee' : 'Banshee',	/* abbr Wind Troop - Banshee */
		// Objects
		'WaterEgg' : 'Vatten ägg',
		'StoneEgg' : 'Sten ägg',
		'FireEgg' : 'Eld ägg',
		'WindEgg' : 'Vind ägg',
		'GD Body' : 'Harnesk JD',
		'GD Helmet' : 'Hjälm JD',
		'GD Tail' : 'Svans JD',
		'GD Claw' : 'Klo JD',
		'WD Body' : 'Harnesk VD',
		'WD Helmet' : 'Hjälm VD',
		'WD Tail' : 'Svans VD',
		'WD Claw' : 'Klo VD',
		'SD Body' : 'Harnesk SD',
		'SD Helmet' : 'Hjälm SD',
		'SD Tail' : 'Svans SD',
		'SD Claw' : 'Klo SD',
		'FD Body' : 'Harnesk ED',
		'FD Helmet' : 'Hjälm ED',
		'FD Tail' : 'Svans ED',
		'FD Claw' : 'Klo ED',
		'WiD Body' : 'Harnesk ViD',
		'WiD Helmet' : 'Hjälm ViD',
		'WiD Tail' : 'Svans ViD',
		'WiD Claw' : 'Klo ViD',
		'Respirators' : 'Huggtands andare',
		'Respirator-100' : '100 Huggtands andare',
		'Respirator-500' : '500 Huggtands andare',
		'Respirator-1000' : '1000 Huggtands andare',
		'Mandrakes' : 'Alrunor',
		'Mandrakes-100' : '100 Alrunor',
		'Mandrakes-500' : '500 Alrunor',
		'Mandrakes-1000' : '1000 Alrunor',
		'Runes' : 'Runor',
		'Runes-100' : '100 Runor',
		'Runes-500' : '500 Runor',
		'Runes-1000' : '1000 Runor',
		'Talons' : 'Klor',
		'Talons-100' : '100 Klor',
		'Talons-500' : '500 Klor',
		'Talons-1000' : '1000 Klor',
		'Zzz' : 'Zzz'
	};
	break;
default:
	TRANSLATION_ARRAY = {
		'Scanning Map':'Scanning map within $NUM$ miles<BR>This should take about a time',
		'Zzz':'Zzz'
	};
}
} // End changeLang

// Set initial Language
setLanguage();

/*******************************************************************************
***************************          STYLES         ****************************
*******************************************************************************/
/********************************************************************************
* All id and class names must be scrambled to prevent the script from being    *
* blocked. These names have to be generated and allocated to CSS prior to      *
* rest of the script being initialised.                                        *
*                                                                              *
* styleList is an array containing the normal names for each class. This       *
* is then looped through and then scrambled to generate a unique name. A check *
* is done to ensure no two randmised names are the same before allowing the    *
* script to continue.                                                          *
********************************************************************************/ 
var UID = {};
var UIDN = {};
function makeUID(len){
	var len = ( len != undefined ? len : 20);
	var chars = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','u','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','U','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9','_'];
	var uid = chars[Math.floor(Math.random()*54)];
	for(var i = 0; i < len; i++)
	{
		uid += chars[Math.floor(Math.random()*64)];
	}
	return uid;
}
function getUID(name){
	return UID[name] != undefined ? UID[name] : name;
}
function setUID(name){
	var uid = makeUID();
	while(UIDN[uid] != undefined){
		uid = makeUID();
	}
	UIDN[uid] = 1;
	UID[name] = uid;
	return uid;
}

function initStylesUID () {
	for (var i=0; i < styleList.length; i++) {
		setUID(styleList[i]);
	}
}
initStylesUID();


var TIMER_COLOR = '#2B4988';

function setMainStyles() { 
	var css = '\
	.jewel {\
		padding : 1px;\
		font-size: 7pt !important;\
		color: #666 !important;\
	}\
	.progress_on {\
		height:12px;\
		width:2px;\
		background-color: rgb(0,125,189);\
		background-image: linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -moz-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -webkit-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
	}\
	.progress_off {\
		height:12px;\
		width:2px;\
		background-color:rgb(255,255,255);\
	}\
	.progress_bar {\
		border: 1px solid #333;\
		border-radius: 3px;\
		-moz-border-radius: 3px;\
		-webkit-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
	}\
	.' + UID['popup_outer'] + ' {\
		border: 1px solid #777;\
		padding-left:3px;\
		padding-right:3px;\
		padding-bottom:3px;\
		border-radius: 5px;\
		-moz-border-radius: 5px;\
		-webkit-box-shadow: rgba(0,0,0,0.52) 0 0 5px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 0 0 5px;\
	}\
	.' + UID['popup_close'] + ' {\
		position: absolute;\
		display:block;\
		right:-1px;\
		margin-top:-1px;\
		width:20px;\
		height:18px;\
		text-align:center;\
		color:#fff;\
		background-color:#555;\
		font-weight:bold;\
		font-size:12px !important;\
		padding:1px;\
		border: 1px solid #666;\
		border-radius: 5px;\
		-moz-border-radius: 5px;\
		cursor: pointer;\
	}\
	.' + UID['popup_close'] + ':hover {\
		background-color:#922;\
		background-image: linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.6) 99%);\
		background-image: -moz-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.6) 99%);\
		background-image: -webkit-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.6) 99%);\
	}\
	.' + UID['popup_bar'] + ':hover {\
		cursor: move;\
	}\
	#' + UID['main_outer'] + ' {\
		background-color: rgb(255,255,255);\
	}\
	#' + UID['main_outer'] + ' * {\
		font-size:8pt;\
		font-family:helvetica,"lucida grande",tahoma,verdana,arial,sans-serif;\
	}\
	#' + UID['main_outer'] + ' div.container {\
		background-color:rgb(245,245,228);\
		height:100%;\
		width:100%;\
		overflow-x: auto;\
	}\
	.confirm_button {\
		width:60px;\
		padding-top:1px;\
		padding-bottom:1px;\
		color:white;\
		font-weight:bold;\
		border: 1px solid #333;\
		border-radius: 3px;\
		-moz-border-radius: 3px;\
		background-image: linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -moz-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -webkit-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		-webkit-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
		cursor:hand;\
		cursor:pointer;\
		background-color: rgb(0,94,189);\
	}\
	.confirm_button:hover {\
		background-color: rgb(0,125,150);\
	}\
	div.' + UID['title'] + ' {\
		border:1px solid;\
		border-color:#ffffff;\
		font-weight:bold;\
		padding-top:2px;\
		padding-bottom:2px;\
		text-align:center;\
		color:#ffffff;\
		background-color:rgb(60,90,150);\
		background-image:url(\'' + urlBackgroundLogo + '\');\
		border-radius: 2px;\
		-moz-border-radus: 2px;\
	}\
	.' + UID['title'] + ' * {\
		display:inline-block !important;\
		font-weight:bold;\
		color:#ffffff;\
		font-size:11pt;\
	}\
	';
	addStyle(css);
}

function setStyles() { 
	var css = '\
	.jewel {\
		padding : 1px;\
		font-size: 7pt !important;\
		color: #666 !important;\
	}\
	.bluejwl {\
		padding : 1px;\
		font-size: 7pt !important;\
		color: #2B4988 !important;\
	}\
	.wrap {\
		white-space: normal !important;\
	}\
	div.short {\
		color: #000;\
		height:7px;\
	}\
	.emptyline {\
		height:3px;\
	}\
	.progress_on {\
		height:12px;\
		width:2px;\
		background-color: rgb(0,125,189);\
		background-image: linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -moz-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -webkit-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
	}\
	.progress_off {\
		height:12px;\
		width:2px;\
		background-color:rgb(255,255,255);\
	}\
	.progress_bar {\
		border: 1px solid #333;\
		border-radius: 3px;\
		-moz-border-radius: 3px;\
		-webkit-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
	}\
	.' + UID['hiding'] + ' {\
		background-color: rgb(0,160,110);\
		color: white;\
		padding-left: 10px;\
		padding-right: 10px;\
		margin-right: -2px;\
		border-radius: 2px;\
		-moz-border-radius: 2px;\
		-webkit-box-shadow: rgba(0,0,0,0.52) 0 0 2px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 0 0 2px;\
	}\
	.' + UID['defending'] + ' {\
		background-color: rgb(184,0,46);\
		color: white;\
		padding-left: 10px;\
		padding-right: 10px;\
		margin-right: -2px;\
		border-radius: 2px;\
		-moz-border-radius: 2px;\
		-webkit-box-shadow: rgba(0,0,0,0.52) 0 0 2px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 0 0 2px;\
	}\
	.' + UID['scrollable'] + ' {\
		overflow: auto !important;\
	}\
	.' + UID['popup_outer'] + ' {\
		border: 1px solid #777;\
		padding-left:3px;\
		padding-right:3px;\
		padding-bottom:3px;\
		border-radius: 5px;\
		-moz-border-radius: 5px;\
		-webkit-box-shadow: rgba(0,0,0,0.52) 0 0 5px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 0 0 5px;\
	}\
	.' + UID['popup_close'] + ' {\
		position: absolute;\
		display:block;\
		right:-1px;\
		margin-top:-1px;\
		width:20px;\
		height:18px;\
		text-align:center;\
		color:#fff;\
		background-color:#555;\
		font-weight:bold;\
		font-size:12px !important;\
		padding:1px;\
		border: 1px solid #666;\
		border-radius: 5px;\
		-moz-border-radius: 5px;\
		cursor: pointer;\
	}\
	.' + UID['popup_close'] + ':hover {\
		background-color:#922;\
		background-image: linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.6) 99%);\
		background-image: -moz-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.6) 99%);\
		background-image: -webkit-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.6) 99%);\
	}\
	.' + UID['popup_bar'] + ':hover {\
		cursor: move;\
	}\
	#' + UID['main_outer'] + ' {\
		background-color: rgb(255,255,255);\
	}\
	#' + UID['main_outer'] + ' * {\
		font-size:8pt;\
		font-family:helvetica,"lucida grande",tahoma,verdana,arial,sans-serif;\
	}\
	#' + UID['main_outer'] + ' ul.tabs {\
		overflow: hidden;\
		display: block;\
		border-bottom: 1px solid #898989;\
		height: 26px;\
		list-style: none;\
		margin: 0;\
		padding: 0;\
		font-size: 10px;\
	}\
	#' + UID['main_outer'] + ' ul.line2 {\
		height: 20px;\
	}\
	#' + UID['main_outer'] + ' ul.tabs li.tab {\
		display: inline-block;\
		float: left;\
		cursor:pointer !important;\
	}\
	#' + UID['main_outer'] + ' ul.tabs li.tab a {\
		background-color: rgb(235,238,245);\
		border-bottom-width: 1px;\
		border: 1px solid #898989;\
		border-left-width: 0;\
		color: #333;\
		font-weight: bold;\
		display: block;\
		height: 16px;\
		margin-top: 6px;\
		padding: 2px 9px 3px 8px;\
		position: relative;\
		text-decoration: none;\
		cursor:pointer;\
	}\
	#' + UID['main_outer'] + ' ul.tabs li.line1 a {\
		padding: 2px 9px 0px 8px;\
	}\
	#' + UID['main_outer'] + ' ul.tabs li.line2 a {\
		height: 16px;\
		margin-top: 0px;\
	}\
	#' + UID['main_outer'] + ' ul.tabs li.first a {\
		border-left-width: 1px;\
	}\
	#' + UID['main_outer'] + ' ul.tabs li.tab a.selected {\
		background-color: rgb(60,90,150);\
		border-top-color: #3B5998;\
		border-bottom-color: #3B5998;\
		border-left-color: #5973A9;\
		border-right-color: #5973A9;\
		color: white;\
		-webkit-box-shadow: rgba(0,0,0,0.6) 1px 0px 1px;\
		-moz-box-shadow: rgba(0,0,0,0.6) 1px 0px 1px;\
		background-image: linear-gradient(bottom, rgba(0,0,0,0) 12%, rgba(255,255,255,0.3) 90%, rgba(255,255,255,0.9) 99%);\
		background-image: -moz-linear-gradient(bottom, rgba(0,0,0,0) 12%, rgba(255,255,255,0.3) 90%, rgba(255,255,255,0.9) 99%);\
		background-image: -webkit-linear-gradient(bottom, rgba(0,0,0,0) 12%, rgba(255,255,255,0.3) 90%, rgba(255,255,255,0.9) 99%);\
	}\
	#' + UID['main_outer'] + ' div.container {\
		height: 100%;\
		width: 100%;\
		overflow-x: auto;\
	}\
	#' + UID['main_outer'] + ' div.container ul.tabs li.tab a {\
		height: 13px;\
		background-color: rgb(241,241,241);\
	}\
	#' + UID['main_outer'] + ' div.container ul.tabs li.tab a.selected {\
		background-color: rgb(110,132,181);\
	}\
	div.' + UID['title'] + ' {\
		border:1px solid;\
		border-color:#ffffff;\
		font-weight:bold;\
		padding-top:2px;\
		padding-bottom:2px;\
		text-align:center;\
		color:#ffffff;\
		background-color:rgb(60,90,150);\
		background-image:url(\'' + urlBackgroundLogo + '\');\
		border-radius: 2px;\
		-moz-border-radus: 2px;\
	}\
	.' + UID['title'] + ' * {\
		display:inline-block !important;\
		font-weight:bold;\
		color:#ffffff;\
		font-size:11pt;\
	}\
	div.' + UID['title_main'] + ' {\
		border:1px solid;\
		border-color:#ffffff;\
		font-weight:bold;\
		font-size:13pt;\
		padding-top:2px;\
		padding-bottom:0;\
		white-space:nowrap;\
		text-align:center;\
		color:#ffffff;\
		background-color:rgb(60,90,150);\
		background-image:url(\'' + urlBackgroundLogo + '\');\
		border-radius: 2px;\
		-moz-border-radus: 2px;\
	}\
	div.' + UID['title_main'] + ' td a {\
		cursor:pointer;\
	}\
	div.' + UID['subtitle'] + ' {\
		border:1px solid;\
		border-color:#ffffff;\
		font-weight:bold;\
		padding-top:2px;\
		padding-bottom:2px;\
		text-align:center;\
		color:#ffffff;\
		background-color: rgb(60,60,60);\
		border-radius: 2px;\
		-moz-border-radus: 2px;\
	}\
	div.' + UID['content'] + ' {\
		border:1px solid rgb(255,200,50);\
		background-color: rgb(245,245,228);\
		padding:3px;\
		border-radius: 2px;\
		color: #000;\
		-moz-border-radus: 2px;\
		-webkit-box-shadow: rgba(0,0,0,0.52) 0 0 2px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 0 0 2px;\
	}\
	div.' + UID['status_ticker'] + ' {\
		border:1px solid #995;\
		background-color: rgb(239,239,224);\
		padding:2px;\
		border-radius: 2px;\
		color: #000;\
		-moz-border-radus: 2px;\
		-webkit-box-shadow: rgba(0,0,0,0.52) 0 0 2px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 0 0 2px;\
	}\
	div.' + UID['status_report'] + ' {\
		height: 106px;\
		max-height: 106px;\
		overflow:auto;\
		color: #000;\
	}\
	div.' + UID['status_feedback'] + ' {\
		border: 1px solid #ddd;\
		padding-top: 5px;\
		padding-right: 5px;\
		padding-bottom: 0.5em;\
		padding-left: 5px;\
		height: 34px;\
		background-color: rgb(255,235,235);\
		text-align:left;\
		font-weight:bold;\
		border-radius: 3px;\
		color: #000;\
		-moz-border-radius: 3px;\
	}\
	table.' + UID['table'] + ' tr td,\
	table.' + UID['compact_table'] + ' tr td,\
	table.' + UID['table'] + ' tr td div {\
		border:none;\
		background:none;\
		white-space:nowrap;\
		padding: 1px 1px;\
		cursor: default;\
	}\
	table.' + UID['table'] + ' tr td {\
		padding: 1px 4px;\
	}\
	table.' + UID['table'] + ' tr td.right,\
	table.' + UID['compact_table'] + ' tr td.right,\
	table.' + UID['table'] + ' tr td.right div {\
		font-weight:bold;\
		text-align:right;\
		padding-right: 5px;\
	}\
	table.' + UID['table'] + ' tr td.left,\
	table.' + UID['compact_table'] + ' tr td.left,\
	table.' + UID['table'] + ' tr td.left div {\
		font-weight:bold;\
		text-align:left;\
		padding-right: 5px;\
	}\
	table.' + UID['table_console'] + ' tr td {\
		white-space:normal;\
		vertical-align:top;\
	}\
	td.' + UID['underline'] + ' {\
		border-bottom:1px solid #ccc;\
		background:none;\
		padding: 1px 4px 1px 4px;\
	}\
	table tr.' + UID['row_top_headers'] + ' td,\
	table tr.' + UID['row_headers'] + ' td {\
		color: white;\
		background-color: rgb(110,115,125);\
		border-right: 2px solid #eef;\
		font-weight:bold;\
		text-align:center;\
		line-height:11pt;\
	}\
	table tr.' + UID['row_top_headers'] + ' td {\
		background-color: rgb(90,95,115);\
	}\
	table tr.' + UID['row_headers'] + ' td a {\
		cursor:pointer;\
	}\
	table tr.' + UID['row_headers_left'] + ' td {\
		color: white;\
		background-color: rgb(110,115,125);\
		border-right: 2px solid #eef;\
		font-weight:bold;\
		text-align:left;\
		line-height:11pt;\
	}\
	tr.' + UID['row_marchOther'] + ' td {\
		color:#888888;\
	}\
	tr.' + UID['row_marchMine'] + ' td {\
		color:#000000;\
	}\
	tr.' + UID['row_owned'] + ' {\
	}\
	table tr td div.' + UID['info_protect'] + ' {\
		border:1px solid;\
		border-color:#ffffff;\
		font-weight:bold;\
		padding-top:2px;\
		padding-bottom:2px;\
		text-align:center;\
		color:yellow;\
		background-color:#0044a0;\
		border-radius: 2px;\
		-moz-border-radus: 2px;\
	}\
	table tr td div.' + UID['info_alerts'] + ' {\
		border:1px solid;\
		border-color:#ffffff;\
		font-weight:bold;\
		padding-top:2px;\
		padding-bottom:2px;\
		text-align:center;\
		color:white;\
		background-color:#770000;\
		border-radius: 2px;\
		-moz-border-radus: 2px;\
	}\
	input.short {\
		width:30px;\
	}\
	input.' + UID['btn_on'] + ',\
	input.' + UID['btn_off'] + ',\
	input.' + UID['bnt_red'] + ',\
	input.' + UID['bnt_green'] + ',\
	input.' + UID['bnt_blue'] + ',\
	input.' + UID['bnt_yellow'] + ',\
	input.' + UID['bnt_cyan'] + ',\
	input.' + UID['bnt_purple'] + ',\
	input.' + UID['bnt_disabled'] + ',\
	#' + UID['main_outer'] + ' input[type=button] {\
		width:130px;\
		padding-top:1px;\
		padding-bottom:1px;\
		color:white;\
		font-weight:bold;\
		border: 1px solid #333;\
		border-radius: 3px;\
		-moz-border-radius: 3px;\
		background-image: linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -moz-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -webkit-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		-webkit-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
		cursor:hand;\
		cursor:pointer;\
	}\
	#' + UID['main_outer'] + ' input[type=button] {\
		background-color: rgb(0,125,189);\
	}\
	#' + UID['main_outer'] + ' input[type=button]:hover {\
		background-color: rgb(40,150,210);\
	}\
	input.' + UID['btn_on'] + ' {\
		background-color: rgb(0,160,110) !important;\
	}\
	input.' + UID['btn_on'] + ':hover {\
		background-color: rgb(0,200,150) !important;\
	}\
	input.' + UID['btn_off'] + ' {\
		background-color: rgb(184,0,46) !important;\
	}\
	input.' + UID['btn_off'] + ':hover {\
		background-color: rgb(200,50,100) !important;\
	}\
	input.thin {\
		width: auto !important;\
		font-size: 7pt !important;\
		margin:0;\
		padding-top:0;\
		padding-top:0;\
		padding-bottom:0;\
		padding-left:2px;\
		padding-right:2px;\
	}\
	input.small {\
		margin:0;\
		padding-top:0;\
		padding-bottom:0;\
		padding-left:1px;\
		padding-right:1px;\
		font-size:10pt;\
	}\
	input.Xtrasmall {\
		margin:0;\
		padding-top:0;\
		padding-bottom:0;\
		padding-left:1px;\
		padding-right:1px;\
		font-size:7pt;\
	}\
	.confirm_button {\
		width:60px;\
		padding-top:1px;\
		padding-bottom:1px;\
		color:white;\
		font-weight:bold;\
		border: 1px solid #333;\
		border-radius: 3px;\
		-moz-border-radius: 3px;\
		background-image: linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -moz-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		background-image: -webkit-linear-gradient(bottom, rgba(0,0,0,0.1) 10%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0.5) 99%);\
		-webkit-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
		-moz-box-shadow: rgba(0,0,0,0.52) 1px 1px 1px;\
		cursor:hand;\
		cursor:pointer;\
		background-color: rgb(0,94,189);\
	}\
	.confirm_button:hover {\
		background-color: rgb(0,125,150);\
	}\
	input.' + UID['bnt_red'] + ' {\
		background-color: rgb(184,0,46) !important;\
	}\
	input.' + UID['bnt_red'] + ':hover {\
		background-color: rgb(200,50,100) !important;\
	}\
	input.' + UID['bnt_green'] + ' {\
		background-color: rgb(0,160,110) !important;\
	}\
	input.' + UID['bnt_green'] + ':hover {\
		background-color: rgb(0,210,150) !important;\
	}\
	input.' + UID['bnt_blue'] + ' {\
		background-color: rgb(0,94,189);\
	}\
	input.' + UID['bnt_blue'] + ':hover {\
		background-color: rgb(0,125,150);\
	}\
	input.' + UID['bnt_yellow'] + ' {\
		background-color:#BFBF00 !important;\
	}\
	input.' + UID['bnt_yellow'] + ':hover {\
		background-color:#DFDF00 !important;\
	}\
	input.' + UID['bnt_cyan'] + ' {\
		background-color:#00BFBF !important;\
	}\
	input.' + UID['bnt_cyan'] + ':hover {\
		background-color:#00DFDF !important;\
	}\
	input.' + UID['bnt_purple'] + ' {\
		background-color:#BF00BF !important;\
	}\
	input.' + UID['bnt_purple'] + ':hover {\
		background-color:#DF00DF !important;\
	}\
	input.' + UID['bnt_disabled'] + ' {\
		background-color:#D8D8D8 !important;\
	}\
	input.' + UID['bnt_disabled'] + ':hover {\
		background-color:#F8F8F8F8 !important;\
	}\
	#' + UID['main_outer'] + ' input[type=text] {\
		border: 1px solid #888;\
		border-radius: 2px;\
		-moz-border-radius: 2px;\
		-webkit-box-shadow: rgba(0,0,0,0.2) 1px 1px 3px inset;\
		-moz-box-shadow: rgba(0,0,0,0.2) 1px 1px 3px inset;\
	}\
	#' + UID['main_outer'] + ' input[type=text]:active,\
	#' + UID['main_outer'] + ' input[type=text]:focus {\
		border-color: #000;\
		-webkit-box-shadow: rgba(0,0,0,0.5) 1px 1px 4px inset;\
		-moz-box-shadow: rgba(0,0,0,0.5) 1px 1px 4px inset;\
	}\
	span.' + UID['bold_red'] + ' {\
		color:#550000;\
		font-weight:bold;\
	}\
	span.' + UID['green'] + ' {\
		color:#009C1F;\
		font-weight:bold;\
	}\
	span.' + UID['red'] + ' {\
		color:#AA0000;\
		font-weight:bold;\
	}\
	hr.thin {\
		margin:0px;\
		padding:0px;\
	}\
	div#' + UID['tooltip'] + ' {\
		position: absolute;\
		max-width:185px;\
		padding: 5px 8px;\
		color:#fff;\
		font-family: "Lucida Grande","Lucida Sans Unicode","bitstream vera sans","trebuchet ms",verdana,sans-serif;\
		font-size:9pt;\
		background-color: rgb(60,90,150);\
		background-color: rgba(60,90,150,0.6);\
		border: 1px solid white;\
		border-radius: 3px;\
		-webkit-box-shadow: rgb(0,0,0) 0px 0px 5px;\
		-moz-box-shadow: rgb(0,0,0) 0px 0px 5px;\
		background-image: linear-gradient(bottom, rgba(30,30,30,0.9) 1%, rgba(30,30,30,0.5) 100%);\
		background-image: -moz-linear-gradient(bottom, rgba(30,30,30,0.9) 1%, rgba(30,30,30,0.5) 100%);\
		background-image: -webkit-linear-gradient(bottom, rgba(30,30,30,0.9) 1%, rgba(30,30,30,0.5) 100%);\
		visibility: hidden;\
		z-index: 1000;\
	}\
	';
	addStyle(css);
}

// Global variables
var Tabs = {};
var progressBarPop;
var mainPop;
var gAttScrollPos = 0;
var gMapScrollPos = 0;
var C = {};
C.attrs = {};

// Jawz - Should be there ?
var gFormatTime = ':';
var gFormatDate = '/';
var soundRepeatTimer = null;
var soundStopTimer   = null;
// End Jawz - Should be there ?

function parseQuotedVars(str){
	var obj = {};
	var pattern = /\s*(.*?)\s*=\s*('|")(.*?)\2/gi;
	var match;
	while ((match = pattern.exec(str)) != null){
		obj[match[1]] = match[3];
	}
	return obj;
}

function getFlashVars (swf){
	// "use strict";
	var params = swf.innerHTML;
	var pattern = /\<\s*param\s*(.*?)\>/gi;
	var attrs={};
	var args, match, p;
	while ((match = pattern.exec(params)) != null){
		var p = parseQuotedVars(match[1]);
		if (p.name && p.name == 'flashvars')
		{
			args = decodeEntity(p.value).split('&');
			for (var i=0; i < args.length; i++)
			{
				var v = args[i].split('=');
				attrs[v[0].strip()] = v[1].strip();
			}
			break;
		}
	}
	// will have to enhance this if they change the names ...
	C.attrs.apiServer	= attrs.api_server;
	C.attrs.sessionId	= attrs.session_id;
	C.attrs.dragonHeart = attrs.dragon_heart;
	C.attrs.userId		= attrs.user_id;
	C.attrs.locale		= attrs.locale;
	USER_ID		 		= attrs.user_id;
	SERVER_ID	 		= ( /realm(\d+)\./.exec( attrs.api_server ) || ['',''] )[1];
}

// Jawz - URLs
var kForumLink = 'Forum';
var kWikiLink = 'Wiki DoA';


var scriptName		= 'DOA Bot Sayfasi';
var scriptUrlError	= 'http://www.mmogwiki.com/forum/index.php?f=5&t=409&rb_v=viewtopic';
var scriptTitle		= '';
var scriptSite		= '';
var scriptTimeout	= null;
var scriptLoaded	= false;
var startupCount	= 0;
var initTimeout		= null;

var kFatalSWF	= '"<B>Error initializing:</b><BR><BR>Unable to find SWF element"';
var kStartupErr	= '"Unable to start "'+ scriptName +'"<BR>"';
var kInitErr	= '"<B>Error initializing:</b><BR><BR>"';

var STARTUP_TIMER;
var citySteps;

// Main entry
function scriptStartup() {
	var i;
	progressBar.hideshow(false);
	clearTimeout(scriptTimeout);
		
	if (scriptLoaded){
		return;
	}
	
	if (++startupCount > 10) {
		dialogFatal (kFatalSWF);
		return;
	}
	
	try {  
		var swf = null;
		var object = document.getElementsByTagName ('object');
		if (object.length < 1) {
			scriptTimeout = setTimeout(scriptStartup, 1000);
			return;
		}
		for (i=0; i < object.length; i++) {
			if (object[i].type && object[i].type=='application/x-shockwave-flash') {
				swf = object[i];
				getFlashVars(swf);
				if (C.attrs.apiServer){
					break;
				}
			}
		}
		if (!C.attrs.apiServer) {
			scriptTimeout = setTimeout(scriptStartup, 1000);
			return;
		}  
	} catch (e) {
		scriptTimeout = setTimeout(scriptStartup, 1000);
		return;
	}
	
	scriptLoaded = true;
	
	try {

		AutoUpdater.check();
		var retry = 0;
		var startupDelay = Math.randRange(10000, 15000);
		progressBar.start({ steps:20, delay:startupDelay, title:translate('Initializing...'), stepText:translate('Loading basic data') });
		WinLog.enabled = ENABLE_WINLOG;
		
		Data.init({
			log		: [ [], [] ],
			// Static data and scripts settings - Will be stored in local storage and be backup in local file
			options	: {
				popUp	: {
					open : true,
					drag : true,
					x	 : 0,
					y	 : 0
				},
				background		: true,
				currentTab		: false,
				forumUrl		: 'http://',
				wikiUrl			: 'http://fr.dragonsofatlantis.wikia.com/wiki/Accueil',
				disable_wave	: !WAVE_TAB_ENABLE,
				disable_multi	: MULTI_TAB_ENABLE,
				disable_spies	: SPY_TAB_ENABLE,
				disable_search	: !SEARCH_TAB_ENABLE,
				disable_battle	: !BATTLE_TAB_ENABLE,
				disable_alliance: !ALLIANCE_TAB_ENABLE,
				disable_log		: !LOG_TAB_ENABLE,
				speedups_enabled: false,
				utc_time		: false,
				user_language	: LANG_CODE,

				alliance	: {
					last_update	 : '',
					current_tab	 : 0,
					transport_id : 0,
					reinforce_id : 0,
					sort_list	 : '0',
					data		 : {
						transports	: {},
						resources	: {},
						units		: {}
					},
					recall		 :false
				},

				autoCollect	: {
					enabled		: false,
					last_time	: 0,
					delay		: 1,
					unit		: 3600
				},

				autoRefresh	: {
					enabled	: false,
					delay	: 1,
					unit	: 3600
				},

				info	: {	current_tab	: 0	},
				jobs	: {	current_tab	: 0	},
				building	: {
					enabled		 : false,
					level_enable : [{},{},{},{},{},{}],
					level_cap	 : [{},{},{},{},{},{}]
				},
				research	: {
					enabled		: false,
					res_enable	: [{},{},{},{},{},{}],
					res_cap		: [{},{},{},{},{},{}]
				},
				training	: {
					enabled		: false,
					current_tab	: 0,
					city		: [
						{ enabled : true, units : [], cap : [] },
						{ enabled : true, units : [], cap : [] },
						{ enabled : true, units : [], cap : [] },
						{ enabled : true, units : [], cap : [] },
						{ enabled : true, units : [], cap : [] },
						{ enabled : true, units : [], cap : [] }
					],
					mode		: 'min_housing'
				},
				resurrect	: {
					enabled		: false,
					res_enable	: [{},{},{},{},{},{}],
					res_max		: [{},{},{},{},{},{}]
				},
				tJobs		: [],
				rJobs		: [],
				sJobs		: [], // resurrection jobs

				calculator	: {
					current_tab		: 0,
					data : {
						ennemyResearch	: {	RapidDeployment:0, Ballistics:0, Metallurgy:0, Medicine:0, Dragonry:0, AerialCombat:0 },
						attackItems		: [false, false, false, false],
						defenseItems	: [false, false, false, false],
						attackUnits		: {
							Porter            :{meleeDamage:1,     rangeDamage:0,    defense:10,    life:45,     speed:100,  range:0,    x:0, qty:0},
							Conscript         :{meleeDamage:10,    rangeDamage:0,    defense:10,    life:75,     speed:200,  range:0,    x:0, qty:0},
							Spy               :{meleeDamage:5,     rangeDamage:0,    defense:5,     life:10,     speed:3000, range:0,    x:0, qty:0},
							Halberdsman       :{meleeDamage:40,    rangeDamage:0,    defense:40,    life:150,    speed:300,  range:0,    x:0, qty:0},
							Minotaur          :{meleeDamage:70,    rangeDamage:0,    defense:45,    life:225,    speed:275,  range:0,    x:0, qty:0},
							Longbowman        :{meleeDamage:5,     rangeDamage:80,   defense:30,    life:75,     speed:250,  range:1200, x:0, qty:0},
							SwiftStrikeDragon :{meleeDamage:150,   rangeDamage:0,    defense:60,    life:300,    speed:1000, range:0,    x:0, qty:0},
							BattleDragon      :{meleeDamage:300,   rangeDamage:0,    defense:300,   life:1500,   speed:750,  range:0,    x:0, qty:0},
							ArmoredTransport  :{meleeDamage:5,     rangeDamage:0,    defense:200,   life:750,    speed:150,  range:0,    x:0, qty:0},
							Giant             :{meleeDamage:1000,  rangeDamage:0,    defense:400,   life:4000,   speed:120,  range:0,    x:0, qty:0},
							FireMirror        :{meleeDamage:20,    rangeDamage:1200, defense:30,    life:1500,   speed:50,   range:1500, x:0, qty:0},
							PackDragon        :{meleeDamage:150,   rangeDamage:0,    defense:400,   life:850,    speed:1000, range:0,    x:0, qty:0},
							AquaTroop         :{meleeDamage:1600,  rangeDamage:800,  defense:300,   life:3000,   speed:500,  range:600,  x:0, qty:0},
							StoneTroop        :{meleeDamage:650,   rangeDamage:0,    defense:900,   life:15000,  speed:350,  range:0,    x:0, qty:0},
							FireTroop         :{meleeDamage:500,   rangeDamage:2000, defense:150,   life:1000,   speed:400,  range:1600, x:0, qty:0},
							WindTroop         :{meleeDamage:700,   rangeDamage:0,    defense:200,   life:2850,   speed:1350, range:0,    x:0, qty:0},
							GreatDragon       :{meleeDamage:2425,  rangeDamage:2425, defense:2425,  life:242514, speed:750,  range:1500, x:0, qty:0},
							WaterDragon       :{meleeDamage:2728,  rangeDamage:2425, defense:2122,  life:242514, speed:800,  range:1500, x:0, qty:0},
							StoneDragon       :{meleeDamage:9700,  rangeDamage:7276, defense:14550, life:970056, speed:650,  range:1700, x:0, qty:0},
							FireDragon        :{meleeDamage:6398,  rangeDamage:9564, defense:4132,  life:413216, speed:850,  range:1800, x:0, qty:0},
							WindDragon        :{meleeDamage:10306, rangeDamage:7275, defense:6063,  life:606285, speed:1300, range:1000, x:0, qty:0}
						},
						defenseUnits	: {
							Porter            :{meleeDamage:1,     rangeDamage:0,    defense:10,    life:45,     speed:100,  range:0,    x:0, qty:0},
							Conscript         :{meleeDamage:10,    rangeDamage:0,    defense:10,    life:75,     speed:200,  range:0,    x:0, qty:0},
							Spy               :{meleeDamage:5,     rangeDamage:0,    defense:5,     life:10,     speed:3000, range:0,    x:0, qty:0},
							Halberdsman       :{meleeDamage:40,    rangeDamage:0,    defense:40,    life:150,    speed:300,  range:0,    x:0, qty:0},
							Minotaur          :{meleeDamage:70,    rangeDamage:0,    defense:45,    life:225,    speed:275,  range:0,    x:0, qty:0},
							Longbowman        :{meleeDamage:5,     rangeDamage:80,   defense:30,    life:75,     speed:250,  range:1200, x:0, qty:0},
							SwiftStrikeDragon :{meleeDamage:150,   rangeDamage:0,    defense:60,    life:300,    speed:1000, range:0,    x:0, qty:0},
							BattleDragon      :{meleeDamage:300,   rangeDamage:0,    defense:300,   life:1500,   speed:750,  range:0,    x:0, qty:0},
							ArmoredTransport  :{meleeDamage:5,     rangeDamage:0,    defense:200,   life:750,    speed:150,  range:0,    x:0, qty:0},
							Giant             :{meleeDamage:1000,  rangeDamage:0,    defense:400,   life:4000,   speed:120,  range:0,    x:0, qty:0},
							FireMirror        :{meleeDamage:20,    rangeDamage:1200, defense:30,    life:1500,   speed:50,   range:1500, x:0, qty:0},
							PackDragon        :{meleeDamage:150,   rangeDamage:0,    defense:400,   life:850,    speed:1000, range:0,    x:0, qty:0},
							AquaTroop         :{meleeDamage:1600,  rangeDamage:800,  defense:300,   life:3000,   speed:500,  range:600,  x:0, qty:0},
							StoneTroop        :{meleeDamage:650,   rangeDamage:0,    defense:900,   life:15000,  speed:350,  range:0,    x:0, qty:0},
							FireTroop         :{meleeDamage:500,   rangeDamage:2000, defense:150,   life:1000,   speed:400,  range:1600, x:0, qty:0},
							WindTroop         :{meleeDamage:700,   rangeDamage:0,    defense:200,   life:2850,   speed:1350, range:0,    x:0, qty:0},
							GreatDragon       :{meleeDamage:2425,  rangeDamage:2425, defense:2425,  life:242514, speed:750,  range:1500, x:0, qty:0},
							WaterDragon       :{meleeDamage:2728,  rangeDamage:2425, defense:2122,  life:242514, speed:800,  range:1500, x:0, qty:0},
							StoneDragon       :{meleeDamage:9700,  rangeDamage:7276, defense:14550, life:970056, speed:650,  range:1700, x:0, qty:0},
							FireDragon        :{meleeDamage:6398,  rangeDamage:9564, defense:4132,  life:413216, speed:850,  range:1800, x:0, qty:0},
							WindDragon        :{meleeDamage:10306, rangeDamage:7275, defense:6063,  life:606285, speed:1300, range:1000, x:0, qty:0}
						},
						battleLog		: []
					},
					ownStatus		: 1,
					attDragLevel	: 0,
					defDragLevel	: 0,
					battleTurn		: 0,
					attGeneral		: 5,
					defGeneral		: 5,
					defWall			: 1
				},

				collapsed	: {
					quests	: [],
					train	: [],
					build	: []
				},

				messages	: {
					last_read	: 0,
					missing		: 0
				},
				messages_tower	: [],
				messages_delete	: {
					type				: 0,
					msgGame				: true,
					msgPlayer			: true,
					msgSentinel			: true,
					msgAlliance			: true,
					rptAnthropus		: true,
					rptTransport		: true,
					rptSpy				: true,
					rptBattle			: true,
					rptReinforcement 	: true,
					rptExceptMyAttacks	: true,
					rptExceptYourAttacks: true,
					dateAll				: true
				},
				search	: {
					enabled		: false,
					current_tab	: 0,
					sort_list	: '0',
					target		: {
						enabled	 : false,
						alliance : null,
						player	 : null,
						distance : 50,
						x		 : 999,
						y		 : 999,
						type	 : '',
						level	 : 0
					},
					grassland	: true,
					lake		: true,
					hill		: true,
					mountain	: true,
					forest		: true,
					nuage		: true,
					plain		: true,
					swamp		: true,
					min_level	: 1,
					max_level	: 10,
					unowned		: false
				},
				verboseLog	: { enabled : false },

				tower	: {
					enabled			: false,
					alarm_active	: false,
					nospy			: false,
					delay			: 2,
					unit			: 60,
					play_sound		: true,
					play_length		: 17,
					sound_url		: DEFAULT_ALERT_SOUND_URL,
					repeat			: false,
					repeat_delay	: 2,
					delete_report	: true,
					delete_delay	: 1,
					delete_unit		: 86400
				},

				attacks	: {
					enabled				: false,
					current_tab			: 0,
					choice				: kAnthropusCamp,
					delay_min			: 30,
					delay_max			: 60,
					delete_reports		: false,
					stop_on_loss		: false,
					log_attacks			: true,
					max_marches			: null,
					level_enable		: ['',     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0],
					level_distance		: ['',    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10],
					units				: ['',	  {},    {},    {},    {},    {},    {},    {},    {},    {},    {},    {}],
					include_great_dragon: ['', false, false, false, false, false, false, false, false, false, false, false],
					except_great_dragon	: ['',    {},    {},    {},    {},    {},    {},    {},    {},    {},    {},    {}],
					clear_all_targets	: false
				},
				multiple : {
					enabled				: false,
					delay_min			: 30,
					delay_max			: 45,
					max_marches			: null,
					stop_on_loss		: true,
					delete_reports		: false,
					include_great_dragon: false,
					target	: {
						x				: 0,
						y				: 0,
						type			: '',
						level			: 0,
						primary_units	: {},
						secondary_units	: {},
						saved_units		: {}
					}
				},
				spies	: {
					enabled			: false,
					delay_min		: 30,
					delay_max		: 45,
					max_marches		: null,
					stop_on_loss	: true,
					delete_reports	: false,
					target	: {
						x		: 0,
						y		: 0,
						type	: '',
						level	: 0,
						units	: {}
					},
				},
				waves	: {
					enabled				: false,
					current_tab			: 0,
					delay_min			: 30,
					delay_max			: 45,
					max_marches			: null,
					stop_on_loss		: true,
					delete_reports		: false,
					include_great_dragon: false,
					target	: {
						x			: 0,
						y			: 0,
						type		: '',
						level		: 0,
						units		: {},
						saved_units	: {}
					},
					history		: []
				}
			},
			// Statistics data - Will be stored in local storage and WON'T be backup in local file
			stats	: {
				attacks	: {
					start_at		: 0,
					run_time		: 0,
					total_attacks	: 0,
					items			:{},
					resources		:{},
					by_level		:[ '',
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}},
						{total_attacks:0, items:{}, resources:{}}
					]
				},
				multiple : {
					start_at		: 0,
					run_time		: 0,
					total_attacks	: 0,
					spoils			: {}
				},
				spies	: {
					start_at		: 0,
					run_time		: 0,
					total_attacks	: 0
				},
				waves	: {
					start_at		: 0,
					run_time		: 0,
					total_attacks	: 0,
					spoils			: {}
				}
			},
			// Dynamic data - Will be stored in local storage and WON'T be backup in local file
			dynamic	: {
				recall_marches	: [],
				players	: {
					memberships				: [],
					memberships_evolution	: [],
					evolution				: []
				},
				playercities	: {
					radius		: 0,
					last_update	: '',
					center		: { x:0, y:0 },
					cities		: []
				}
			}
		});

		logit (inspectObj (C, 6, 1));

		// Set the default locale use
		if ( Data.options.user_language != undefined && Data.options.user_language != null && Data.options.user_language != LANG_CODE) {
			setLanguage(Data.options.user_language);
		}
				//  Check basic initialization
		function stepStarting (current_step) { //, retry) {
			//var retry = retry || 0;
			var wait_time = Math.randRange(1500, 2500);
			var error_code;
			var error_msg;
            var progress_title;
			progressBar.resume ();

			function onSuccess (message, waitTime, currentStep) {
				verboseLog ( message );
				console.log ( message );
				STARTUP_TIMER = setTimeout(stepStarting, waitTime, currentStep);
			}

			function onError (errorCode, errorMsg, message, waitTime, currentStep) {
				error_code = errorCode;
				switch (errorCode) {
					// Bad request (API version ?)
					case 400 :	error_msg = translate('<b>Bad request!</b>');
								progressBar.stop;
								progressBar.hideshow(false);
								retry = 400;
								dialogFatal('<b>' + kFatalSeedTitle + '</b><br><br>\
											<font color="#BF0000"><b> ' + errorMsg + '</b></font>\
											<br><br><div align=left>\
											' + kFatalSeedMsg + '<br><br></div>\
											<a id="' + UID['support_link'] + '" href="" target="_blank">Bugs and Known Issues</a><br>');
								return;
								break;
					// Forbidden (RefControl or --no-referrers missing ?)
					case 403 :	error_msg = translate('<b>Forbidden!</b>');
								retry = 403;
								return;
								break;
					// Rate Limit Exceeded
					case 509 :	error_msg = translate('<b>Rate Limit Exceeded</b>, too many requests!');
								waitTime = 600;
								progressBar.update ({ step:currentStep, title:progress_title, stepText:translate('Fetching '+message)+'<br>'+ error_msg + ' - ' + translate('Retry in') + ' ' + waitTime });
								progressBar.pause ();
								verboseLog(error_msg + ' - ' + translate('Retry in :') + waitTime);
								STARTUP_TIMER = setTimeout( stepStarting, waitTime * 1000, currentStep );
								return;
								break;
					default : break;
				}
				error_msg = errorMsg;
				console.log('stepStarting: '+message+' retry ' + retry);
				STARTUP_TIMER = setTimeout( stepStarting, waitTime, currentStep, ++retry);
			}

			switch ( current_step ) {
				case 1: //  Translation Initialization
					progress_title = translate('Getting basic data...');
					progressBar.update ({ step:current_step, title:progress_title, stepText:translate('Fetching Translation matrix') });
					Translation.init(function (res) {
						if (res.ok) {
							onSuccess (translate('Translation Matrix Successfully initialized'), wait_time, current_step + 1);
						} else {
							onError (res.status, res.errmsg, translate('Translation matrix'), wait_time, current_step);
						}
					});
					break;
				case 2: //  Manifest Initialization
					progress_title = translate('Getting game data...');
					progressBar.update ({ step:current_step, title:progress_title, stepText:translate('Fetching Manifest') });
					Manifest.init(function (res) {
						if (res.ok) {
							onSuccess (translate('Manifest Successfully initialized'), wait_time, current_step + 1);
						} else {
							onError (res.status, res.errmsg, translate('Manifest'), wait_time, current_step);
						}
					});
					break;
				case 3: //  Seed Initialization
					progress_title = translate('Getting game data...');
					progressBar.update ({ step:current_step, title:progress_title, stepText:translate('Fetching Seed') });
					Seed.init(function (res) {
						if (res.ok) {
							onSuccess (translate('Seed Successfully initialized'), wait_time, current_step + 1);
						} else {
							onError (res.status, res.errmsg, translate('Seed'), wait_time, current_step);
						}
					});
					break;
				case 4: // Fetch capital data
					progress_title = translate('Getting cities data...');
					var cityIdx;
					// We make sure to first start the capital
					for (var i=0; i < Seed.cityInit.length; i++) {
						if (Seed.cityInit[i].type == 'capital') {
							cityIdx = Seed.cityInit[i].id;
						}
					}
					// Set progress bar steps / city
					citySteps = Math.floor(16 / (Seed.cityInit.length-1));
					progressBar.update ({ step:current_step, title:progress_title, stepText:translate('Fetching Capital data') });
					Seed.fetchCity (cityIdx, function(res) {
						if (res.ok) {
							wait_time = Math.randRange(2000,5000);
							onSuccess (translate('Capital data successfully fetched'), wait_time, current_step + 1);
						} else {
							onError (res.status, res.errmsg, translate('Capital data'), wait_time, current_step);
						}
					});
					break;
				case 5: // Fetch outposts data
					progress_title = translate('Getting cities data...');
					for (var i=0; i < Seed.cityInit.length; i++) {
						if (Seed.cityInit[i].loaded) {
							continue;
						}
						progressBar.update ({ step:current_step+(citySteps*i), title:progress_title, stepText:translate('Fetching Outpost #')+(i+1) });
						if (Seed.cityInit[i].timer) {
							clearTimeout (Seed.cityInit[i].timer);
						}
						var current_index = i;
						var cityIdx = Seed.cityInit[i].id;
						Seed.fetchCity (cityIdx, function(res) {
							if (res.ok) {
								wait_time = Math.randRange(2000,5000);
								if (current_index == Seed.cityInit.length - 1) {
									wait_time = 1500;
								}
								onSuccess (translate('Outpost #'+(i+1))+' '+translate('data successfully fetched'), wait_time, current_step);
							} else {
								onError (res.status, res.errmsg, translate('Outpost #'+(i+1)), wait_time, current_step);
							}
						});
						return;
					}
					startScript();
					return;
					break;
			}
			// Retries Limit
			if (retry > 20) {
				clearTimeout( STARTUP_TIMER );
				progressBar.stop;
				progressBar.hideshow(false);
				if (retry < 400) { // to avoid displaying twice a dialogFatal popup
					dialogFatal('<b>' + kFatalSeedTitle + '</b><br><br>\
								<font color="#BF0000"><b> ' + (error_code || retry) + ' - ' + error_msg + '</b></font>\
								<br><br><div align=left>\
								' + kFatalSeedMsg + '<br><br></div>\
								<a id="' + UID['support_link'] + '" href="" target="_blank">Bugs and Known Issues</a><br>');
				}
				return;
			}
		}
		
		actionLog('<B>' + scriptVersion + ' ' +translate('Loading...') + '</B>');
		consoleLog('<B>' + scriptVersion + ' ' +translate('Loading...') + '</B>');
		stepStarting( 1 );


		// TODO: check result, retry or disable tools?
		function startScript() {

			progressBar.update ({ step:19, title:translate('Completing...'), stepText:translate('Initializing map, auto-collect, ...') });
			Names.init ();
			Map.init ();
			Marches.init ();
			AutoCollect.init (); 
			Messages.init ();

			progressBar.stop;
			progressBar.hideshow(false);
			progressBarPop.destroy();

            // Jawz		
			if (Data.options.popUp==null || Data.options.popUp.x==null || Data.options.popUp.x=='' || isNaN(Data.options.popUp.x)){
				Data.options.popUp.x = 745;
				Data.options.popUp.y = 1;
			}
            // End Jawz

			// Get client screen width and adjust script popup to suit
			// if (screen.width >= 1240) {
			// 	var popupWidth = 475 + Math.floor(Math.random()*11);
			// } else {
			// 	var popupWidth = 395 + Math.floor(Math.random()*11);
			// }
			var popupWidth = 540 + Math.floor(Math.random()*11);
			var popupHeight = 795 + Math.floor(Math.random()*5); // Jawz - 795 instead of 725
			
			// Random Title
			makeRandomTitle();
			
			// Create a new popup DIV for the main script window
			mainPop = new PopUp ('main', Data.options.popUp.x, Data.options.popUp.y, popupWidth, popupHeight, Data.options.popUp.drag, function () { tabManager.hideTab(); }); //resetScript(); });

			// Check Our Coords
			Map.checkOurCoords();

			// Create all the tabs and insert them into the main script popup DIV
			tabManager.init(mainPop.getMainDiv());
			
			// Display everything
			Data.options.popUp.open = true;
			if (Data.options.popUp.open) {
				mainPop.show(true);
				tabManager.showTab();
			}

			// Jawz
			RecallMarch.init ();
			simpleSoundPlayer.init();
			// End Jawz

			window.addEventListener('unload', Data.onUnload, false);

			// Apply CSS styles (THIS MUST BE THE LAST ALWAYS)
			setStyles();

			actionLog('<B>' + scriptVersion + ' ' +translate('Loaded') + '</B>');
			consoleLog('<B>' + scriptVersion + ' ' +translate('Loaded') + '</B>');
		}
	} catch (e) {
		dialogFatal(kInitErr + e);
		logit(inspectObj (e, 8, 1));
	}
}


//*********************************** MyAjax package *********************************************
var MyAjax = {
	messageList : function (cat, numpage, callback){  // Jawz - Added numpage
		if (!cat){
			cat = 'all';
		}
		var npage = (numpage == -1 ? 1 : numpage); // Jawz
		var p = {}
		p['user_id']		= C.attrs.userId;
		p['dragon_heart']	= C.attrs.dragonHeart;
		p['count']			= 12;
		p['timestamp']		= parseInt(serverTime());
		p['_session_id']	= C.attrs.sessionId;
		p['category']		= cat;
		p['page']			= npage;  // Jawz - npage instead of 1
		p['version']		= api_version;
		new MyAjaxRequest ('reports.json', p, mycb, false);
		function mycb (rslt){
			if (rslt.ok && !rslt.dat.errors) {
				// Jawz
				if (numpage == -1 && callback)
					callback (rslt.dat.result.total);
				else
				// Jawz
				if (callback){
					callback (rslt.dat.result.report_notifications);
				}
			}
			else if(rslt.dat.result) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.result.errors[0];
				verboseLog('Ajax.messageList ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			
			if (callback) {
				callback (null);
			}
		}
	},

	messageDetail : function (id, callback){
		var p = {}
		p['user_id']		= C.attrs.userId;
		p['timestamp']		= parseInt(serverTime());
		p['_session_id']	= C.attrs.sessionId;
		p['version']		= api_version;
		p['dragon_heart']	= C.attrs.dragonHeart;
		new MyAjaxRequest ('reports/'+ id +'.json',p , mycb, false);
		function mycb (rslt){
			if (rslt.ok && !rslt.dat.errors) {
				if (callback){
					callback (rslt.dat.result);
				}
			}
			else if(rslt.dat.result) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.result.errors[0];
				verboseLog('Ajax.messageDetail ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			
			if (callback) {
				callback (null);
			}
		}
	},

	messageDelete : function (ids, callback){
		var p = {}
		p['user_id']		= C.attrs.userId;
		p['_method']		= 'delete';
		p['timestamp']		= parseInt(serverTime());
		p['_session_id']	= C.attrs.sessionId;
		p['ids']			= ids.join('|');
		p['dragon_heart']	= C.attrs.dragonHeart;
		p['version']		= api_version;
		new MyAjaxRequest ('reports/bulk_delete.json', p, mycb, true);
		function mycb (rslt){
			if (rslt.ok && !rslt.dat.errors) {
				rslt.ok = false;
			}
			else if(rslt.dat.result) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.result.errors[0];
				verboseLog('Ajax.messageDelete ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			
			if (callback){
				callback (rslt.ok);
			}
		}
	},

	// Use a json to wrap the building upgrade job
	buildingUpgrade : function (cityId, buildingId, callback){
		var t = MyAjax;
		var p = {};
		p['user_id']		= C.attrs.userId;
		p['dragon_heart']	= C.attrs.dragonHeart;
		p['_session_id']	= C.attrs.sessionId;
		p['_method']		= 'put';
		p['version']		= api_version;
		p['timestamp']		= parseInt(serverTime());
		new MyAjaxRequest ('cities/'+ cityId +'/buildings/'+ buildingId +'.json', p, mycb, true);
		function mycb (rslt){
			//logit ("BUILD RESPONSE:\n" + inspectObj (rslt, 10, 1));
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.result.success){
					Seed.jsonAddJob (rslt.dat.result.job);
				} 
			}
			else if(rslt.dat.result) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.result.errors[0];
				verboseLog('Ajax.buildingUpgrade ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			
			if (callback){
				callback (rslt);
			}
		}
	},

	troopTraining : function (troopType, troopQty, cityId, callback){
		var t = MyAjax;
		var p = {};
		p['user_id']		  = C.attrs.userId;
		p['_method']		  = 'post';
		p['timestamp']		  = parseInt(serverTime());
		p['_session_id']	  = C.attrs.sessionId;
		p['units[quantity]']  = troopQty;
		p['units[unit_type]'] = troopType;
		p['dragon_heart']	  = C.attrs.dragonHeart;
		p['version']		  = api_version;
		new MyAjaxRequest ('cities/'+ cityId +'/units.json', p, mycb, true);
		function mycb (rslt){
			//logit ("Troop Training Response:\n" + inspectObj (rslt, 10, 1));
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.result.success){
					Seed.updateCity (rslt.dat.result.city);
					Seed.jsonAddJob (rslt.dat.result.job);
				} 
			}
			else if(rslt.dat.result) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.result.errors[0];
				verboseLog('Ajax.troopTraining ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			
			if (callback){
				callback (rslt);
			}
		}
	},

	researchStart : function (cityId, researchType, callback){
		var t = MyAjax;
		var p = {};
		p['user_id']		= C.attrs.userId;
		p['_method']		= 'post';
		p['timestamp']		= parseInt(serverTime());
		p['_session_id']	= C.attrs.sessionId;
		p['research[research_type]'] = researchType;
		p['dragon_heart']	= C.attrs.dragonHeart;
		p['version']		= api_version;
		new MyAjaxRequest ('cities/'+ cityId +'/researches.json', p, mycb, true);
		function mycb (rslt){
			//logit ("RESEARCH RESPONSE:\n" + inspectObj (rslt, 10, 1));
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.result.success){
					Seed.updateCity (rslt.dat.result.city);
					Seed.jsonAddJob (rslt.dat.result.job);
				} 
			} 
			else if(rslt.dat.result) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.result.errors[0];
				verboseLog('Ajax.researchStart ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			
			if (callback){
				callback (rslt);
			}
		}
	},

	marchBusy : 0,
	marchSend : function (cityId, x, y, generalId, units, ownerId, callback) {
		var t = MyAjax;
		
		++t.marchBusy;

	    var dragon_type = null;
		var found_in_list = false;
		
		var u = {}
		var mt = false;
		var sendTroops = "{";
		for (var pu in units){
			if (units[pu] > 0) {
				for (var gd=0; gd < Seed.dragonList.length && !found_in_list; gd++) {
					if (Seed.dragonList[gd].type == units[pu]) {
						found_in_list = true;
						dragon_type = units[pu];
					}
				}
				u[pu] = units[pu];
				if (mt == true ){
					sendTroops += ',';
				}
				sendTroops += '"' + pu + '":' + units[pu];
				mt = true;
			}
		}
		sendTroops += "}";

		// Initialise POST data
		var p = {};
		p['march[march_type]']	= 'attack';
		p['march[y]']			= y;
		p['timestamp']			= parseInt(serverTime());
		p['march[units]']		= sendTroops;
		p['march[general_id]']	= generalId;
		p['version']			= api_version;
		p['_method']			= 'post';
		p['dragon_heart']		= C.attrs.dragonHeart;
		p['user_id']			= C.attrs.userId;
		p['march[x]']			= x;
		p['_session_id']		= C.attrs.sessionId;
		// Send request
		new MyAjaxRequest ('cities/'+ cityId +'/marches.json', p, mycb, true);
		function mycb(rslt) {
			--t.marchBusy;
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.result.success) {
					try {
						Seed.updateCity(rslt.dat.result.city);
						Seed.marches[rslt.dat.result.job.march_id].ownerId = ownerId;
						if (dragon_type !== null && Seed.dragons[dragon_type])
							Seed.dragons[dragon_type].is_in_city = false;
					} catch (e) {
						WinLog.write ('***********'+ e);
					}
				}
				else if(rslt.dat.result) {
					rslt.ok = false;
					rslt.errmsg = rslt.dat.result.reason;
					verboseLog('Ajax.marchSend ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
				}
			} else if (rslt.ok && rslt.dat.errors) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.errors;
				verboseLog('Ajax.marchSend ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			else if (rslt.status === 509){
				rslt.ok = false;
				rslt.errmsg = translate('<b>Rate Limit Exceeded</b>, too many requests!');
				verboseLog('Ajax.marchSend ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			
			if (callback){
				callback (rslt);
			}
		}
	},

	// Jawz - Spy march
	marchSpy : function (cityId, x, y, units, ownerId, callback) {
		var t = MyAjax;
		
		++t.marchBusy;
		
		var u = {}
		var mt = false;
		var sendTroops = "{";
		for (var pu in units){
			if (units[pu] > 0) {
				u[pu] = units[pu];
				if (mt == true ){
					sendTroops += ',';
				}
				sendTroops += '"' + pu + '":' + units[pu];
				mt = true;
			}
		}
		sendTroops += "}";
		
		// Initialise POST data
		var p = {};
		p['march[march_type]']	= 'spy';
		p['march[y]']			= y;
		p['timestamp']			= parseInt(serverTime());
		p['march[units]']		= sendTroops;
		p['version']			= api_version;
		p['_method']			= 'post';
		p['dragon_heart']		= C.attrs.dragonHeart;
		p['user_id']			= C.attrs.userId;
		p['march[x]']			= x;
		p['_session_id']		= C.attrs.sessionId;
		// Send request
		new MyAjaxRequest ('cities/'+ cityId +'/marches.json', p, mycb, true);
		function mycb(rslt) {
			--t.marchBusy;
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.result.success) {
					try {
						Seed.updateCity(rslt.dat.result.city);
						Seed.marches[rslt.dat.result.job.march_id].ownerId = ownerId;          
					} catch (e) {
						WinLog.write ('***********'+ e);
					}
				}
				else if(rslt.dat.result) {
					rslt.ok = false;
					rslt.errmsg = rslt.dat.result.reason;
					verboseLog('Ajax.marchSpy ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
				}
			} else if (rslt.ok && rslt.dat.errors) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.errors;
				verboseLog('Ajax.marchSpy ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			else if (rslt.status === 509){
				rslt.ok = false;
				rslt.errmsg = translate('<b>Rate Limit Exceeded</b>, too many requests!');
				verboseLog('Ajax.marchSpy ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}

			if (callback){
				callback (rslt);
			}
		}
	},
	// End Jawz - Spy march

	// Jawz - Transport march
	TransportMarch : function (cityId, x, y, units, resources, ownerId, callback) {
		var t = MyAjax;
		
		++t.marchBusy;

		var r = {}
		var trs = false;
		var sendResources = "{";
		for (var pr in resources){
			if (resources[pr] > 0) {
				r[pr] = resources[pr];
				if (trs == true ){
					sendResources += ',';
				}
				sendResources += '"' + pr + '":' + resources[pr];
				trs = true;
			}
		}
		sendResources += "}";
		
		var u = {}
		var mt = false;
		var sendTroops = "{";
		for (var pu in units){
			if (units[pu] > 0) {
				u[pu] = units[pu];
				if (mt == true ){
					sendTroops += ',';
				}
				sendTroops += '"' + pu + '":' + units[pu];
				mt = true;
			}
		}
		sendTroops += "}";
		
		// Initialise POST data
		var p = {};
		p['march[type]']	= 'TransportMarch';
		p['march[y]']			= y;
		p['timestamp']			= parseInt(serverTime());
		p['march[resources]']	= sendResources;
		p['march[units]']		= sendTroops;
		p['version']			= api_version;
		p['_method']			= 'post';
		p['dragon_heart']		= C.attrs.dragonHeart;
		p['user_id']			= C.attrs.userId;
		p['march[x]']			= x;
		p['_session_id']		= C.attrs.sessionId;
		// Send request
		new MyAjaxRequest ('cities/'+ cityId +'/marches.json', p, mycb, true);
		function mycb(rslt) {
			--t.marchBusy;
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.result.success) {
					try {
						Seed.updateCity(rslt.dat.result.city);
						Seed.marches[rslt.dat.result.job.march_id].ownerId = ownerId;          
					} catch (e) {
						WinLog.write ('***********'+ e);
					}
				}
				else if(rslt.dat.result) {
					rslt.ok = false;
					rslt.errmsg = rslt.dat.result.reason;
					verboseLog('Ajax.TransportMarch ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
				}
			} else if (rslt.ok && rslt.dat.errors) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.errors;
				verboseLog('Ajax.TransportMarch ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			} else if (rslt.status === 509){
				rslt.ok = false;
				rslt.errmsg = translate('<b>Rate Limit Exceeded</b>, too many requests!');
				verboseLog('Ajax.marchSend ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			
			
			if (callback){
				callback (rslt);
			}
		}
	},
	// End Jawz - transport march

	// This looks really cool, if it works
	marchRecall : function (cityId, marchId, callback){
		var t = MyAjax;
		var p = {};
		//++t.marchBusy;
		p['user_id']		= C.attrs.userId;
		p['dragon_heart']	= C.attrs.dragonHeart;
		p['_session_id']	= C.attrs.sessionId;
		p['_method']		= 'delete';
		p['version']		= api_version;
		p['timestamp']		= parseInt(serverTime());
		new MyAjaxRequest ('cities/'+ cityId +'/marches/'+ marchId +'.json', p, mycb, true);
		function mycb (rslt){
			//--t.marchBusy;
			//logit ("MARCH RESPONSE:\n" + inspectObj (rslt, 10, 1));
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.result.success){
					//logit (inspectObj (rslt, 9, 1));        
					Seed.updateCity(rslt.dat.result.city);
					//Seed.marches[rslt.dat.result.job.march_id].status = 'retreating';
				} 
				else if(rslt.dat.result) {
					rslt.ok = false;
					rslt.errmsg = rslt.dat.result.errors[0];
					verboseLog('Ajax.marchRecall ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
				}
			} else if (rslt.ok && rslt.dat.errors) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.errors;
				verboseLog('Ajax.marchRecall ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			if (callback){
				callback (rslt);
			}
		}
	},

	collectResources : function (cityId, callback){
		var p = {};
		p['user_id']		= C.attrs.userId;
		p['timestamp']		= parseInt(serverTime());
		p['_session_id']	= C.attrs.sessionId;
		p['version']		= api_version;
		p['dragon_heart']	= C.attrs.dragonHeart;
		new MyAjaxRequest ('cities/'+ cityId +'/move_resources.json', p, mycb, true);
		function mycb (rslt){
			if (rslt.ok && !rslt.dat.errors) {
				Seed.updateCity (rslt.dat.city);
			}
			else if(rslt.dat.result) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.result.errors[0];
				actionLog( translate('Auto-Collect Error') +': ' + rslt.msg);
			}

			if (callback){
				callback (rslt.ok);
			}
		}
	},

	// Jawz
	switchDefense : function (cityId, onOff, callback){
		var p = {};
		p['user_id']		= C.attrs.userId;
		p['_session_id']	= C.attrs.sessionId;
		p['callback']		= 'function Function() {}';
		p['version']		= api_version;
		p['dragon_heart']	= C.attrs.dragonHeart;
		p['timestamp']		= parseInt(serverTime());
		p['_method']		= 'put';
		p['defended']		= onOff ? '0' : '1';
		new MyAjaxRequest ('cities/'+ cityId +'.json', p, mycb, true);
		function mycb (rslt){
			if (rslt.ok && !rslt.dat.errors) {
				actionLog( translate('switchDefense OK') );
				Seed.updateCity (rslt.dat.city);
			}
			else if(rslt.dat.result) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.result.errors[0];
				actionLog( translate('switchDefense Error') +': ' + rslt.msg);
			}
			else if(rslt.dat.errors) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.errors[0];
				actionLog( translate('switchDefense Error') +': ' + rslt.errmsg);
			}
			if (callback){
				callback (rslt);
			}
		}
	},

	claimQuest : function (questName, callback){
		var p = {};
		p['user_id']		= C.attrs.userId;
		p['version']		= api_version;
		p['timestamp']		= parseInt(serverTime());
		p['quest_name']		= questName;
		p['_method']		= 'put';
		p['_session_id']	= C.attrs.sessionId;
		p['dragon_heart']	= C.attrs.dragonHeart;
		new MyAjaxRequest ('player_quests/claim.json', p, mycb, true);
		function mycb (rslt){
			if (rslt.ok && !rslt.dat.errors) {
				try {
					if (rslt.dat.quests.claimed) Seed.player.quests.claimed = cloneProps(rslt.dat.quests.claimed);
					if (rslt.dat.result.items) Seed.player.items = cloneProps(rslt.dat.result.items);
				} catch (e) {
					actionLog( translate('Quest claim Error') +': ' + e.name +' - '+ e.message);
				}
			}
			else if(rslt.dat.errors) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.errors[0];
				actionLog( translate('Quest claim Error') +': ' + rslt.errmsg);
			}
			if (callback){
				callback (rslt);
			}
		}
	},

	marchSpeedUp : function (cityId, url, jobId, callback){
		var p = {};
		p['job_id']			= jobId;
		p['version']		= api_version;
		p['_session_id']	= C.attrs.sessionId;
		p['user_id']		= C.attrs.userId;
		p['timestamp']		= parseInt(serverTime());
		p['_method']		= 'delete';
		p['dragon_heart']	= C.attrs.dragonHeart;
		new MyAjaxRequest ('player_items/'+url+'.json', p, mycb, true);
		function mycb (rslt){
			if (rslt.ok && !rslt.dat.errors) {
				try {
					if (rslt.dat.result.items) Seed.player.items = cloneProps(rslt.dat.result.items);
				} catch (e) {
					rslt.ok = false;
					rslt.errmsg = e.name +' - '+ e.message;
					actionLog( translate('March speedup Error') +': ' + e.name +' - '+ e.message);
				}
			}
			else if(rslt.dat.errors) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.errors[0];
				actionLog( translate('March speedup Error') +': ' + rslt.errmsg);
			}
			if (callback){
				callback (rslt);
			}
		}
	},

	troopReviving : function (troopType, troopQty, cityId, callback){
		var t = MyAjax;
		var p = {};
		p['_session_id']	  = C.attrs.sessionId;
		p['units[quantity]']  = troopQty;
		p['version']		  = api_version;
		p['_method']		  = 'post';
		p['user_id']		  = C.attrs.userId;
		p['units[unit_type]'] = troopType;
		p['timestamp']		  = parseInt(serverTime());
		p['dragon_heart']	  = C.attrs.dragonHeart;
		new MyAjaxRequest ('cities/'+ cityId +'/units/resurrect.json', p, mycb, true);
		function mycb (rslt){
			//logit ("Troop Training Response:\n" + inspectObj (rslt, 10, 1));
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.result.success){
					Seed.jsonAddJob (rslt.dat.result.job);
				} 
			}
			else if(rslt.dat.result) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.result.errors[0];
				verboseLog('Ajax.troopReviving ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			
			if (callback){
				callback (rslt);
			}
		}
	}
	// End Jawz
};
//*********************************** MyAjax package *********************************************


//*********************************** Auto-collect package *********************************************
var AutoCollect = {
	init : function (){
		var t = AutoCollect;
		t.setEnable (Data.options.autoCollect.enabled);
	},
	
	setEnable : function (onOff){
		var t = AutoCollect;
		clearTimeout (t.timer);
		Data.options.autoCollect.enabled = onOff;
		if (onOff){
			var time = (Data.options.autoCollect.delay*Data.options.autoCollect.unit) - serverTime() + Data.options.autoCollect.last_time;
			if (time <= 0){
				t.doit ();
			} else {
				t.timer = setTimeout (t.doit, time*1000);
			}
		}
	},
	
	doit : function (){
		var t = AutoCollect;
		Data.options.autoCollect.last_time = serverTime();
		for (var out=WATER_OUTPOST_ID; out<Seed.cities.length; ++out){  // Jawz - Start at 2 (0=Capital, 1=Spectral waiting to know if we can collect from spectral)
			collect (out, out*30000);
		}
		var delay_time = ((Data.options.autoCollect.delay * Data.options.autoCollect.unit) + (Math.random()*120))*1000;
		t.timer = setTimeout (t.doit, delay_time);

		function collect (cityIdx, delay){
			setTimeout (function(){
				MyAjax.collectResources (Seed.cities[cityIdx].id);
				actionLog (translate('Collected resources at outpost')+ ' <B>#'+ cityIdx +'</B>');
			}, delay);
		}
	}
};
//*********************************** Auto-collect package *********************************************


//*********************************** Buildings package *********************************************
var Buildings = {
	getList : function (cityIdx, type) {
		var ret = [];
		for (var i=0; i < Seed.cities[cityIdx].buildings.length; i++) {
			if (Seed.cities[cityIdx].buildings[i].type === type){
				ret.push (Seed.cities[cityIdx].buildings[i]);
			}
		}
		return ret;
	},
	getLevel : function (cityIdx, type){
		var build_list = Buildings.getList(cityIdx, type );
		if (build_list.length < 1){
			return {min:0, max:0};
		}
		build_list.sort(function(a,b){return a.level - b.level;});
		return {min:build_list[0].level, max:build_list[build_list.length-1].level};
	},
	getById : function (cityIdx, bid){
		for (var i=0; i < Seed.cities[cityIdx].buildings.length; i++){
			if (Seed.cities[cityIdx].buildings[i].id == bid){
				return (Seed.cities[cityIdx].buildings[i]);
			}
		}
		return null;
	},
	setLevel : function (city_id, bid, level){
		var cityIdx = Seed.cityIdx[city_id];
		for (var i=0; i < Seed.cities[cityIdx].buildings.length; i++){
			if (Seed.cities[cityIdx].buildings[i].id == bid){
				Seed.cities[cityIdx].buildings[i].level = level;
			}
		}
	}
};
//*********************************** Buildings package *********************************************


//*********************************** Data package *********************************************
var Data = {
	log			: [ [], [] ],
	defaults	: {},

	init : function (obj) {
		try {
			//Saves defaults properties
			Data.defaults.mergeWith( obj || {} );
			for ( var item_name in obj ) {
				// Checks if the object is already defined in the Data Object
				if ( typeof (Data[item_name]) == 'undefined' ) {
					//  Assign default object properties, if defined, otherwise an empty object
					Data[item_name] = typeof(obj[item_name]) != 'undefined' ? cloneProps(obj[item_name]) : {};
				}
				// Load the data stored, of the current item from localStorage
				var stored_object = Data.getObject( item_name );
				// Clean removed values from stored object ( max depth 2 )
				if (stored_object != null && typeof (stored_object) == 'object') {
					verboseLog ('Clean Removed Vars from : [ ' + name + ' ]');
					stored_object.cleanRemoved (Data[item_name], 1);
				}
				// Check if the default object is really an object
				if (Data[item_name] !== null && typeof (Data[item_name]) == 'object' ) {
					// Assign the properties of stored objeto into the default object, overwriting the values
					Data[item_name].mergeWith(stored_object);
				}
				else { //if ( stored_object !== '' )
					Data[item_name] = stored_object;
				} 
			}
		} catch (e) {
			alert ('This browser does not support LocalStorage\n\n'+e);
			return false;
		}
	},
	
	clearStorage : function() {
		localStorage.clear();
		for ( var item_name in Data.defaults ) {
			Data[item_name] = cloneProps(Data.defaults[item_name]);
		}
		actionLog('localStorage Deleted!');
	},

	getObject : function (key) {
		var item = localStorage.getItem( [SERVER_ID, USER_ID, key].join('_') );
		//logit('load setting ['+SERVER_ID+', '+USER_ID+', '+key+' = '+item);
		return ( item || '' ).charAt(0) === '{' ? JSON.parse( item || '{}' ) : eval( item );
	},

	makeZip : function () {
		var zip = new JSZip();
		var keys = getKeys (Data.defaults);
		for (var i=0; i < keys.length; i++)	{
			if ( /(marches|requests|dynamic)/i.test( keys[i] ) ) {
				keys.splice(i, 1);
			};
		}
		var content = '{';
		for (var i = 0; i < keys.length ; i++) {
			var name = keys[i];
			content += '"' + name + '":' + JSON.stringify(Data[name]);
			if (i < keys.length-1)
				content += ','
		}
		content += '}';
		zip.folder(scriptName).add('Realm' + SERVER_ID + '_' + Seed.player.name + '.txt', content);
		return zip.generate();
	},
	
	setObject : function (key, value) {
		if (key == 'log') return;
		try {
			//logit('save setting ['+SERVER_ID+', '+USER_ID+', '+key+' = '+JSON.stringify( value ) );
			localStorage.setItem( [SERVER_ID, USER_ID, key].join('_'), JSON.stringify( value ) );
		} catch(e){
			if ( e === QUOTA_EXCEEDED_ERR )	{
				logit (translate('LocalStorage') + ' : ' + translate('Quota exceeded') + '! ' + translate('Please, delete the cache and persistent data in your browser'));
			}
		}
	},

	onUnload : function () {
		verboseLog('Save Data in localStorage');
		var keys = getKeys (Data.defaults);
		for (var i=0; i < keys.length; i++) {
			var item_name = keys[i];
			Data.setObject ( item_name, Data[item_name] );
		}
	},

	setDefaultValues : function(tab) {
		switch (tab) {
			case 'waves'	: setWavesDefaults (); break;
			case 'multiple'	: setMultipleDefaults (); break;
			case 'spies'	: setSpiesDefaults (); break;
			case 'attacks'	: setAttacksDefaults (); break;
			case 'jobs'		: setJobsDefaults (); break;
			case 'search'	: setSearchDefaults (); break;
			case 'all'		: setWavesDefaults ();
							  setMultipleDefaults ();
							  setSpiesDefaults ();
							  setAttacksDefaults ();
							  setJobsDefaults ();
							  setSearchDefaults ();
						  break;
			default : break;
		}
		function setWavesDefaults () {
			if (Seed.cities[CAPITAL_ID].figures.marches.maximum &&
				(!Data.options.waves.max_marches || Data.options.waves.max_marches == null || Data.options.waves.max_marches == undefined))
				Data.options.waves.max_marches = Seed.cities[CAPITAL_ID].figures.marches.maximum;
		}
		function setMultipleDefaults () {
			if (Seed.cities[CAPITAL_ID].figures.marches.maximum &&
				(!Data.options.multiple.max_marches || Data.options.multiple.max_marches == null || Data.options.multiple.max_marches == undefined))
				Data.options.multiple.max_marches = parseIntZero(Seed.cities[CAPITAL_ID].figures.marches.maximum);
		}
		function setSpiesDefaults () {
			if (Seed.cities[CAPITAL_ID].figures.marches.maximum &&
				(!Data.options.spies.max_marches || Data.options.spies.max_marches == null || Data.options.spies.max_marches == undefined))
				Data.options.spies.max_marches = parseIntZero(Seed.cities[CAPITAL_ID].figures.marches.maximum);
		}
		function setAttacksDefaults () {
			for (var x=1; x<=11; x++) {
				if (!Data.options.attacks.units[x])
					Data.options.attacks.units[x] = {};
				// check if troops have been entered. Is not, set to default
				var exists = false;
				for (var j=0; j<attack_unit_types.length && !exists; j++) {
					if (Data.options.attacks.units[x][attack_unit_types[j]] && Data.options.attacks.units[x][attack_unit_types[j]] > 0)
						exists = true;
				}
				if (!exists) {
					for (var j=0; j<attack_unit_types.length; j++) {
						var num = 0
						switch (x) {
							case 1: 
								switch (attack_unit_types[j]) {
									case 'Longbowman': num = 110; break;
									case 'ArmoredTransport': num = 25; break;
									default: num = 0; break;
								}
								break;
							case 2:
								switch (attack_unit_types[j]) {
									case 'Longbowman': num = 550; break;
									case 'ArmoredTransport': num = 50; break;
									default: num = 0; break;
								}
								break;
							case 3:
								switch (attack_unit_types[j]) {
									case 'Longbowman': num = 1050; break;
									case 'ArmoredTransport': num = 80; break;
									default: num = 0; break;
								}
								break;
							case 4:
								switch (attack_unit_types[j]) {
									case 'Longbowman': num = 2100; break;
									case 'ArmoredTransport': num = 100; break;
									default: num = 0; break;
								}
								break;
							case 5:
								switch (attack_unit_types[j]) {
									case 'Longbowman': num = 5500; break;
									case 'ArmoredTransport': num = 130; break;
									default: num = 0; break;
								}
								break;
							case 6:
								switch (attack_unit_types[j]) {
									case 'Longbowman': num = 11000; break;
									case 'ArmoredTransport': num = 150; break;
									default: num = 0; break;
								}
								break;
							case 7:
								switch (attack_unit_types[j]) {
									case 'Longbowman': num = 30000; break;
									case 'ArmoredTransport': num = 1000; break;
									default: num = 0; break;
								}
								break;
							case 8:
								switch (attack_unit_types[j]) {
									case 'FireTroop': num = 2500; break;
									case 'ArmoredTransport': num = 1000; break;
									default: num = 0; break;
								}
								break;
							case 9:
								switch (attack_unit_types[j]) {
									case 'FireTroop': num = 3000; break;
									case 'ArmoredTransport': num = 1000; break;
									default: num = 0; break;
								}
								break;
							case 10:
								switch (attack_unit_types[j]) {
									case 'FireTroop': num = 4000; break;
									case 'ArmoredTransport': num = 1000; break;
									default: num = 0; break;
								}
								break;
							default: num = 0; break;
						}
						if (num > 0) {
							Data.options.attacks.units[x][attack_unit_types[j]] = num;
						}
					}
				}
			}
			for (var x=1; x<=11; x++) {
				if (!Data.options.attacks.except_great_dragon[x])
					Data.options.attacks.except_great_dragon[x] = {};
				if (Data.options.attacks.except_great_dragon[x] == null || Data.options.attacks.except_great_dragon[x] == undefined) {
					for (var j=0; j<Seed.dragonList.length; j++) {
						var dragon = Seed.dragonList[j];
						Data.options.attacks.except_great_dragon[x][dragon.type] = false;
					}
				}
			}
			if (Seed.cities[CAPITAL_ID].figures.marches.maximum &&
				(!Data.options.attacks.max_marches || Data.options.attacks.max_marches == null || Data.options.attacks.max_marches == undefined)){
				Data.options.attacks.max_marches = Seed.cities[CAPITAL_ID].figures.marches.maximum;
			}
		}
		function setJobsDefaults () {
			// Training initialization
			for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx){
				if (!Data.options.training.city[cityIdx]){
					Data.options.training.city[cityIdx] = {};
				}
				if (!Data.options.training.city[cityIdx].units)
					Data.options.training.city[cityIdx].units = [];

				var exists = false;
				for (var tt=0; tt < capital_units.length && !exists; tt++) {
					if (Data.options.training.city[cityIdx].units[tt] && Data.options.training.city[cityIdx].units[tt] > 0)
						exists = true;
				}
				if (!exists) {
					for (var tt=0; tt < capital_units.length; tt++){
						Data.options.training.city[cityIdx].units[tt] = 0;
						// User defined initialization for common units
						// Just change the troops number and activate the lines
						// to have always the same settings when cleaning the cache

						/* -Remove this line to activate-
						switch (capital_units[tt]) {
							case kPorter			: num = 0; break;
							case kConscript			: num = 1000; break;
							case kSpy				: num = 2000; break;
							case kHalberdsman		: num = 3000; break;
							case kMinotaur			: num = 4000; break;
							case kLongbowman		: num = 2500; break;
							case kSwiftStrikeDragon	: num = 2000; break;
							case kBattleDragon		: num = 1150; break;
							case kArmoredTransport	: num = 2000; break;
							case kGiant				: num = 1125; break;
							case kFireMirror		:
								switch (cityIdx) {
									case CAPITAL_ID : num = 1000; break;
									default : num = 0; break;
								}
								break;
							default : num = 0; break;
						}
						if (num > 0) {
							Data.options.training.city[cityIdx].units[tt] = num;
						}
						-Remove this line to activate- */

					}
					// Initialization for Elite units (aqua, granit, lava, banshees)
					// Just change the troops number and activate the lines
					// to have always the same settings when cleaning the cache

					/* -Remove this line to activate-
					switch (cityIdx) {
						case WATER_OUTPOST_ID : num = 1000; break;
						case STONE_OUTPOST_ID : num = 1250; break;
						case FIRE_OUTPOST_ID  : num = 900; break;
						case WIND_OUTPOST_ID  : num = 1600; break;
						default : num = 0; break;
					}
					var tt = capital_units.length;
					if (num > 0) {
						Data.options.training.city[cityIdx].units[tt] = num;
					}
					-Remove this line to activate- */

				}
				if (!Data.options.training.city[cityIdx].cap)
					Data.options.training.city[cityIdx].cap = [];

				var exists = false;
				for (var tt=0; tt < all_trainable_units.length && !exists; tt++) {
					if (Data.options.training.city[cityIdx].cap[tt] && Data.options.training.city[cityIdx].cap[tt] > 0)
						exists = true;
				}
				if (!exists) {
					for (var tt=0; tt < all_trainable_units.length; tt++){
						Data.options.training.city[cityIdx].cap[tt] = 0;

						// User defined cap initialization
						// Just change the troops cap and activate the lines
						// to have always the same cap settings when cleaning the cache

						/* -Remove this line to activate-
						switch (all_trainable_units[tt]) {
							case kPorter			: num = 10; break;
							case kConscript			: num = 1000000; break;
							case kSpy				: num = 100000; break;
							case kHalberdsman		: num = 600000; break;
							case kMinotaur			: num = 600000; break;
							case kLongbowman		: num = 1000000; break;
							case kSwiftStrikeDragon	: num = 200000; break;
							case kBattleDragon		: num = 100000; break;
							case kArmoredTransport	: num = 500000; break;
							case kGiant				: num = 100000; break;
							case kFireMirror		: num = 50000; break;
							case kAquaTroop			: num = 300000; break;
							case kStoneTroop		: num = 0; break;
							case kFireTroop			: num = 0; break;
							case kWindTroop			: num = 300000; break;
							default : num = 0; break;
						}
						Data.options.training.city[cityIdx].cap[tt] = num;
						-Remove this line to activate- */
					}
				}
			}
			// Build initilization
			for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx) {
				if (!Data.options.building.level_enable[cityIdx]){
					Data.options.building.level_enable[cityIdx] = {};
				}
				if (!Data.options.building.level_cap[cityIdx]){
					Data.options.building.level_cap[cityIdx] = {};
				}
			}
			// Research initialization
			for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx) {
				if (!Data.options.research.res_enable[cityIdx]) {
					Data.options.research.res_enable[cityIdx] = {};
				}
				if (!Data.options.research.res_cap[cityIdx]) {
					Data.options.research.res_cap[cityIdx] = {};
				}
			}
			// Resurrection initialization
			for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx){
				if (!Data.options.resurrect.res_enable[cityIdx]){
					Data.options.resurrect.res_enable[cityIdx] = {};
				}
				if (!Data.options.resurrect.res_max[cityIdx]) {
					Data.options.resurrect.res_max[cityIdx] = {};
				}
				for (tt=0; tt < all_unit_types.length; tt++){
					if (!Data.options.resurrect.res_max[cityIdx][all_unit_types[tt]]) {
						Data.options.resurrect.res_max[cityIdx][all_unit_types[tt]] = 0;
					}
				}
			}
		}
		function setSearchDefaults () {
			if (!Data.options.search.target.x || Data.options.search.target.x == 999) {
				Data.options.search.target.x = Seed.cities[CAPITAL_ID].x;
				Data.options.search.target.y = Seed.cities[CAPITAL_ID].y;
			}
			if (!Data.options.search.target.distance || Data.options.search.target.distance == null || Data.options.search.target.distance == undefined)
				Data.options.search.target.distance = 50;
			if (!Data.options.search.sort_list || Data.options.search.sort_list == null || Data.options.search.sort_list == undefined)
				Data.options.search.sort_list = '0';
			if (!Data.options.search.min_level || Data.options.search.min_level == null || Data.options.search.min_level == undefined)
				Data.options.search.min_level = 1;
			if (!Data.options.search.max_level || Data.options.search.max_level == null || Data.options.search.max_level == undefined)
				Data.options.search.max_level = 10;
		}
	}
};
//*********************************** Data package *********************************************


//*********************************** Manifest package *********************************************
var Manifest = {
	data : {},
	
	init : function (callback) {
		Manifest.fetchManifest(function (res) {
			if (res.ok) {
				verboseLog(translate('Manifest was Successfully requested from the server'));
			} else {
				verboseLog('fetchManifest ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			if (callback){
				callback(res);
			}
		});
	},
	
	fetchManifest : function (callback) {
		var now = new Date().getTime() / 1000;
		var params = {};
		params['user_id'] = C.attrs.userId;
		params['timestamp'] = parseInt(serverTime());
		params['_session_id'] = C.attrs.sessionId;
		params['version'] = api_version;
		params['dragon_heart'] = C.attrs.dragonHeart;
		
		new MyAjaxRequest ('manifest.json', params, function (res) {
			if (res.ok && !res.dat.errors) {
				Manifest.data = res.dat; // This holds the entire Manifest JSON data parsed as an object 
				try {
					Manifest.updateManifest();
				} catch (e) {
					res.ok = false;
					res.errmsg = 'fetchManifest when calling updateManifest returned this error: ' + e.toString();
				}
			} else if (res.ok && res.dat.errors) {
				res.ok = false;
				res.errmsg = res.dat.errors;
			}
			
			if (callback){
				callback(res);
			}
		}, false);
	},
	
	buildings : {
		byCityType : function (cityType, buildable, order) {
			var buildings = Manifest.data.buildings;
			var i, j, res = [];
			if (!buildable) {
				buildable = 'all';
			}
			if (!cityType) {
				cityType = 'all';
			}
			if (buildings.length > 0) {
				for (i = 0; i < buildings.length; i = i + 1) {
					if (buildings[i].buildable === buildable || buildable.toLowerCase() === 'all') {
						if (buildings[i].city_type.length > 0) {
							for (j = 0; j < buildings[i].city_type.length; j = j + 1) {
								if (buildings[i].city_type[j] === cityType.toLowerCase() || cityType.toLowerCase() === 'all') {
									res[res.length] = buildings[i];
									break;
								}
							}
						}
					}
				}
			}
			if (order) {
				res = Manifest.buildings.sortBy(res, order);
			}
			return res;
		},
		
		byLocation : function (location, buildable, order) {
			var buildings = Manifest.data.buildings;
			var i, res = [];
			if (!buildable) {
				buildable = 'all';
			}
			if (!location) {
				cityType = 'all';
			}
			if (buildings.length > 0) {
				for (i = 0; i < buildings.length; i = i + 1) {
					if (buildings[i].buildable === buildable || buildable.toLowerCase() === 'all') {
						if (buildings[i].location === location.toLowerCase() || location.toLowerCase() === 'all') {
							res[res.length] = buildings[i];
						}
					}
				}
			}
			if (order) {
				res = Manifest.buildings.sortBy(res, order);
			}
			return res;
		},
		
		sortBy : function (data, order) {
			var orderBy;
			if (!order) {
				order = {alphabetical: 'asc'};
			}
			for (orderBy in order) {
				switch (orderBy) {
				case 'alphabetical' :
					orderAlphabetical(order[orderBy]);
					break;
				case 'buildable' :
					orderBuildable(order[orderBy]);
					break;
				case 'location' :
					orderLocation(order[orderBy]);
					break;
				}
			}
			return data;
			
			function orderAlphabetical(order) {
				if (order.toLowerCase() === 'asc') {
					data.sort(function (a, b) {
						var typeA = a.type.toLowerCase(), typeB = b.type.toLowerCase();
						if (typeA < typeB) {return -1}
						if (typeA > typeB) {return 1}
						return 0;
					});
				} else if (order.toLowerCase() === 'desc') {
					data.sort(function (a, b) {
						var typeA = a.type.toLowerCase(), typeB = b.type.toLowerCase();
						if (typeA > typeB) {return -1}
						if (typeA < typeB) {return 1}
						return 0;
					});
				}
			}
		
			function orderBuildable(order) {
				if (order === true) {
					data.sort(function (a, b) {
						var buildableA = a.buildable, buildableB = b.buildable;
						if (buildableA < buildableB) {return -1}
						if (buildableA > buildableB) {return 1}
						return 0;
					});
				} else if (order === false) {
					data.sort(function (a, b) {
						var buildableA = a.buildable, buildableB = b.buildable;
						if (buildableA > buildableB) {return -1}
						if (buildableA < buildableB) {return 1}
						return 0;
					});
				}
			}

			
			function orderLocation(order) {
				if (order.toLowerCase() === 'city') {
					data.sort(function (a, b) {
						var locationA = a.location.toLowerCase(), locationB = b.location.toLowerCase();
						if (locationA < locationB) {return -1}
						if (locationA > locationB) {return 1}
						return 0;
					});
				} else if (order.toLowerCase() === 'field') {
					data.sort(function (a, b) {
						var locationA = a.location.toLowerCase(), locationB = b.location.toLowerCase();
						if (locationA > locationB) {return -1}
						if (locationA < locationB) {return 1}
						return 0;
					});
				}
			}
		},
	},
	
	building : function (type) { 
		console.log('Manifest.building');
		var b;
		
		if (type) {
			for (b = 0; b < Manifest.data.buildings.length; b = b + 1) {
			
			}
		} else {
			// Return an error message because no type was specificed
		}
	},
	
	updateManifest : function () {
		var data, i, j;
		
		// Initialise levels for each building & Save requirements and Stats
		data = Manifest.data.buildings;
		for (i=0; i < data.length; i++) {
			if (!Seed.requirements.building[data[i].type]) {
				Seed.requirements.building[data[i].type] = {};
			}
			if (!Seed.requirements.building[data[i].type].level) {
				Seed.requirements.building[data[i].type].level = [];
			}
			if (!Seed.stats.building[data[i].type]) {
				Seed.stats.building[data[i].type] = {};
			}
			if (!Seed.stats.building[data[i].type].level) {
				Seed.stats.building[data[i].type].level = [];
			}
			for (j=0; j < data[i].levels.length; j++) {
				Seed.requirements.building[data[i].type].level[data[i].levels[j].level] = data[i].levels[j].requirements;
				Seed.stats.building[data[i].type].level[data[i].levels[j].level] = { time:data[i].levels[j].time };
			}
		}

		// Initialise levels for each research & Save requirements and Stats
		data = Manifest.data.research;
		for (i=0; i < data.length; i++) {
			if (!Seed.requirements.research[data[i].type]) {
				Seed.requirements.research[data[i].type] = {};
			}
			if (!Seed.requirements.research[data[i].type].level) {
				Seed.requirements.research[data[i].type].level = [];
			}
			if (!Seed.stats.research[data[i].type]) {
				Seed.stats.research[data[i].type] = {};
			}
			if (!Seed.stats.research[data[i].type].level) {
				Seed.stats.research[data[i].type].level = [];
			}
			for (j=0; j < data[i].levels.length; j++) {
				Seed.requirements.research[data[i].type].level[data[i].levels[j].level] = data[i].levels[j].requirements;
				Seed.stats.research[data[i].type].level[data[i].levels[j].level] = { time:data[i].levels[j].time };
			}
		}

		// Initialise units & Save requirements and Stats ( by Jawz )
		data = Manifest.data.city.capital.units;
		for (i=0; i < data.length; i++) {
			if (!Seed.requirements.unit[data[i].type]) {
				Seed.requirements.unit[data[i].type] = [];
			}
			Seed.requirements.unit[data[i].type] = data[i].requirements;
			if (!Seed.stats.unit[data[i].type]) {
				Seed.stats.unit[data[i].type] = {};
			}
			Seed.stats.unit[data[i].type] = data[i].stats;
			Seed.stats.unit[data[i].type].time = data[i].time;
			Seed.stats.unit[data[i].type].upkeep = data[i].upkeep;
		}

		// Initialise troops resurrection requirements and Stats
		data = Manifest.data.city.spectral.units;
		for (i=0; i < data.length; i++) {
			if (!Seed.requirements.resurrect[data[i].type]) {
				Seed.requirements.resurrect[data[i].type] = [];
			}
			Seed.requirements.resurrect[data[i].type] = data[i].requirements;
			if (!Seed.stats.resurrect[data[i].type]) {
				Seed.stats.resurrect[data[i].type] = {};
			}
			Seed.stats.resurrect[data[i].type] = data[i].stats;
			Seed.stats.resurrect[data[i].type].time = data[i].time;
			Seed.stats.resurrect[data[i].type].upkeep = data[i].upkeep;
		}

		// Save quests manifest
		data = Manifest.data.quests;
		for (i=0; i < data.length; i++) {
			if (!Seed.quests.category[i]) {
				Seed.quests.category[i] = [];
			}
			Seed.quests.category[i] = data[i][0];
			for (j=0; j < data[i][1].length; j++){
				if (!Seed.quests.list[data[i][0]]) {
					Seed.quests.list[data[i][0]] = [];
				}
				var rec = {
					name		: data[i][1][j].name,
					recommended	: data[i][1][j].recommended,
					reward		: data[i][1][j].reward
				};
				Seed.quests.list[data[i][0]].push(rec);
			}
		}
		// End Jawz

		// Save Great dragons statistics by level
		// Jawz
		var greatDragonLvlsManifest = Manifest.data.great_dragon_levels;
		var waterDragonLvlsManifest = Manifest.data.water_dragon_levels;
		var stoneDragonLvlsManifest = Manifest.data.stone_dragon_levels;
		var fireDragonLvlsManifest  = Manifest.data.fire_dragon_levels;
		var windDragonLvlsManifest  = Manifest.data.wind_dragon_levels;
		for (var m=1; m<11; m++) {
			if (!Seed.greatDragons.GreatDragon[m])
				Seed.greatDragons.GreatDragon[m] = [];
			Seed.greatDragons.GreatDragon[m] = greatDragonLvlsManifest[m];
			if (!Seed.greatDragons.WaterDragon[m])
				Seed.greatDragons.WaterDragon[m] = [];
			Seed.greatDragons.WaterDragon[m] = waterDragonLvlsManifest[m];
			if (!Seed.greatDragons.StoneDragon[m])
				Seed.greatDragons.StoneDragon[m] = [];
			Seed.greatDragons.StoneDragon[m] = stoneDragonLvlsManifest[m];
			if (!Seed.greatDragons.FireDragon[m])
				Seed.greatDragons.FireDragon[m] = [];
			Seed.greatDragons.FireDragon[m] = fireDragonLvlsManifest[m];
			if (!Seed.greatDragons.WindDragon[m])
				Seed.greatDragons.WindDragon[m] = [];
			Seed.greatDragons.WindDragon[m] = windDragonLvlsManifest[m];
		}
		// End Jawz
	}

};
//*********************************** Manifest package *********************************************


//*********************************** Map package *********************************************
var Map = {
	init : function () {
		Data.init({
			map	: {
				terrains: {
					AnthropusCamp:[],
					Bog			:[],
					Forest		:[],
					Grassland	:[],
					Hill		:[],
					Lake		:[],
					Mountain	:[],
					Plain		:[],
					Fog			:[],
					City		:[],
					Outpost		:[],
					Wildernesses:[]
				},
				radius : 35,
				position: {x:0, y:0},
				targets: []
			}
		});
	},
	
	scanMap : function (x, y, radius, callback, options){
		var t = Map;
		t.scanMapObj(x, y, radius, function(res){
			if(res.done) {
				Data.map.terrains = res.terrains;
				// save map to localStorage
				try{
					localStorage.setItem('map', JSON.stringify(Data.map));
				} catch(e){
					if (e == QUOTA_EXCEEDED_ERR) {
						dispError ('<p style="font-size:12pt;">'+translate('LocalStorage')+'<p><br/>'+translate('Quota exceeded')+'!<br/>'+translate('Please, delete the cache and persistent data in your browser', Tabs.Jobs.container));
					}
				}
			} else {

			}
			callback(res);
		}, options);
	},

	scanMapObj : function (x, y, radius, callback, options){
		var t = Map;
		
		t.terrains = {
			AnthropusCamp:[],
			Bog			:[],
			Forest		:[],
			Grassland	:[],
			Hill		:[],
			Lake		:[],
			Mountain	:[],
			Plain		:[],
			Fog			:[],
			City		:[],
			Outpost		:[],
			Wildernesses:[]
		}; 
		
		t.centerX = x;
		t.centerY = y;
		t.firstX = t.normalize (x-radius+7);
		t.firstY =  t.normalize (y-radius+7);
		t.curIX = t.curIY = 0;
		t.widthI = parseInt(((radius*2)+14)/15);
		t.radius = radius;
		t.callback = callback; 
		t.circ = true;
		t.step = parseInt(t.widthI*t.widthI);

		t.count		= t.count || 0;
		
		t.options = {
			noTerrains		: false,
			noCities		: false,
			noWildernesses	: false,
			minLevel		: 0,
			withAlliance	: false, // Jawz - replaced true,
			printCSV		: false
		}
		if(options != undefined){
			Object.extend(t.options, options);
		}
				
		var p = {};
		p['user_id'] = C.attrs.userId;
		p['x'] = t.firstX;
		p['y'] = t.firstY;
		p['timestamp'] = parseInt(serverTime());
		p['_session_id'] = C.attrs.sessionId;
		p['dragon_heart'] = C.attrs.dragonHeart;
		p['version'] = map_api_version;  
		new MyAjaxRequest ('map.json', p, t.gotMapObj, true);  // Jawz - Set to true
	},  
	
	gotMapObj : function (rslt){
		var t = Map;
		var x = rslt.dat.x;
		var byCoords = {}

		if (!rslt.ok){
			if (t.callback)
				t.callback (null);    // error !?!
			return;
		}
		
		// Terrains
		if(!t.options.noTerrais){
			for (var i=0; i < rslt.dat.terrain.length; i++)
			{
				for (var j=0; j < rslt.dat.terrain[i].length; j++)
				{
					var tArr = rslt.dat.terrain[i][j];
				
					// Check Options
					if (t.options.minLevel > tArr[1]) {
						continue;
					}
					
					if (tArr[0] == 'City' || tArr[0] == 'Outpost'){
						continue;
					}
					
					var dist = getDistance (t.centerX, t.centerY, tArr[2], tArr[3]);

					t.terrains[tArr[0]].push({
						x		: tArr[2], 
						y		: tArr[3], 
						dist	: dist, 
						type	: tArr[0], 
						lvl		: tArr[1],
						isAtt	: true,
						pName	: undefined, // Jawz
						last	: 0
					});

					byCoords[tArr[2]+','+tArr[3]] = {
						index	: t.terrains[tArr[0]].length-1,
						type	: tArr[0], 
						lvl		: tArr[1],
					};

				}
			}
		}
	
		//Cities
		if(!t.options.noCities){
			for (var i=0; i < rslt.dat.map_cities.length; i++)
			{
				var target = rslt.dat.map_cities[i];
				
				// Skip our alliance or owner
				if ( (Seed.player.id == target.player.id) ||
					(Seed.player.alliance != undefined && target.player.alliance != undefined && Seed.player.alliance.id == target.player.alliance.id)
					) {
					continue;
				}
				
				//Check Options
				if ((t.options.minLevel > target.level) ||
					(t.options.withAlliance && target.player.alliance == undefined)
					){
						continue;
				}
				
				var dist = getDistance(t.centerX, t.centerY, target.x, target.y);

				var obj = {
					x		: target.x,
					y		: target.y,
					dist	: dist,
					type	: target.type,
					lvl		: target.level,
					id		: target.id,
					name	: target.name,
					pId		: target.player.id,
					pName	: target.player.name,
					pLvl	: target.player.level,
					pRace	: target.player.race,
					pType	: target.player.type,
					pMight	: target.player.might,
					isAtt	: (target.player.alliance == undefined),
					last	: 0
				};
				
				if(target.player.alliance != undefined){
					obj.pAlliId = target.player.alliance.id;
					obj.pAlli = target.player.alliance.name;
				}
				
				if(target.outpost_type != undefined){
					obj.life = target.life;
					obj.maxLife = target.maximum_life;
					obj.recRate = target.recovery_rate;
					obj.opType = target.outpost_type;
				}
				
				if(target.type == 'Capital'){
					t.terrains.City.push(obj);
				} else {
					t.terrains.Outpost.push(obj);
				}
			}
		}

		//Wildernesses
		if(!t.options.noWildernesses){
			for (var i=0; i < rslt.dat.city_wildernesses.length; i++)
			{
				var target = rslt.dat.city_wildernesses[i];
				var xy = target.x+','+target.y;

				// Skip our alliance or owner
				if ( (Seed.player.id == target.player.id) ||
					(Seed.player.alliance != undefined && target.player.alliance != undefined && Seed.player.alliance.id == target.player.alliance.id)
					) {
					if (byCoords[xy] != undefined){
						var type = byCoords[xy].type;
						t.terrains[type].splice(byCoords[xy].index,1);
					}
					continue;
				}
				
				//Check Options
				if ((t.options.minLevel > target.level) ||
					(t.options.withAlliance && target.player.alliance == undefined)
					){
						continue;
				}
				
				var dist = getDistance(t.centerX, t.centerY, target.x, target.y);
				
				var type = 'Wildernesses';
				var level = 0;
				
				if (byCoords[xy] != undefined){
					type = byCoords[xy].type;
					level = byCoords[xy].lvl;
					var terrain = t.terrains[type];
					if( terrain[byCoords[xy].index] ) {
						terrain[byCoords[xy].index].isAtt=false;
						terrain[byCoords[xy].index].pName = target.player.name; // Jawz
					}
				}
				
				var obj = {
					x		: target.x,
					y		: target.y,
					dist	: dist,
					type	: type,
					lvl		: level,
					id		: target.id,
					name	: target.name,
					pId		: target.player.id,
					pName	: target.player.name,
					pLvl	: target.player.level,
					pRace	: target.player.race,
					pType	: target.player.type,
					pMight	: target.player.might,
					isAtt	: (target.player.alliance == undefined),
					last	: 0
				};
				
				if(target.player.alliance != undefined){
					obj.pAlliId = target.player.alliance.id;
					obj.pAlli = target.player.alliance.name;
				}
				
				t.terrains.Wildernesses.push(obj);
			}
		}

		progressBar.update ({ step:t.count++ });

		if (++t.curIX >= t.widthI){
			t.curIX = 0;
			if (++t.curIY >= t.widthI){
				
				// print csv to console?
				if(t.options.printCSV){
					console.log( t.toCSV(t.terrains,'City') );
					console.log( t.toCSV(t.terrains,'Outpost') );
					console.log( t.toCSV(t.terrains,'Wildernesses') );
				}
				
				t.callback ({done:true,terrains:t.terrains});
				return;
			}
		}
		t.step = t.step - 1;
		t.callback ({done:false});

		setTimeout (function(){
			var p = {};
			p['user_id'] = C.attrs.userId;
			p['x'] = t.normalize(t.firstX+(t.curIX*15));
			p['y'] = t.normalize(t.firstY+(t.curIY*15));
			p['timestamp'] = parseInt(serverTime());
			p['_session_id'] = C.attrs.sessionId;
			p['dragon_heart'] = C.attrs.dragonHeart;
			p['version'] = map_api_version;
			new MyAjaxRequest ('map.json', p, t.gotMapObj, true);  // Jawz - Set to true
		}, MAP_DELAY * Math.floor(Math.random() * (-1) + 2));
	},
	
	toCSV : function(terrains,type,structure){
		if (terrains[type] == undefined) {
			return;
		}
		if(structure == undefined){
			structure = [
				'pAlli',
				'pName',
				'x',
				'y',
				'pLvl',
				'pMight',
				'name',
				'lvl',
				'type',
				'maxLife'
			];
		}
		var csv = [];
		// headers
		csv.push(structure.join(';').replace(/\"/,''));
		// structure
		console.log(terrains[type].length);
		for(var i=0; i < terrains[type].length; i++){
			console.log(terrains[type].name);
			var row='';
			for(var j=0; j < structure.length; ++j){
				if ( (terrains[type])[structure[j]] != undefined){
					row += (terrains[type])[structure[j]];
				}
				row += ';';
			}
			csv.push(row);
		}
		return csv;
	},
	
	sortBy : function(terrains,key,type){
		if (terrains[type] != undefined) {
			terrains[type].sort(function(a,b){
				return a[key] - b[key];
			});
		}
	},
	
	sortByDist : function(terrains,type){
		if (terrains[type] != undefined) {
			terrains[type].sort(function(a,b){
				return a.dist - b.dist;
			});
		}
	},
	
	sortByLevel : function(terrains,type){
		Map.sortBy(terrains,'Level', type);
	},
	
	getTargetByCoords : function(x,y,callback){
		Map.scanMapObj(x, y, 1, function(res){
			if(res.done){
				for (var type in res.terrains){
					for (var i=0; i < res.terrains[type].length; i++){
						if ( (res.terrains[type])[i].x == x && (res.terrains[type])[i].y == y){
							if ( callback ) callback( (res.terrains[type])[i] );
							return;
						}
					}
				}
			} else {
				if ( callback ) 
					callback(false);
				return;
			}
		});
	},
	
	checkOurCoords : function(){
		if (Data.map.position.x != Seed.cities[CAPITAL_ID].x || Data.map.position.y != Seed.cities[CAPITAL_ID].y){
			
			Data.map.position.x = Seed.cities[CAPITAL_ID].x;
			Data.map.position.y = Seed.cities[CAPITAL_ID].y;
			
			// ReCalculates Distances
			for (var n in Data.map.terrains){
				var targets = Data.map.terrains[n];
				for (var i=0; i< targets.length; i++){
					targets[i].dist = getDistance(Data.map.position.x, Data.map.position.y, targets[i].x, targets[i].y);
					//consoleLog(targets[i].dist);
				}
			}
		}
	},
	
	normalize : function (x){
		if (x > 750){
			x -= 750;
		}
		if (x < 0){
			x += 750;
		}
		return x;
	}
};
//*********************************** Map package *********************************************


// Jawz *********************************** March package *********************************************
var Marches = {
	table_output : {
		attacks	: {},
		waves	: {},
		spies	: {},
		multiple: {}
	},
	timeItems : [ {	name:'Blink',text:'1m'},
				  {	name:'Hop',  text:'5m'},
				  {	name:'Skip', text:'15m'},
				  {	name:'Jump', text:'1h00'},
				  {	name:'Leap', text:'2h30'} ],
	
	init : function () {
		var t = Marches;
		Data.init ({
			marches	: {
				start_at	: 0,
				attacks		: {},
				waves		: {},
				spies		: {},
				multiple	: {},
				count_limit	: 1
			}
		});
	},
	
	add : function (march_id, type) {
		var t = Marches;
		var march = Seed.marches[march_id];
		if (march === null) {
			if (DEBUG_MARCHES) WinLog.write ('***** ERRROR march missing from seed: '+ march.id);
		}  else {
			(Data.marches[type])[march_id] = cloneProps(march);
			if (DEBUG_MARCHES) WinLog.write ('Marches.add: ID=' + march.id + '  (' + march.x + ',' + march.y + ') General:' + march.general.id);
		}
	},

	remove : function (march_id, type) {   
		var t = Marches;
		if (march_id)
			delete ((Data.marches[type])[march_id]);
	},

	checkTimer : null,
	check : function () {
		var t = Marches;
		var now = parseInt(serverTime());
		clearTimeout (t.checkTimer);
		for (var type in Data.marches) {
			if ( !(/(attacks|waves|spies|multiple)/.test( type )) ){
				continue;
			}
			var marches = Data.marches[type];
			for (var id in marches) {
				if (marches[id].run_at < ( now - 60 )  && !(marches[id].has_report)) {
					// Will force at least 5 minute wait for the report to come in before it gives up on it. (fixed by Lord Mimir)
					if (marches[id].retry && marches[id].run_at < (now - 300)) {
						++Data.options.messages.missing;
						
						// Prevent errors in the marches queuing ?
						if (MyAjax.march_busy && t.march_busy > 0)
							--t.march_busy;
						
						if (DEBUG_MARCHES) WinLog.write ('March report never received! (now=' + now + ')\n'+ inspectObj (marches[id], 6, 1));    
						marches[id].has_report = true;
					} else {
						marches[id].retry = true;
						Messages.checkMessages( {category:'reports'} );
					}
				}
			}
		}
		t.checkTimer = setTimeout (t.check, Math.randRange(30000, 70000));
	},
	
	updateTable : function (table, type) {
		var t = Marches;
		var now = parseInt(serverTime());
		
		// shortcut for current table_output
		var table_output = t.table_output[type];

		// Clear table of old data  (by Lord Mimir)
		var cleared=0;
		for (var row = 0; row < table.rows.length; row++) {  
			var id = table.rows[row].getAttribute('ref');  
			if (Seed.marches[id] === undefined) {  
				cleared++;  
				table.deleteRow( row );  
				delete table_output[id];  
				row--;  
				continue;  
			} else if (cleared > 0) { 
				table_output[id].row -= cleared;   
			}
		}
		
		// loop to clear the attack if both no longer active and report has been recieved also sets dragons back in city.
		for (var id in Data.marches[type]) {
			if ( (Seed && Seed.marches[id] === undefined) && (Data.marches[type])[id].has_report ){
			    var dragon_type = null;
				var found_in_list = false;
				for (var unit_type in (Data.marches[type])[id].units) {
					for (var gd=0; gd < Seed.dragonList.length && !found_in_list; gd++) {
						if (Seed.dragonList[gd].type == unit_type) {
							found_in_list = true;
							dragon_type = unit_type;
						}
					}
				}
				if (dragon_type !== null && Seed.dragons[dragon_type])
					Seed.dragons[dragon_type].is_in_city = true;
				Marches.remove (id, type);
			}
		}

		/*	NOTE: We use a dual system, the first one to create the rows and
			the another to update it. We do it in this way because we don't want 
			to lose the event listeners of the buttons. */
		for (var id in Seed.marches) {
			var iRow, iCell;
			if (( Seed.marches[id].x === Seed.cities[CAPITAL_ID].x ) &&  
				( Seed.marches[id].y === Seed.cities[CAPITAL_ID].y ) && 
				( Seed.marches[id].status === 'marching' )
			   ){
				//Delete march as one can not attack own capital city.  
				//This part of code should not happen at all but is present as a catchall.
				delete Seed.marches[id];
				continue;
			}
			// Add the current march if it's not in the Data.marches
			if ( Data.marches.attacks[id] === undefined && 
				 Data.marches.waves[id] === undefined && 
				 Data.marches.spies[id] === undefined && 
				 Data.marches.multiple[id] === undefined
			   ){
				t.add(id,'attacks');
			}
			if ( ( Data.marches.attacks[id]  === undefined && type == 'attacks' ) || 
				 ( Data.marches.waves[id]    === undefined && type == 'waves' ) || 
				 ( Data.marches.spies[id]    === undefined && type == 'spies' ) || 
				 ( Data.marches.multiple[id] === undefined && type == 'multiple' )
			   ){
				//Only allow attacks on correct table.
				continue;
			}
			
			// shortcut of current march
			var march = Seed.marches[id];
			
			var retreating = (march.status === 'retreating');
			
			var time_left = march.run_at - now;
			var time_format;
			if (time_left < 0) {
				time_format = '...';
			} else if (isNaN(time_left)){
				time_format = '---';
			} else {
				time_format = timestr(time_left, true);
			}

			var units = '';
			for (var unit_type in march.units)
				units += ' ' + translate(unit_type) + ': ' + march.units[unit_type] + ' +';
			units = units.substr(1, units.length - 2);

			// Inserting Row
			if (table_output[id] === undefined && (time_left || march.status==='encamped')) {
				// Insert a new row
				iRow = table.insertRow(-1);
				// associates the current row number to the id of the march
				table_output[id] = {row:table.rows.length-1};
				iRow.setAttribute ('ref', id);
				iRow.title = [
							'(' + (march.general && march.general.name ? march.general.name : '----') + ')'
							,march.target_name
							,march.terrain_level
							,'[' + march.x + '/' + march.y + ']\n'
							,units.replace(/\+/g,'\n')
					].join(' ');
				// Retreating case
				if ( retreating ) {
					table_output[id].row_status = 2; // Retreating mode
					// march Status
					iCell = iRow.insertCell(-1);
					iCell.innerHTML = '<b>'+ translate('Returning') + ':</b>';
					// march Target
					iCell = iRow.insertCell(-1);
					iCell.className = 'wrap';
					iCell.innerHTML = march.target_name.nowrap();
					// march Coords
					iCell = iRow.insertCell(-1);
					iCell.style.textAlign = 'right';
					iCell.innerHTML = '&nbsp;<b>&lt;</b>&nbsp;';
					// march time_left
					iCell = iRow.insertCell(-1);
					iCell.innerHTML = time_format;
					// march Recall Button
					iCell = iRow.insertCell(-1);
					iCell.style.textAlign = 'right';
					iCell.innerHTML = '&nbsp;';
					// Speedups buttons
					for (var i=0; i<t.timeItems.length; i++) {
						iCell = iRow.insertCell(-1);
						iCell.style.textAlign = 'right';
						iCell.innerHTML = '&nbsp;';
						t.addSpeedUpButton(i, iCell, iRow.cells[3], id);
					}
				}
				
				// Marching case
				else {
					table_output[id].row_status = 1; // Marching mode
					// march Status
					iCell = iRow.insertCell(-1);
					switch (march.march_type) {
						case 'TransportMarch': iCell.innerHTML =  '<b>' + (RecallMarch.exists(id) ? translate('Yoyo') : translate('Transport')).capitalize() + ':</b>'; break;
						case 'SpyMarch'		 : iCell.innerHTML =  '<b>' + translate('Spy').capitalize() + ':</b>'; break;
						default: iCell.innerHTML =  '<b>' + translate(march.status).capitalize() + ':</b>'; break;
					}
					// march Target
					iCell = iRow.insertCell(-1);
					iCell.className = 'wrap';
					iCell.innerHTML = march.target_name.nowrap()  + '&nbsp;' + march.terrain_level + '&nbsp;';
					// march Coords
					iCell = iRow.insertCell(-1);
					iCell.style.textAlign = 'right';
					iCell.innerHTML = '<span class=jewel> [' + march.x +'/'+ march.y +']</span>&nbsp;<b>&gt;</b>&nbsp;';
					// march time_left
					iCell = iRow.insertCell(-1);
					iCell.style.textAlign = 'right';
					iCell.innerHTML = time_format;
					// march Recall Button
					iCell = iRow.insertCell(-1);
					
					var button = document.createElement('input');
					button.type = 'button';
					// Save the current March id in the attibute "ref" of the button
					button.setAttribute ('ref', id);
					if (march.status === 'encamped') {
						button.className = 'thin';
						button.value = 'X';
					} else {
						button.className = UID['bnt_red'] + ' thin';
						button.value = 'X';
					}
					button.addEventListener ('click', function (event){
						var self = event.target;
						self.disabled = true;
						self.style.display = 'none';
						// Take the march id from the "ref" attribute
						var march_id = self.getAttribute('ref');
						// Verify that the march really exists in Seed.marches
						if (Seed.marches[march_id]) {
							var city_id = Seed.marches[march_id].city_id;
							MyAjax.marchRecall (city_id, march_id, function (r) {
								if (r.ok && r.dat.result.success) {
									Seed.marches[march_id].status = 'retreating';
									(Data.marches[type])[march_id].status = 'retreating';
								}
							});
						}
					}, false);
					iCell.appendChild (button);
					// Speedups buttons
					for (var i=0; i<t.timeItems.length; i++) {
						iCell = iRow.insertCell(-1);
						iCell.style.textAlign = 'right';
						iCell.innerHTML = '&nbsp;';
						if (march.status != 'encamped')
							t.addSpeedUpButton(i, iCell, iRow.cells[3], id);
					}
				}
			}
			
			// Upgrade Row
			else {
				if (table_output[id] === undefined) continue;
				iRow = table.rows[ table_output[id].row ];
				if (iRow === undefined) {
					delete table_output[id];
					continue;
				}
				// Row Status cases
				switch ( table_output[id].row_status ) {
					// Finish state
					case 0:
						if (retreating && time_left > 0) { // added a check to prevent hidding of marches before they finish retreating.
							table_output[id].row_status = 2;
							// march Recall Button
							iRow.cells[4].innerHTML = '';
							// Speedups buttons
							for (var i=0; i<t.timeItems.length; i++) {
								iRow.cells[(5+i)].innerHTML = '';
							}
							continue;
						}
						iRow.style.display = 'none';
						table_output[id].row_status = -1;
						continue;
						break;
					// Marching state (Waiting for retreating)
					case 1:
					case 2:
						if (retreating) {
							table_output[id].row_status = 3; // Change to retreating state
							// march Status
							var html_status = '';
							html_status += '<b>' + translate('Returning') + ':</b>';
							iRow.cells[0].innerHTML = html_status;
							// march Target
							iRow.cells[1].innerHTML = march.target_name.nowrap();
							// march Coords
							iRow.cells[2].innerHTML = '&nbsp;<b>&lt;</b>&nbsp;';
							// march Recall Button
							iRow.cells[4].innerHTML = '';
							for (var i=0; i<t.timeItems.length; i++) {
								iRow.cells[(5+i)].innerHTML = '';
								t.addSpeedUpButton(i, iRow.cells[(5+i)], iRow.cells[3], id);
							}
						}
						else if ( (isNaN(time_left) || time_left < 0) &&  table_output[id].row_status === 1 ) {
							if ( march.terrain_type && !( /(Anthropus|City|Outpost|Bog)/.test(march.terrain_type)) ) {
								if (march.status === 'marching') {
									table_output[id].row_status = 2; // Change to Waiting for retreating (Action Taken)
								} else if ( march.status === 'encamped' ) {
									table_output[id].row_status = 4; // Change to encamped
									// Change button to  show recall
									// first clear old button. 
									iRow.cells[4].innerHTML = '';
									//now create button
									var button = document.createElement('input');
									button.type = 'button';
									// Save the current March id in the attibute "ref" of the button
									button.setAttribute ('ref', id);
									button.className = 'thin';
									button.value = 'X';
									button.addEventListener ('click', function (event){
										var self = event.target;
										self.disabled = true;
										self.style.display = 'none';
										// Take the march id from the "ref" attribute
										var march_id = self.getAttribute('ref');
										// Verify that the march really exists in Seed.marches
										if (Seed.marches[march_id]) {
											var city_id = Seed.marches[march_id].city_id;
											MyAjax.marchRecall (city_id, march_id, function (r) {
												if (r.ok && r.dat.result.success) {
													Seed.marches[march_id].status = 'retreating';
													(Data.marches[type])[march_id].status = 'retreating';
												}
											});
										}
									}, false);
									iRow.cells[4].appendChild (button);
									for (var i=0; i<t.timeItems.length; i++) {
										iRow.cells[(5+i)].innerHTML = '';
									}
								}
							}
						}
						break;
					// retreating state (Waiting for finish)
					case 3:
						if (isNaN(time_left) || time_left < 0) {
							table_output[id].row_status = 0; // Change to Finish state
						}
						break;
					//units encamped;
					case 4:
						if (retreating) {
							table_output[id].row_status = 3; // Change to retreating state
							// march Status
							iRow.cells[0].innerHTML = '<b>'+ translate('Retreating') + ':</b>';
							// march Target
							iRow.cells[1].innerHTML = march.target_name.nowrap();
							// march Coords
							iRow.cells[2].innerHTML = '&nbsp;<b>&lt;</b>&nbsp;';
							// march Recall Button
							iRow.cells[4].innerHTML = '';
							for (var i=0; i<t.timeItems.length; i++) {
								iRow.cells[(5+i)].innerHTML = '';
								t.addSpeedUpButton(i, iRow.cells[(5+i)], iRow.cells[3], id);
							}
						}
						break;
				}
				// march time_left
				iRow.cells[3].innerHTML = time_format;
			}
		}
	},

	addSpeedUpButton : function (itemId, nCell, nTimeCell, marchId) {
		if (!Data.options.speedups_enabled) return;
		var t = Marches;
		//var cellIndex = 5 + itemId;
		nCell.innerHTML = '';
		var num = isEmpty(Seed.player.items[t.timeItems[itemId].name],0);
		var button = document.createElement('input');
		button.type = 'button';
		// Save the current March id in the attibute "ref" of the button
		button.setAttribute ('ref', t.timeItems[itemId].name + '_' + marchId);
		button.value = t.timeItems[itemId].text;
		if (num > 0) {
			button.disabled = false;
			button.className = UID['bnt_green'] + ' thin';
			button.addEventListener ('click', function (event){
				var self = event.target;
				self.disabled = true;
				self.className = UID['bnt_disabled'] + ' thin';
				// Take the march id from the "ref" attribute
				var ids = self.getAttribute('ref').split('_');
				// Verify that the march really exists in Seed.marches
				if (Seed.marches[ids[1]]) {
					var city_id = Seed.marches[ids[1]].city_id;
					MyAjax.marchSpeedUp (city_id, ids[0], Seed.marches[ids[1]].job_id, function (r) {
						if (r.ok && r.dat.result.success) {
							if (r.dat.result.item_response) {
								itmResp = r.dat.result.item_response;
								if (itmResp.queue == 'march' && Seed.marches[itmResp.march_id]) {
									Seed.marches[itmResp.march_id].run_at   = itmResp.run_at;
									Seed.marches[itmResp.march_id].duration = itmResp.duration;
									var time_left = Seed.marches[itmResp.march_id].run_at - parseInt(serverTime());
									var time_format;
									if (time_left < 0) {
										time_format = '...';
									} else if (isNaN(time_left)){
										time_format = '---';
									} else {
										time_format = timestr(time_left, true);
									}
									nTimeCell.innerHTML = time_format;
								}
							}
							var num = isEmpty(Seed.player.items[ids[0]],0);
							if (num > 0) {
								button.disabled = false;
								button.className = UID['bnt_green'] + ' thin';
							}
						}
					});
				}
			}, false);
		} else {
			button.disabled = true;
			button.className = UID['bnt_disabled'] + ' thin';
		}
		nCell.appendChild (button);
	},
};
// Jawz *********************************** March package *********************************************


// Jawz *********************************** MemberShips package *********************************************
var MemberShips = {
 
	fetchMembership : function (callback, doDetail){
		var t = MemberShips;
		t.callback = callback; 
		t.doDetail = doDetail;
logit ('Try json memberships for alliance '+Seed.player.alliance+', '+Seed.player.alliance.id);
		if (Seed.player.alliance.id){
			var p = {};
			p['user_id']	  = C.attrs.userId;
			p['_session_id']  = C.attrs.sessionId;
			p['timestamp']	  = parseInt(serverTime());
			p['count']		  = 120;
			p['approved']	  = 1;
			p['dragon_heart'] = C.attrs.dragonHeart;
			p['version']	  = api_version;  
			var jsonType = 'alliances/'+Seed.player.alliance.id+'/memberships'; //.json';
			new MyAjaxRequest (jsonType, p, t.updateMemberships, false);
		}
	},
	updateMemberships : function (rslt){
		var t = MemberShips;
		var memberList = rslt.dat.alliance_memberships; 
		if (!rslt.ok){
			t.callback (null);
			return;
		}
		var ret = {member:[]};
		for (var m=0; m<memberList.length; m++) {
			//logit (inspectObj(memberList[m]));
			var d = {	player : memberList[m].player.name,
						id     : memberList[m].player.id,
						role   : memberList[m].role,
						might  : memberList[m].player.might,
						city   : memberList[m].player.city.name,
						x      : memberList[m].player.city.x,
						y      : memberList[m].player.city.y,
						dist   : getDistance(Seed.cities[CAPITAL_ID].x, Seed.cities[CAPITAL_ID].y, memberList[m].player.city.x, memberList[m].player.city.y)};
			ret.member.push (d);
		}
		ret.done = true;
		t.callback (ret); 
		return;
	},
}
// Jawz *********************************** MemberShips package *********************************************


//*********************************** Messages package *********************************************
var Messages = {
	readList : [],
	fetchTimer : null,
	lastQueued : 0,
	battleReportListeners : [],
	checkBusy : false,
	delete_queue : [],

	init : function (){
		Messages.checkMessages(500);
		window.addEventListener ('unload', Messages.onUnload, false);
	},

	marchAtTarget : function (){
		var t = Messages;
		t.checkMessages( {category:'reports'} );
	},

	deleteMessage : function (msgId){
		var t = Messages;
		t.delete_queue.push (msgId);
		if (t.delete_queue.length >= Math.randRange (5, 12)) {
			doit();
		}
		function doit (){
			var t = Messages;
			//logit ('DELETE MESSAGES:\n'+ inspectObj (t.deleteQueue, 5, 1));      
			MyAjax.messageDelete (t.delete_queue, function (rslt){
				var t = Messages;
				t.delete_queue = [];
			});
		}
	},

	onUnload : function (){
		var t = Messages;
		if (t.delete_queue.length>0){
			MyAjax.messageDelete (t.delete_queue);
		}
	},

	// check for battle reports
	checkMessages : function ( options ){
		var t = Messages;
		if (t.battleReportListeners.length == 0){
			return;
		}

		var category = ( options.category || 'all' ).toLowerCase(); // based on Didi idea (thanks)
		var waitTime = options.wait || 30000;

		RequestQueue.add ('checkMessages', function(){ doit(category); }, Math.randRange(waitTime, waitTime*1.5) );
		
		function doit (category){
			MyAjax.messageList (category, 1, function (rslt){ // Jawz - Added numpage
				var t = Messages;
				if (rslt == null) return;
				//logit ('messageList:\n' + inspectObj (rslt, 7, 1));        
				for (var i = rslt.length-1; i >= 0; i--)
				{
					if (rslt[i].report_type === 'BattleReport' && !rslt[i].read_at)
					{
						if (t.readList.indexOf(rslt[i].id) < 0){
							t.readList.push (rslt[i].id);
						}
					}
				}
				clearTimeout (t.fetchTimer);
				if (t.readList.length > 0){
					t.fetchTimer = setTimeout (t.fetchNext, Math.randRange(2000,4000));
				}
			});
		}
	},  

	fetchNext : function (){
		var t = Messages;
		var id = t.readList[0];
		if (!id){
			logit ('Messages.fetchNext BAD MESSAGE ID:\n'+ inspectObj (t.readList, 8, 1));
			return;
		}    
		clearTimeout (t.fetchTimer);
		MyAjax.messageDetail (id, function (rslt){
			var t = Messages;
			t.readList.shift();
			if (rslt)	// Jawz
				t.gotBattleReport (rslt);
			if (t.readList.length > 0){
				t.fetchTimer = setTimeout (t.fetchNext, Math.randRange(2000,4000));
			}
		});
	},

	gotBattleReport : function (rpt){
		var t = Messages;
		if (!rpt || !rpt.report) return; // Jawz
		if (DEBUG_MARCHES){
			WinLog.write ('Read Message: '+ rpt.report.location.terrain +' , '+ rpt.report.location.x +','+  rpt.report.location.y +' General: '+ rpt.report.attacker.general.id );    
		}
		for (var i=0; i < t.battleReportListeners.length; i++){
			t.battleReportListeners[i](rpt);
		}
	},

	addBattleReportListener : function (notify){
		var t = Messages;
		t.battleReportListeners.push (notify);
	},

	removeBattleReportListener : function (notify){
		var t = Messages;
		var i = t.battleReportListeners.indexOf (notify);
		if (i>=0){
			t.battleReportListeners.splice (i, 1);
		}
	}

};
//*********************************** Messages package *********************************************


//*********************************** Names package *********************************************
var Names = {
	troops : {
		'names' : [
		[0, kPorter, kPorter],
		[1, kConscript, kConscr],
		[2, kSpy, kSpy],
		[3, kHalberdsman, kHalbrd],
		[4, kMinotaur, kMino],
		[5, kLongbowman, kLBM],
		[6, kSwiftStrikeDragon, kSSDrg],
		[7, kBattleDragon, kBatDrg],
		[8, kArmoredTransport, kATrans],
		[9, kGiant, kGiant],
		[10, kFireMirror, kFireM],
		[11, kGreatDragon, kGrtDrg],
		[12, kWaterDragon, kWatDrg],
		[13, kStoneDragon, kStnDrg],
		[14, kFireDragon, kFireDrg],
		[15, kWindDragon, kWndDrg],
		[16, kAquaTroop, kATroop],
		[17, kStoneTroop, kSTroop],
		[18, kFireTroop, kFTroop],
		[19, kWindTroop, kWTroop],
		[20, kPackDragon, kPackDrg],
		],
	}, 

	items : {
		'names' : [
		[1, 'Blink', 'Blink'],
		[2, 'Hop', 'Hop'],
		[3, 'Skip', 'Skip'],
		[4, 'Jump', 'Jump'],
		[5, 'Leap', 'Leap'],
		[6, 'Bounce', 'Bounce'],
		[100, 'GreatDragonBodyArmor', 'GD Body'],
		[101, 'GreatDragonHelmet', 'GD Helmet'],
		[102, 'GreatDragonTailGuard', 'GD Tail'],
		[103, 'GreatDragonClawGuards', 'GD Claw'],
		[110, 'WaterDragonEgg', 'WaterEgg'],
		[111, 'WaterDragonBodyArmor', 'WD Body'],
		[112, 'WaterDragonHelmet', 'WD Helmet'],
		[113, 'WaterDragonTailGuard', 'WD Tail'],
		[114, 'WaterDragonClawGuards', 'WD Claw'],
		[115, 'AquaTroopRespirator', 'Respirator'],
		[116, 'AquaTroopRespiratorStack100', 'Respirator-100'],
		[117, 'AquaTroopRespiratorStack500', 'Respirator-500'],
		[118, 'AquaTroopRespiratorStack1000', 'Respirator-1000'],
		[120, 'StoneDragonEgg', 'StoneEgg'],
		[121, 'StoneDragonBodyArmor', 'SD Body'],
		[122, 'StoneDragonHelmet', 'SD Helmet'],
		[123, 'StoneDragonTailGuard', 'SD Tail'],
		[124, 'StoneDragonClawGuards', 'SD Claw'],
		[125, 'StoneTroopItem', 'Mandrakes'],
		[126, 'StoneTroopItemStack100', 'Mandrakes-100'],
		[127, 'StoneTroopItemStack500', 'Mandrakes-500'],
		[128, 'StoneTroopItemStack1000', 'Mandrakes-1000'],
		[130, 'FireDragonEgg', 'FireEgg'],
		[131, 'FireDragonBodyArmor', 'FD Body'],
		[132, 'FireDragonHelmet', 'FD Helmet'],
		[133, 'FireDragonTailGuard', 'FD Tail'],
		[134, 'FireDragonClawGuards', 'FD Claw'],
		[135, 'FireTroopItem', 'Runes'],
		[136, 'FireTroopItemStack100', 'Runes-100'],
		[137, 'FireTroopItemStack500', 'Runes-500'],
		[138, 'FireTroopItemStack1000', 'Runes-1000'],
		[140, 'WindDragonEgg', 'WindEgg'],
		[141, 'WindDragonBodyArmor', 'WiD Body'],
		[142, 'WindDragonHelmet', 'WiD Helmet'],
		[143, 'WindDragonTailGuard', 'WiD Tail'],
		[144, 'WindDragonClawGuards', 'WiD Claw'],
		[145, 'WindTroopItem', 'BansheeTalon'],
		[146, 'WindTroopItemStack100', 'Talons-100'],
		[147, 'WindTroopItemStack500', 'Talons-500'],
		[148, 'WindTroopItemStack1000', 'Talons-1000'],
		[149, 'AnthropusTalisman', 'Talisman'],
		[150, 'AnthropusTalisman50K', 'Talisman-50K'],
		],
	}, 

	init : function (){
		var t = Names;
		t.makeIdx (t.troops);
		t.makeIdx (t.items);
	},
	
	getItemAbbr : function (name){
		var x = Names.items.byName[name]; 
		if (x){
			return x[2];
		}
		return name.substr (0, 14);
	},
	
	getTroopAbbr : function (name){
		var x = Names.troops.byName[name]; 
		if (x){
			return x[2];
		}
		return name.substr (0, 14);
	},

	makeIdx : function (o){
		byId = {};
		byAbbr = {};
		byName = {};
		var n = o.names;
		for (var i=0; i < n.length; i++){
			byId[n[i][0]] = n[i];
			byAbbr[n[i][2]] = n[i];
			byName[n[i][1]] = n[i];
		}
		o.byId = byId;
		o.byAbbr = byAbbr;
		o.byName = byName;
	}
};
//*********************************** Names package *********************************************


// Jawz *********************************** Recall march package *********************************************
var RecallMarch = {
	init : function (){
		var t = RecallMarch;
		if (!Data.dynamic.recall_marches || Data.dynamic.recall_marches == undefined || Data.dynamic.recall_marches == "")
			Data.dynamic.recall_marches = [];
		t.timer = setTimeout (t.doit, 1000);
	},

	doit : function (){
		var t = RecallMarch;
		// first of all, we clear the array
		for (var m=0; m<Data.dynamic.recall_marches.length; m++){
			if (Data.dynamic.recall_marches[m] === undefined)
				Data.dynamic.recall_marches.splice(m,1);
			else if ((Data.dynamic.recall_marches[m] !== undefined) && (!Seed.marches[Data.dynamic.recall_marches[m].marchId] || Seed.marches[Data.dynamic.recall_marches[m].marchId] == null)){
				logit ('***** March to recall missing from seed: '+ inspectObj(Data.dynamic.recall_marches[m])); 
				Data.dynamic.recall_marches.splice(m,1);
			}
		}
		// Then, we deal with the remaining march to recall present into the array
		for (var m=0; m<Data.dynamic.recall_marches.length; m++){
			if ((Data.dynamic.recall_marches[m] !== undefined) && (Seed.marches[Data.dynamic.recall_marches[m].marchId] !== null)){
				var now = parseInt(serverTime());
				if ((Data.dynamic.recall_marches[m].run_at - now) < 60 && !Data.dynamic.recall_marches[m].recalling) {
					Data.dynamic.recall_marches[m].recalling = true;
					verboseLog ('Recalling march '+Data.dynamic.recall_marches[m].marchId+
							' arrives at '+timestr(Data.dynamic.recall_marches[m].run_at, true)+' '+
							', current time '+timestr(now, true)+', diff '+(Data.dynamic.recall_marches[m].run_at - now)+'s');
					doRecallMarch (Data.dynamic.recall_marches[m]);
				}
			}
		}
		t.timer = setTimeout (t.doit, 1000);
		function doRecallMarch (march){
			var targMsg = 'Recall march ' + march.marchId;
			verboseLog(targMsg + ' ' + translate('attempted'));
			new MyAjax.marchRecall (march.cityId, march.marchId, function (rslt){
				if (rslt.ok) {
					delete (march);
					verboseLog(targMsg + ' ' + translate('succeeded'));
				} else {
					march.recalling = false; // in order to try again a march recall
					verboseLog(targMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg);
				}
			});
		}
	},
	exists : function (march_id){
		var t = RecallMarch;
		if (!Data.dynamic.recall_marches || Data.dynamic.recall_marches.length === 0) return false;
		var found = false;
		for (var m=0; m<Data.dynamic.recall_marches.length && !found; m++){
			if (Data.dynamic.recall_marches[m].marchId == march_id) found = true;
		}
		return found;
	},
};
// Jawz *********************************** Recall march package *********************************************


//*********************************** RequestQueue package *********************************************
var RequestQueue = {
	que : {},
	add : function (id, func, maxWaitMillis){
		var t = RequestQueue;
		var now = serverTime();
		var maxWait = maxWaitMillis/1000;
		if (isNaN(maxWaitMillis)){
			maxWait = 1;
		}
		if (t.que[id]){
			if (now + maxWaitMillis >= t.que[id][2]){
				return;
			}
			clearTimeout(t.que[id][1]);  
		} 
		var timer = setTimeout (function(){myFunc(id)}, maxWait*1000);
		t.que[id] = [func, timer, now+maxWait];
		//dispQ ('RequestQueue.add id='+ id);  
		function myFunc(id){
			var t = RequestQueue;
			var func = t.que[id][0];
			delete t.que[id];
			//dispQ ('RequestQueue.doit id='+ id);  
			func();
		}
		
		// Translation
		function dispQ (msg){
			var now = serverTime();
			var m = msg + ' (now='+ now +'):\n';
			for (var p in RequestQueue.que){
				m += p +' : '+ RequestQueue.que[p][1] +' : '+ RequestQueue.que[p][2] +' ('+ (RequestQueue.que[p][2]-now) +')\n';
			}
			WinLog.write (m);
		}   
	}, 

	isPending : function (id){
		var t = RequestQueue;
		return t.que[id]?true:false;
	}
};
//*********************************** RequestQueue package *********************************************


//*********************************** Seed package *********************************************
var Seed = {
	cities			: [],	  // cities
	cityIdx			: {},     // 'indicies'
	cityTs			: {},     // timestamps of last update
	cityInit		: [],
	jobs			: {},     // by city
	marches			: {},
	numMarches		: 0,
	generals		: {},
	requirements	: { building:[], research:[], resurrect:[], unit:[] },
	stats			: { building:{}, dragons:{}, research:{}, resurrect:{}, unit:{} },
	// Jawz
	refresh_cities 	: [],
	greatDragons	: {GreatDragon:[], WaterDragon:[], StoneDragon:[], FireDragon:[], WindDragon:[]},
	dragonList		: [],
	dragons			: {},
	quests			: {category:[], list:[]},
	// End Jawz
	numGenerals		: 0,
	serverTimeOffset: 0,
	lastRefresh		: 0,
	tickTimer		: 0,

	numCities		: 0,

	init : function (callback) {
		var t = Seed;
	
		t.fetchPlayer(function (rslt) {
			if (rslt.ok) {
				verboseLog(translate('Player data was Successfully requested from the server'));
			} else {
				verboseLog('fetchPlayer ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			if (callback){
				callback(rslt);
			}
		}, { noCities: true } );
		clearInterval(t.tickTimer);
		t.tickTimer = setInterval(t.tick, 1000);
	},

	fetchPlayer : function (callback, options) {
		var city;
		if (callback instanceof Function) {
			var callback = callback;
			var options = options || {};
		} else {
			var options = callback;
			var callback = null;
		}

		if (options && options.noPlayer) {
			// options.cities (array)
			// only fetch the cities id in the array
			if (options && options.cities) {
				for (var i = 0; i < options.cities.length;  i++) {
					// First, check if exist the city_id (by Lord Mimir)
					if (Seed.cityIdx[options.cities[i]] !== undefined) {
						verboseLog('FetchPlayer : Call fetchCity');
						Seed.addToRefresh(options.cities[i], true);
						setTimeout( Seed.fetchCity, Math.randRange(i*1000,i*3000) , options.cities[i], callback );
					}
				}
				return;
			}
		}

		var p = {};
		p['user_id']		= C.attrs.userId;
		p['dragon_heart']	= C.attrs.dragonHeart;
		p['_session_id']	= C.attrs.sessionId;
		p['version']		= api_version;
		p['timestamp']		= parseInt(serverTime());		
		new MyAjaxRequest ('player.json', p, function (rslt) {
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.timestamp){
					Seed.serverTimeOffset = rslt.dat.timestamp - (new Date().getTime() / 1000);
				}
				
				Seed.player = rslt.dat; 

				// options.cities (array)
				// only fetch the cities id in the array
				if (options && options.cities) {
					for (var i = 0; i < options.cities.length;  i++) {
						// First, check if exist the city_id (by Lord Mimir)
						if (Seed.cityIdx[options.cities[i]] !== undefined) {
							verboseLog('FetchPlayer / player.json : Call fetchCity');
							Seed.addToRefresh(options.cities[i], true);
							setTimeout( Seed.fetchCity, Math.randRange(i*1000,i*3000) , options.cities[i], callback );
						}
					}
					return;
				}

				// Fill the cityInit array 
				// (used here & in the StartUp process so it must be before to verified options.noCities)
				var i = 0;
				for (city in rslt.dat.cities) {
					if (Seed.cityInit[i] === undefined ) {
						Seed.cityInit[i] = {};
					}
					Seed.cityInit[i].id = rslt.dat.cities[city].id;
					Seed.cityInit[i].type = city;
					i++;
				}

				// option.noCities (boolean)
				// Don't fetch Cities if we are from StartUp, because we do from there
				if (options && options.noCities) {
					if (callback)
						callback (rslt);
					return;
				}
				
				// OK, fetch all cities
				try {
					for (var i=0; i < Seed.cityInit.length; i++) {
						if (Seed.cityInit[i].timer){
							clearTimeout (Seed.cityInit[i].timer);
						}
						verboseLog('FetchPlayer / all cities : Call fetchCity');
						Seed.addToRefresh(Seed.cityInit[i].id, true);
						Seed.cityInit[i].timer = setTimeout (Seed.fetchCity, Math.randRange(i*2000,i*4000), Seed.cityInit[i].id, callback);
					}
				} catch (e) {
					rslt.ok = false;
					rslt.errmsg = e.toString();
				}
			}
			else if (rslt.ok && rslt.dat.errors) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.errors;
			}
			if ( callback ){
				callback (rslt);
			}
		});
	},
	
	fetchCity : function (cityId, callback) {
		if ( !cityId ) return;
		var t = Seed;
		var p = {};
		p['user_id'] = C.attrs.userId;
		p['dragon_heart'] = C.attrs.dragonHeart;
		p['_session_id'] = C.attrs.sessionId;
		p['timestamp'] = parseInt(serverTime());
		p['version'] = api_version;
		new MyAjaxRequest ('cities/'+ cityId +'.json', p, function (rslt) {
			if (rslt.ok && !rslt.dat.errors) {
				if (rslt.dat.timestamp){
					t.serverTimeOffset = rslt.dat.timestamp - (new Date().getTime() / 1000);
					if (rslt.dat.city.type == 'Capital')
						t.lastRefresh = serverTime ();
				}
				
				try {
					t.updateCity(rslt.dat.city);
				} catch (e) {
					rslt.ok = false;
					rslt.errmsg = e.toString();
				}
			}
			else if (rslt.ok && rslt.dat.errors) {
				rslt.ok = false;
				rslt.errmsg = rslt.dat.errors;
			}
			if (rslt.ok) {
				verboseLog('fetchCity ' + translate('attempt for') + ' ' + cityId + ' ' + translate('was returned with a status of') + ' ' + rslt.ok);
			} else {
				verboseLog('fetchCity ' + translate('attempt for') + ' ' + cityId + ' ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			if (callback){
				callback (rslt);
			}
		}, true);
	},

	addToRefresh : function (cityId, is_refreshing) {
		var t = Seed;
		var found = false;
		var now = serverTime ();
		for (var c=0; c < t.refresh_cities.length && !found; c++)
			if (t.refresh_cities[c].id == cityId) found = true;
		// if city not queued to refresh and time elapsed since last refresh done is greater than 1 minute
		if (!found) // && (now - t.cityTs[t.cities[cityId].id]) > 30)
			t.refresh_cities.push({id:cityId, isRefeshing:is_refreshing});
	},

	tick : function () {     // called once per second - to check for job completion
		var t = Seed;
		var now = parseInt(serverTime ());
		try {
			for (var p=0; p < all_resource_types.length; p++){
				var production = t.cities[CAPITAL_ID].figures.resource_rates[all_resource_types[p]];
				var actual = t.cities[CAPITAL_ID].resources[all_resource_types[p]];
				if ((actual < production.capacity && production.rate > 0) ||
					(actual > 0 && production.rate < 0)) {
					if (t.lastRefresh && t.lastRefresh != 0) {
						// Case when a delay is to take into account when city data has just been updated
						actual = actual + ((production.rate/3600) * parseInt(now - t.lastRefresh));
						t.lastRefresh = 0;
					} else
						actual = actual + (production.rate/3600);
					if (actual > production.capactity) actual = production.capacity;
					if (actual < 0) actual = 0; // Case of food with negative production rate
					// update the Seed resource total only if the city is not queued for refresh
					if (!t.refresh_cities[CAPITAL_ID])
						t.cities[CAPITAL_ID].resources[all_resource_types[p]] = actual;
				}
			}
		} catch (e) {
			verboseLog (translate('Resources stock levels update failed') + ': ' + inspectObj(e, 8, 1));
			clearInterval(t.tickTimer);
			setTimeout (t.restartTick, 30000);
			return;
		}

		// check for job completion
		for (var cityIdx in t.jobs) {
			for (var jobId in t.jobs[cityIdx]) {
				var job = t.jobs[cityIdx][jobId];
				if (job.done) {
					if (now > (job.run_at - 5)) {
						var march = t.marches[job.march_id];
						if (march) {
							if (march.status !== 'encamped')
								delete (t.jobs[cityIdx][jobId]);
						} else {
							delete (t.jobs[cityIdx][jobId]);
						}
					}
				} else {
					if (now > (job.run_at - 5)) {
						job.done = true;
						switch ( job.queue ) {
							case 'building':
								Buildings.setLevel (cityIdx, job.city_building_id, job.level);
								break;
							case 'march':
								var march = t.marches[job.march_id];
								if (march.status == 'marching') {
									t.addToRefresh(cityIdx, false);
									Messages.marchAtTarget(march);
									if (t.numMarches && t.numMarches > 0)
										--t.numMarches;
								}
								break;
							case 'research':
								Seed.player.research[job.research_type] = job.level;
								break;
							case 'units':
								Seed.cities[CAPITAL_ID].units[job.unit_type] += job.quantity;
								break;
							default : t.addToRefresh(cityIdx, false);
						}
						delete (t.jobs[cityIdx][jobId]);
					}
				}
			}
		}
		// delete expired marches ...
		for (var id in t.marches) {
			var march = t.marches[id];
			if ((march.run_at < now-10) || ((march.status=='returning' || march.status=='retreating') && march.run_at < now-2)) {
				delete (t.marches[id]);
				if (march.status=='returning' || march.status == 'retreating')
					t.addToRefresh(t.cities[CAPITAL_ID].id, false);
				if (march.units['WaterDragon']) t.addToRefresh(t.cities[WATER_OUTPOST_ID].id, false);
				if (march.units['StoneDragon']) t.addToRefresh(t.cities[STONE_OUTPOST_ID].id, false);
				if (march.units['FireDragon'])  t.addToRefresh(t.cities[FIRE_OUTPOST_ID].id, false);
				if (march.units['WindDragon'])  t.addToRefresh(t.cities[WIND_OUTPOST_ID].id, false);
				if (t.numMarches > 0) --t.numMarches;
			}
		}

		if (t.refresh_cities.length) {
			for (var idx = t.refresh_cities.length-1; idx >=0 ; idx-- ) {
				var city_id = t.refresh_cities[idx];
				if (!city_id.isRefreshing) {
					city_id.isRefreshing = true;
					verboseLog('Seed.tick : Call fetchCity for ' + city_id.id);
					t.fetchCity (city_id.id, function(res) {
						if (res.ok) {
							t.refresh_cities.splice (idx, 1);
						} else {
							var error_msg;
							if (res.status === 509) {
								error_msg = '<b>Rate Limit Exceeded</b>, too many requests!';
							} else error_msg = res.errmsg;
							verboseLog('Seed.tick : Call fetchCity returned code '+res.status+' - ' + res.errmsg);
							clearInterval(t.tickTimer);
							setTimeout (t.restartTick, 30000);
							return;
						}
					});
				}
			}
		}
	},
	restartTick : function () {
		var t = Seed;
		if (t.tickTimer) clearInterval(t.tickTimer);
		t.tickTimer = setInterval(t.tick, 1000);
	},

	// TODO: fix march destination when city (shows as bog)
	updateCity : function (city) {
		var t = Seed;
		if (!city) return;
		verboseLog(translate('Updating City values')+': ' + city.name);
		
		var cityIdx = (city.type == 'Capital') ? CAPITAL_ID : (city.name.charAt(city.name.length-1));
		
		// Fixed by Lord Mimir (thanks you very much!)
		var cityIdx;    
		if (typeof t.cityIdx[city.id] !== 'undefined' && t.cityIdx[city.id] !== null) {
			cityIdx = t.cityIdx[city.id];
		}
		else if (city.type == 'Capital') {
			cityIdx = CAPITAL_ID;
		} else {
			switch (city.outpost_type){
				case 'WaterDragonOutpost'	: cityIdx = WATER_OUTPOST_ID; break;
				case 'StoneDragonOutpost'	: cityIdx = STONE_OUTPOST_ID; break;
				case 'FireDragonOutpost'	: cityIdx = FIRE_OUTPOST_ID; break;
				case 'WindDragonOutpost'	: cityIdx = WIND_OUTPOST_ID; break;
				case 'SpectralOutpost'		: cityIdx = SPECTRAL_OUTPOST_ID; break;
				default: cityIdx = SPECTRAL_OUTPOST_ID; // Spectral outpost
			}
			
			if (cityIdx == CAPITAL_ID) cityIdx = WATER_OUTPOST_ID;

			if (typeof t.cities[cityIdx] !== 'undefined' && t.cities[cityIdx] !== null)
			{
				t.cityIdx[t.cities[cityIdx].id] = t.cities.length;
				t.cities[t.cities.length] = t.cities[cityIdx];
			}
		}
		
		t.cities[cityIdx] = city;
		
		t.cityIdx[city.id] = cityIdx;
		
		t.cityTs[city.id] = serverTime();  

		// Add dragons object (by Didi)
		var dragon = null;
		switch (parseInt(cityIdx)) {
			case CAPITAL_ID			: dragon = city.great_dragon; break;
			case WATER_OUTPOST_ID	: dragon = city.water_dragon; break;
			case STONE_OUTPOST_ID	: dragon = city.stone_dragon; break;
			case FIRE_OUTPOST_ID	: dragon = city.fire_dragon; break;
			case WIND_OUTPOST_ID	: dragon = city.wind_dragon; break;
			default : dragon = null; break;
		}
		if (dragon !== null) {
			var dragon_type = dragon.type.substring(dragon.type.indexOf('::')+2);
			dragon_type = (dragon_type == 'CityGreatDragon') ? 'GreatDragon' : dragon_type;
			var aerial_combat_level = (Seed.player.research['AerialCombat']) ? Seed.player.research['AerialCombat'] : 0;
			t.dragons[dragon_type] = dragon;
			t.dragons[dragon_type].name       = dragon_type;
			t.dragons[dragon_type].can_attack = (t.checkArmorDragon(dragon_type) && t.dragons[dragon_type].level >=8 && aerial_combat_level > 0 && dragon_type != 'SpectralDragon');
			t.dragons[dragon_type].city_id    = city.id;
		
			if (dragon.life !== dragon.maximum_life) {
				t.dragons[dragon_type].cure_at = serverTime() + ((dragon.maximum_life - dragon.life) / dragon.recovery_rate)*3600;
			} else {
				t.dragons[dragon_type].cure_at = serverTime();
			}
			var found_in_list = false;
			for (var gd=0; gd < t.dragonList.length && !found_in_list; gd++)
				if (t.dragonList[gd].type == dragon_type) found_in_list = true;
			if (!found_in_list)	{
				t.dragonList.push ({type:dragon_type, city:cityIdx});
				t.dragonList.sort( function(a,b){ return a.city - b.city; } );
			}
		}
		
		if (cityIdx == CAPITAL_ID) {
			// generals
			for (var i=0; i<city.generals.length; i++) {
				t.generals[city.generals[i].id] = city.generals[i];
			}
			t.numGenerals = city.generals.length;
			
			// marches
			t.numMarches = 0;
			for (var i=0; i < city.marches.length; i++)
			{
				var march = city.marches[i];
				
				if (march.general_id){
					t.generals[march.general_id].busy = true;
				}
				var dragon_type = null;
				var found_in_list = false;
				for (var unit_type in  march.units)	{
					for (var gd=0; gd < t.dragonList.length && !found_in_list; gd++) {
						if (t.dragonList[gd].type == unit_type) {
							found_in_list = true;
							dragon_type = unit_type;
						}
					}
				}
				if (dragon_type !== null && t.dragons[dragon_type])
					t.dragons[dragon_type].is_in_city = false;

				if (t.marches[march.id] != undefined){
					//if (march.status != 'retreating')
						++t.numMarches;
				}
			
				t.checkMarchStatus (march);
				
				//verboseLog(march.id+' '+march.march_type+' '+march.target+' '+march.status);
			}
			verboseLog('Num of Marches: '+t.numMarches);
		}
		// jobs
		for (var i=0; i < city.jobs.length; i++){
			t.checkAddJob (city.jobs[i]);
		}
		for (var i=0; i < t.cityInit.length; i++){
			if (t.cityInit[i].id === city.id && !t.cityInit[i].loaded) {
				t.cityInit[i].loaded = true;
				var message = translate('City') + ' ' + city.id + ' ' + translate('Successfully initialized');
				verboseLog(message);
				console.log(message);
			}
		}
	},

	// Function to count number of piece armor (by Didi)
	checkArmorDragon : function (dragon_type) {
		var t = Seed;
		var armors = ['BodyArmor', 'ClawGuards', 'TailGuard', 'Helmet'];
		var ret = 0;
		for (var i = 0; i < armors.length; i++) {
			if ( isEmpty(Seed.player.items[ dragon_type + armors[i] ],0) !== 0 ) {
				ret++;
			}
		}
		if (ret == 4) return true;
		else return false;
	},

	// if fetchcity is pending, will notify when complete, else notifies right away...
	updateNotifyQueue : [],
	notifyOnUpdate : function (notify) {
		consoleLog('updateNotifyQueue');
		var t = Seed;
		if (!RequestQueue.isPending('fetchCity')) {
			notify();
			return;
		}
		t.updateNotifyQueue.push (notify);
	},

	checkMarchStatus : function (march){
		var t = Seed;

		var m = cloneProps(march);

/*		if (m.status == 'returning'){
			m.last_status = m.status;
		}
	*/	
		m.target_name = m.destination_name  ? translate('City') +' '+ m.destination_name : translate(m.terrain_type);
		
		t.marches[m.id] = m;
	},

	checkAddJob : function (job){
		var t = Seed;
		var cityId = job.city_id;
		if (!job.run_at){
			WinLog.write ('checkAddJob job.run_at is null:\n'+ inspectObj (job, 5, 1));
			if (ALERT_ON_BAD_DATA){
				alert ('checkAddJob job.run_at is null');
			}
		}    
		
		if (!t.jobs[cityId]){
			t.jobs[cityId] = {};
		}
		if (job.queue == 'march'){
			if (!t.marches[job.march_id]){
				WinLog.write ('checkAddJob MISSING MARCH:\n'+ inspectObj (job, 5, 1) +'\n'+ inspectObj(t.marches, 5, 1));
				if (ALERT_ON_BAD_DATA){
					alert ('checkAddJob MISSING MARCH');
				}
				if (job.run_at < serverTime()){
					return;               // ?????? delete from Seed.jobs  ????
				}
			} 
			else {  
				t.marches[job.march_id].run_at = job.run_at;
				t.marches[job.march_id].duration = job.duration;
				t.marches[job.march_id].job_id = job.id;
			}
		} 
		
		if (job.queue == 'units'){
		}

		if (t.jobs[cityId][job.id]){
			return;
		}
		job.run_at += 2;      
		t.jobs[cityId][job.id] = cloneProps(job);
	},

	jsonAddJob : function (job){  // called from various jsons (buildUpgrade) when new job rx'd 
		var t = Seed;
		t.checkAddJob (job);
	},

	checkIncomingData : function (rslt){
		var t = Seed;
		// check seed for missing building ...      
		for (var ij=0; ij < rslt.dat.city.jobs.length; ij++)
		{
			var job = rslt.dat.city.jobs[ij];
			if (job.queue == 'building'){
				var building = null;
				for (var im=0; im < rslt.dat.city.buildings.length; im++)
				{
					if (rslt.dat.city.buildings[im].id == job.city_building_id){
						building = rslt.dat.city.buildings[im];
						break;
					}
				}
				if (!building){
					WinLog.writeText ('*********************** MISSING BUILDING! ('+ job.city_building_id +') now='+ serverTime() +'\n' + inspectObj (job, 7, 1) +'\n'+ inspectObj (rslt, 12, 1));
					if (ALERT_ON_BAD_DATA){
						alert ('Danger Will Robinson! (missing building)');
					}
				}
			}
		}
		
		if (!rslt.dat.city.marches){
			return;
		}
		// check seed for missing march ...  
		for (var ij=0; ij < rslt.dat.city.jobs.length; ij++)
		{
			var job = rslt.dat.city.jobs[ij];
			if (job.march_id){
				if (t.findMarch(job.march_id, rslt.dat.city.marches) == null){
					WinLog.writeText ('*********************** MISSING MARCH, Job ID:'+ job.march_id +' (now='+ serverTime() +')\n'+ inspectObj (job, 7, 1) +'\n'
					+ inspectObj (rslt, 12, 1));
					if (ALERT_ON_BAD_DATA){
						alert ('Danger Will Robinson! (missing march)');
					}
				}
			}
		}   
		// check seed for missing march job ...  
		for (var im=0; im < rslt.dat.city.marches.length; im++)
		{
			var march = rslt.dat.city.marches[im];
			var job = null;
			for (var ij=0; ij < rslt.dat.city.jobs.length; ij++)
			{
				if (rslt.dat.city.jobs[ij].march_id == march.id){
					job = rslt.dat.city.jobs[ij];
					break;
				}
			}
			if (job==null){
				WinLog.writeText ('*********************** MISSING JOB FOR MARCH!  marchId:'+ march.id +'\n'+ inspectObj (rslt, 11, 1));
				if (ALERT_ON_BAD_DATA){
					alert ('MISSING JOB FOR MARCH!');
				}
			}
		}
	},

	findMarch : function (mid, marches){
		for (var im=0; im < marches.length; im++){
			if (marches[im].id == mid){
				return marches[im];
			}
		}
		return null;
		}

};
//*********************************** Seed package *********************************************


// Jawz *********************************** simpleSoundPlayer package *********************************************
var simpleSoundPlayer = {
	sentinelAlertCount	: 0,
	oldAlertCount		: 0,
	alertString			: '',
	checkInterval		: null,

	init : function (){
		var t = simpleSoundPlayer;
		t.oldAlertCount = 0;
		if (Data.options.tower.enabled)
			t.checkInterval = setInterval (t.checkAlerts, 1000);
	},

	checkAlerts : function () {
		var t = simpleSoundPlayer;
		t.alertString = '';
		var attacks = 0;
		var spies = 0;
		t.oldAlertCount = t.sentinelAlertCount;
		if (Data.options.tower.enabled && Data.options.messages_tower.length != 0) {
			for (var i=0; i<Data.options.messages_tower.length; i++) {
				if (Data.options.messages_tower[i].type == 0) attacks++;
				if (Data.options.messages_tower[i].type == 1) spies++;
				if (Data.options.tower.nospy && attacks > 1) break;
				else if (!Data.options.tower.nospy && attacks > 1 && spies > 1) break;
			}
		}
		if (attacks + spies > 0) {
			t.sentinelAlertCount = attacks + spies;
			t.alertString += '<tr><td colspan=4 width=100%"><div class=' + UID['info_alerts'] + '>' + translate('Warning for ') + '<B>';
			if (attacks == 0) {
				if (spies > 1) t.alertString += translate('several spies');
				else t.alertString += translate('one spy');
			} else if (attacks > 1) {
				if (spies > 1)  t.alertString += translate('several spies') + translate('</B> and <B>') + translate('several attacks');
				else if (spies == 1)  t.alertString += translate('one spy') + translate('</B> and <B>') + translate('several attacks');
				else t.alertString += translate('several attacks');
			} else {
				if (spies > 1)  t.alertString += translate('several spies') + translate('</B> and <B>') + translate('one attack');
				else if (spies == 1)  t.alertString += translate('one spy') + translate('</B> and <B>') + translate('one attack');
				else t.alertString += translate('one attack');
			}
			t.alertString += '</B> ' + translate('in progress') + '</div></td></tr>';
		}
		if (Data.options.tower.play_sound && !Data.options.tower.alarm_active && t.sentinelAlertCount != t.oldAlertCount)
			t.soundTheAlert(Data.options.tower.repeat);
	},
	addPlayer : function (container, url) {
		var audio =	 '<object class="playerpreview" id="swfSoundPlayerObj" type="application/x-shockwave-flash" data="'+SWF_PLAYER_URL+'" width="0" height="0">'
					+'	<param name="movie" value="'+SWF_PLAYER_URL+'">'
					+'	<param name="AllowScriptAccess" value="always" />'
					+'	<param name="FlashVars" value="mp3='+url+'&amp;autoplay=1" />'
					+'</object>';
		if (container) document.getElementById(container).innerHTML = audio;
	},
	removePlayer : function (container) {
		if (container) document.getElementById(container).innerHTML = "";
	},
	soundTheAlert : function (doRepeats){
		var t = simpleSoundPlayer;
		Data.options.tower.alarm_active = true;
		clearTimeout (soundStopTimer);
		clearTimeout (soundRepeatTimer);
		t.addPlayer(UID['jawz_SwfPlyr'], Data.options.tower.sound_url);
		soundStopTimer = setTimeout (t.stopSoundAlerts, Data.options.tower.play_length*1000);
		if (doRepeats && Data.options.tower.repeat)
			soundRepeatTimer = setTimeout (function (){t.soundTheAlert(true)}, Data.options.tower.repeat_delay*60000);
	},
	stopSoundAlerts : function (){
		var t = simpleSoundPlayer;
		t.removePlayer(UID['jawz_SwfPlyr']);
		clearTimeout (soundStopTimer);
		Data.options.tower.alarm_active = false;
	},
}
// Jawz *********************************** simpleSoundPlayer package *********************************************


//*********************************** Translation package *********************************************
var Translation = {
	loaded : false,
	xml		 : {},
	available_langs : [ {code:'de', desc:'German' },
						{code:'en', desc:'English' },
						{code:'es', desc:'Spanish' },
						{code:'fr', desc:'French' },
						{code:'nl', desc:'Dutch' },
						{code:'sv', desc:'Swedish' },
						{code:'tr', desc:'Trukish' } ],
	
	/* WARNING: DON'T CHANGE THIS ORDER */
	_section : [
		'items',
		'common',
		'buildings',
		'messages',
		'dialogs',
		'levels',
		'troops',
		'map',
		'research',
		'quests'    // Jawz
	],
	
	init : function (notify) {
		var t = Translation;
		t.fetchLocale(function (rslt) {
			if (rslt.ok) {
				verboseLog(translate('Locale data was Successfully requested from the sever'));
				t.loaded = true;
				t.fixResults();
			} else {
				verboseLog('fetchLocale ' + translate('was returned with a status of') + ' ' + rslt.ok + ' - ' + rslt.errmsg);
			}
			if (notify){
				notify(rslt);
			}
		});
	},

	fetchLocale : function (notify) {
		var t = Translation;
		new MyAjaxRequest ('locales/' + C.attrs.locale + '.xml', {'_swf_session_id':C.attrs.sessionId}, function (rslt) {
			if (rslt.ok) {
				try {
					t.parseXML(rslt.dat);
					
				} catch (e) {
					rslt.ok = false;
					rslt.errmsg = e.toString();
				}
			} 
			else if (rslt.errmsg.indexOf('404') !== -1) {
				new MyAjaxRequest('locales/en.xml', {'%5Fswf%5Fsession%5Fid':C.attrs.sessionId}, function (rslt) {
					if (rslt.ok) {
						try {
						
							t.parseXML(rslt.dat);
							
						} catch (e) {
							rslt.ok = false;
							rslt.errmsg = e.toString();
						}
					}
					if (notify) {
						notify(rslt);
					}
				});
			}
			if (notify){
				notify(rslt);
			}
		});
	},
	
	parseXML : function(xmlStr){
		var t = Translation;
		var XMLString = [];

		// Jawz - Remove <dragons> XML tree
		var start = xmlStr.indexOf('<dragons>');
		var end = xmlStr.indexOf('</dragons>') + 10;
		xmlStr = xmlStr.substring(1, start) + xmlStr.substring(end);
		// End Jawz
		XMLString.push('<?xml version="1.0" encoding="UTF-8"?>');
		XMLString.push('<translations>');
		for (i=0; i < t._section.length; ++i){
			var start = xmlStr.indexOf('<'+t._section[i]+'>');
			var end = xmlStr.indexOf('</'+t._section[i]+'>') + t._section[i].length + 3;
			XMLString.push(xmlStr.substring(start, end));
			xmlStr = xmlStr.substring(1, start) + xmlStr.substring(end);
		}
		XMLString.push('</translations>');
		//logit('Traductions : '+inspectObj(XMLString));
					
		XmlTree = new XML.ObjTree();
		t.xml = XmlTree.parseXML( XMLString.join('').replace(/\n/g,'') );

		if (t.xml.translations){
			t.xml = t.xml.translations;
		} else {
			verboseLog('Error in the XML file structure: <translations> element not found!');
		}
	},
	
	fixResults : function(){
		var t = Translation.xml;

		function objectToFlat (obj) {
			var r={};
			for (var key in obj) {
				if (typeof obj[key] === 'object') {
					for (var subkey in obj[key]) {
						if (typeof (obj[key])[subkey] === 'object' ) {
							for (var subsubkey in (obj[key])[subkey]) {
								if (subsubkey === 'title' || subsubkey === 'name') {
									r[key+'-'+subkey] = ((obj[key])[subkey])[subsubkey];
								} else {
									r[key+'-'+subkey+'-'+subsubkey] = ((obj[key])[subkey])[subsubkey];
								}
							}
						} else {
							if (subkey === 'title' || subkey === 'name') {
								r[key] = (obj[key])[subkey];
							} else {
								r[key+'-'+subkey] = (obj[key])[subkey];
							}
						}
					}
				} else {
					r[key] = obj[key];
				}
			}
			return r;
		}

		var section = ['dialogs','messages'];//,'errors','confirmations'
		for ( var i=0; i < section.length; i++ ) {
			t[section[i]] = objectToFlat(t[section[i]]);
		}

		// Jawz
		var newObjQuests={};
		for(var key in t.quests){
			if(typeof t.quests[key] == 'object'){
				for (var subkey in t.quests[key]){
					switch (subkey) {
						case 'title' : newObjQuests[key] = (t.quests[key])[subkey]; break;
						case 'objectives' : newObjQuests[key+'-'+subkey] = (t.quests[key])[subkey]; break;
						default : break;
					}
				}
			} else {
				newObjQuests[key] = t.quests[key];
			}
		}
		Translation.xml['quests'] = cloneProps(newObjQuests);
		// End Jawz

		t.common.information = t.common.info;
		t.common.omit = t.common.skip;
		t.common['spy-on'] = t.common.spy;
		t.dialogs.researching = t.dialogs.research;

		t.common['enter-coords'] = t.dialogs['attack-screen-enter-coords'];
		t.common['battle-report'] = t.messages['battle-report-title'];
		t.common['auto-collection-of-resources'] = t.dialogs['boost-collect-day'].replace(/:/,'');

		t.common.levels = findSimilarWord(t.common.level, t.messages['spy-tip-prefix']);
		
		delete t.common.error;
		delete t.common.home;
		delete t.common.info;
		delete t.common['ranged-attack'];
		delete t.common.skip;
		delete t.common.spy;
		delete t.messages.date;
		delete t.messages.fought;
		delete t.messages.subject;
		delete t.messages.to;
		delete t.dialogs.research;
		delete t.dialogs.spy;
		delete t.dialogs.unavailable;
		delete t.dialogs.upkeep;
	},
	
	_normalize : function (str){
		return (str || '').toLowerCase().replace(/ /g,'-');
	},
	
	getContent : function(section,key,subkey){
		key = Translation._normalize(key);
		if(Translation.xml[section] != undefined) {
			if( (Translation.xml[section])[key] != undefined ) {
				return subkey ? ((Translation.xml[section])[key])[subkey] : (Translation.xml[section])[key];
			}
		}
		return false;
	},
	
	buildings : function(key,subkey){
		subkey = subkey != undefined ? subkey : 'name';
		return Translation.getContent('buildings',key,subkey);
	},
	
	common : function(key){
		return Translation.getContent('common',key);
	},
	
	items : function(key,subkey){
		subkey = subkey != undefined ? subkey : 'name';
		return Translation.getContent('items',key,subkey);
	},
	
	dialogs : function(key){
		return Translation.getContent('dialogs',key);
	},
	
	levels : function(key){
		return Translation.getContent('levels',key,'title');
	},
	
	map : function(key,subkey){
		subkey = subkey != undefined ? subkey : 'name';
		return Translation.getContent('map',key,subkey);
	},
	
	messages : function(key){
		return Translation.getContent('messages',key);
	},
	
	troops :  function(key,subkey){
		subkey = subkey != undefined ? subkey : 'name';
		return Translation.getContent('troops',key,subkey);
	},
	
	research :  function(key,subkey){
		subkey = subkey != undefined ? subkey : 'name';
		return Translation.getContent('research',key,subkey);
	},

	quests :  function(key,subkey){
		subkey = subkey != undefined ? subkey : 'name';
		return Translation.getContent('quests',key,subkey);
	},
};
//*********************************** Translation package *********************************************


// Provide language translation services based on the browswer language
var needTranslate = {};
function translate( str ) {
	if ( TRANSLATION_ARRAY[str] != undefined ) {
		return TRANSLATION_ARRAY[str];
	}
	else if ( Translation.loaded ){
		var newStr;
		for (var i=0; i < Translation._section.length; ++i){
			newStr = Translation[Translation._section[i]](str);
			if (newStr){
				return newStr;
			}
		}
		if (IS_NOT_NATIVE_LANG && needTranslate[str] == undefined) {
			needTranslate[str] = 1;
			if(Tabs.Log){
				logit( '( Translate ) -> ' + str );
			}
		}
	}
	return str;
}
// Jawz
function translateByKey( str, key ) {
	if ( TRANSLATION_ARRAY[str] != undefined ) {
		return TRANSLATION_ARRAY[str];
	}
	else if ( Translation.loaded ){
		var newStr;
		for (var i=0; i < Translation._section.length; ++i){
			newStr = Translation[Translation._section[i]](key);
			if (newStr){
				return newStr;
			}
		}
		if (IS_NOT_NATIVE_LANG && needTranslate[str] == undefined) {
			needTranslate[str] = 1;
			if(Tabs.Log){
				logit( '( Translate ) -> ' + str );
			}
		}
	}
	return str;
}
// End Jawz


//*********************************** VerboseLog package *********************************************
var VerboseLog = {
	init : function () {
		var t = VerboseLog;
		t.setEnable(Data.options.verboseLog.enabled);
	},
	
	setEnable : function (onOff) {
		var t = VerboseLog;
		Data.options.verboseLog.enabled = onOff;
	}
};
//*********************************** VerboseLog package *********************************************


//****************
// Functions
//****************
function objAddTo (o, name, val){
	if (!o[name]){
		o[name] = val;
	} else {
		o[name] += val;
	}
}
function generalList (cityIdx){
	var ret = {};
	var generals = Seed.cities[cityIdx].generals;
	for (var i=0; i < generals.length; i++){
		ret[generals[i].id] = generals[i].name +' ('+ generals[i].rank +')';
	}
	return ret;
}
function getTroopNumbers (cityIdx, troopType) {
	var city = (typeof cityIdx == 'number') ? Seed.cities[cityIdx] : cityIdx;
	var incity = city.units[troopType] ? city.units[troopType] : 0;
	var marches = 0;
	for (var march in Seed.marches){
		for (var name in Seed.marches[march].units){
			if (troopType == name){
				marches += Seed.marches[march].units[name];
			}
		}
	}
	return {incity:incity, marches:marches, total:incity+marches};
}
function getAvailableGeneral (){
	for (var p in Seed.generals){
		if (!Seed.generals[p].busy){
			return Seed.generals[p];
		}
	}
	return null;
}
function getMusterPointMaxTroops(cityIdx){
	if (!Seed.cities[cityIdx].figures.marches.maximum_troops || Seed.cities[cityIdx].figures.marches.maximum_troops == undefined) {
		var lvl = (Buildings.getLevel (cityIdx, kMusterPoint)).max;
		if (!lvl) return 0;
		else
			switch (lvl) {
				case 11 : var maxLvl = 120000; break;
				case 12 : var maxLvl = 140000; break;
				case 13 : var maxLvl = 160000; break;
				default : var maxLvl = lvl * 10000;
			}
	} else var maxLvl = Seed.cities[cityIdx].figures.marches.maximum_troops;
	return maxLvl;
}
function getMusterPointSlots (cityIdx){
	var lvl = (Buildings.getLevel (cityIdx, kMusterPoint)).max;
	if (!lvl){
		return 0;
	}
	return lvl - Seed.numMarches;
}
function getMusterPointLevel (cityIdx){
	var lvl = (Buildings.getLevel (cityIdx, kMusterPoint)).max;
	return (!lvl) ? 0 : lvl;
}
function getBuildingJob (cityIdx){
	var cid = Seed.cities[cityIdx].id;
	for (var p in Seed.jobs[cid]){
		var job = Seed.jobs[cid][p];
		if (job.queue == 'building'){
			return ({job:job, building:Buildings.getById(cityIdx, job.city_building_id)});
		}
	}
	return null;
}
function getResearchJob (cityIdx){
	var cid = Seed.cities[cityIdx].id;
	for (var p in Seed.jobs[cid]){
		var job = Seed.jobs[cid][p];
		if (job.queue == 'research'){
			return (job);
		}
	}
	return null;
}
function getBuildingById (cityIdx, bId){
	var b = Seed.cities[cityIdx].buildings;
	for (var i=0; i<b.length;i++){
		if (b[i].id == bId){
			return b[i].type;
		}
	}
	return '';
}
function MarchTracker (){
	var marches = {};

	function MarchTracker (){
	}

	this.setReportDelete = function (onOff){
	}
	this.setTroopLossListener = function (listener){
	} 
}
function deleteResearchJob(job){
	var cid = Seed.cities[CAPITAL_ID].id;
	var jobs = Seed.jobs[cid];
	for (var p in jobs){
		if (jobs[p] == job){
			delete jobs[p];
		}
	} 
}
function deleteBuildJob(cityIdx, job){
	var cid = Seed.cities[cityIdx].id;
	var jobs = Seed.jobs[cid];
	for (var p in jobs){
		if (jobs[p] == job){
			delete jobs[p];
		}
	} 
}
function getBuildJob (cityIdx){
	var cid = Seed.cities[cityIdx].id;
	var jobs = Seed.jobs[cid];
	for (var p in jobs){
		if (jobs[p].queue == 'building'){
			return jobs[p];
		}
	}
	return null;
}
function getTrainJob (cityIdx){
	var cid = Seed.cities[cityIdx].id;
	var jobs = Seed.jobs[cid];
	for (var p in jobs){
		if (jobs[p].queue == 'units'){
			return jobs[p];
		}
	}
	return null;
}
// Jawz
function getTotTrainTable (){
	var now  = serverTime();
	var totalTrain = [];
	for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx) {
		var time = 0;
		if (Seed.cities[cityIdx] && Seed.cities[cityIdx].jobs) {
			var jobs = Seed.cities[cityIdx].jobs;
			var trains = [];
			for (var j=0; j < jobs.length; j++)
				if (jobs[j].queue=='units' && jobs[j].unit_type && jobs[j].run_at > now) trains.push (jobs[j]);
			if (trains.length > 0) {
				trains.sort( function(a,b){ return a.run_at - b.run_at; } );
				var time = trains[trains.length-1].run_at - now;
			}
		}
		if (Seed.cities[cityIdx])
			totalTrain.push ({cityIdx:cityIdx, total:time});
	}
	totalTrain.sort(function(a,b){return a.total-b.total});
	return totalTrain;
}
function getAvailableDragon (exceptions) {
	var found = false;
	for (var gd=0; gd < Seed.dragonList.length && !found; gd++) {
		var dragon		= Seed.dragons[Seed.dragonList[gd].type];
		var curName		= dragon.name;
		var isInCity	= dragon.is_in_city;
		var canAttack	= dragon.can_attack;
		var curLife		= dragon.life;
		var maxLife		= dragon.maximum_life;
		var excluded	= false;
		if (exceptions)	excluded = exceptions[Seed.dragonList[gd].type];
		if (((curLife / maxLife) >= 0.75) && isInCity && canAttack && !excluded) {
			found = true;
		}
	}
	if (found)
		return curName;
	else
		return null;
}
function getDragonJob (cityIdx){
  var cid = Seed.cities[cityIdx].id;
  for (var p in Seed.jobs[cid]){
    var job = Seed.jobs[cid][p];
    if (job.queue == 'dragon')
      return (job);
  }
  return null;
}
function getResurrectionJob (cityIdx){
	var cid = Seed.cities[cityIdx].id;
	var jobs = Seed.jobs[cid];
	for (var p in jobs){
		if (jobs[p].queue == 'resurrection'){
			return jobs[p];
		}
	}
	return null;
}function getOutpostJob (cityIdx){
  var cid = Seed.cities[cityIdx].id;
  for (var p in Seed.jobs[cid]){
    var job = Seed.jobs[cid][p];
    if (job.queue == 'outpost')
      return (job);
  }
  return null;
}
// End Jawz
function trainTable (myId, resurrect){
	var m = '<table class=' + UID['table'] + ' width=100%>';  // Jawz - added width
	var now = serverTime();
	var mtClass = '' + UID['row_marchMine'];
	for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx)
	{
		if (Seed.cities[cityIdx] && Seed.cities[cityIdx].jobs && ((cityIdx != SPECTRAL_OUTPOST_ID && !resurrect) || (cityIdx == SPECTRAL_OUTPOST_ID && resurrect)) ) {
			var jobs = Seed.cities[cityIdx].jobs;
			// Jawz
			var last = serverTime();
			var trains = [];
			m += '<tr class='+ mtClass +'><td align=left width=20%><b>'+ ( (cityIdx == SPECTRAL_OUTPOST_ID) ? translate(Seed.cities[cityIdx].name) : Seed.cities[cityIdx].name ) +'</b></TD>';
			for (var j=0; j < jobs.length; j++) {
				if (jobs[j].queue=='units' && jobs[j].unit_type && jobs[j].run_at > last && !resurrect) trains.push (jobs[j]);
				if (jobs[j].queue=='resurrection' && jobs[j].unit_type && jobs[j].run_at > last && resurrect) trains.push (jobs[j]);
			}
			if (trains.length == 0)
				m += '<td>' + translate('Idle') + '</td></tr>';
			else {
				trains.sort( function(a,b){ return a.run_at - b.run_at; } );
				// End Jawz
				for (var j=0; j < trains.length; j++)  // Jawz - replaced jobs by trains
				{
					var time_remaining = (trains[j].run_at-last > 0) ? trains[j].run_at-last : 0;
					var left='<tr class='+ mtClass +'><td> &nbsp </td>', tot='';
					if (j==0) left = ' ';
					else if (j==trains.length-1)
						tot = ' &nbsp <B>('+ timestrShort((trains[j].run_at-serverTime() > 0) ? trains[j].run_at-serverTime() : 0) +')</b>';
					m += left + '<TD width=40%>' + nombreFormate(trains[j].quantity,' ') +' '+ translate(trains[j].unit_type) +' </td>'
					+'<td width=40%><font color=' + TIMER_COLOR + '>' + timestr(time_remaining,true) + '</font>' + tot +'</td></tr>';
					last = trains[j].run_at;
				}   
			}
			m += '<tr><td colspan=3>&nbsp</td></tr>';
		}
	}
	return m + '</table>';
}

//******************************** Info Tab *****************************
Tabs.Info = {
	tabOrder		: INFO_TAB_ORDER,
	tabLabel		: 'Info',
	tabDisabled		: !INFO_TAB_ENABLE,
	container		: null,
	timer			: null,
	contentType		: 0, // 0 = overview, 1 = inventory, 2 = quests
	infoScrollPos	: 0,
	lastSubTab		: 'tabInfoOverview',

	init : function (div){
		var t = Tabs.Info;

		// Jawz - Purge completed & claimed quests
		for (var i=0; i<Seed.quests.category.length; i++) {
			for (var j=0; j<Seed.quests.list[Seed.quests.category[i]].length; j++) {
				var quest		= Seed.quests.list[Seed.quests.category[i]][j];
				var claimed = false;
				if (Seed.player.quests.claimed) {
					for (var x=0; x<Seed.player.quests.claimed.length && !claimed; x++) {
						if (name == Seed.player.quests.claimed[x]) claimed = true;
					}
				}
				if (claimed) {
					Seed.quests.list[Seed.quests.category[i]].splice(j,1);
				}
			}
		}
		// End Jawz

		t.container = div;
		div.innerHTML = '<div class=' + UID['title'] + '>'+ scriptName + '&nbsp; -&nbsp;v' + scriptVersion + '</div>'
		// Jawz
		+'<div class=' + UID['title_main'] + '>'
		+'<table width=80% align=center>'
		+'	<tr align=center><td width="100px"><a id='+ setUID('tabInfo_ScriptUpdate') +' style="color:#FFFFFF;text-decoration:none;">'+ translate('Version update') +'</a></td>'
		+'		<td width="100px"><a href="'+ Data.options.wikiUrl + '" target="_blank" style="color:#FFFFFF;text-decoration:none;">'+ kWikiLink +'</a></td>'
		+'		<td width="100px"><a href="'+ Data.options.forumUrl + '" target="_blank" style="color:#FFFFFF;text-decoration:none;">'+ kForumLink +'</a></td>'
		+'</tr></table></div>'
		// End Jawz
		+'<table width=100%><tr>'
		+'	<td width=33%><input id='+ setUID('tabInfo_Refresh') +' type=button value='+ translate('Refresh') +'></input></td>'
		+'	<td width=33% align=center>' + ((REALM_URL == null || REALM_URL == '' || !REALM_URL) ? '' : '<input id='+ setUID('tabInfo_Reload') +' type=button value="'+ translate('Reload') +'"></input>') + '</td>' // Jawz
		+'	<td width=33% align=right><SPAN id='+ setUID('tabInfo_Time') +'></span></td>'
		+'</tr></table>'
		// Jawz
		+'<ul class=tabs>'
		+'	<li class="tab first"><a id='+ setUID('tabInfoOverview') +'>'+ translate('Overview') +'</a></li>'
		+'	<li class=tab><a id='+ setUID('tabInfoInventory') +'>'+ translate('Inventory') +'</a></li>'
		+'	<li class=tab><a id='+ setUID('tabInfoQuests') +'>'+ translate('Quests') +'</a></li>'
		+'</ul>'
		// End Jawz
		+'<div id='+ setUID('tabInfo_Content') +' class="' + UID['scrollable'] + '" style="margin-top:1px !important; height:650px; max-height:650px;"></div>';  // Jawz - Added styles
		document.getElementById(UID['tabInfo_Refresh']).addEventListener ('click', t.refresh, false);
		// Jawz
		document.getElementById(UID['tabInfo_Reload']).addEventListener ('click', reloadTools, false);
		document.getElementById(UID['tabInfoOverview']).addEventListener ('click', t.tabInfoOverview, false);
		document.getElementById(UID['tabInfo_ScriptUpdate']).addEventListener ('click', AutoUpdater.manualCheck, false);
		document.getElementById(UID['tabInfoInventory']).addEventListener ('click', t.tabInfoInventory, false);	
		document.getElementById(UID['tabInfoQuests']).addEventListener ('click', t.tabInfoQuests, false);	
		t.contentType = Data.options.info.current_tab;
		t.show();
		// End Jawz
	},
	show : function (){
		var t = Tabs.Info;
		switch (isEmpty(t.contentType, 0)) {
			case 0: t.tabInfoOverview(); break;
			case 1: t.tabInfoInventory(); break;
			case 2: t.tabInfoQuests(); break;
		}
		// End Jawz
	},
	hide : function (){
		var t = Tabs.Info;
		clearTimeout (t.timer);
	},
	// Jawz
	onUnload : function (){
		var t = Tabs.Info;
		logit ('===============  Tabs.Info.onUnload');
		Data.options.info.current_tab = t.contentType;
		if (t.clockTimer) clearInterval (t.clockTimer);    // Jawz - reactivated
	},
	showClock : function (){
		var t = Tabs.Info;
		var now = new Date();
		now.setTime(now.getTime() + ((Data.options.utc_time) ? (now.getTimezoneOffset()*60000) : 0));
		document.getElementById(UID['tabInfo_Time']).innerHTML = '<b>' + now.toTimeString().substring (0,8) +'</b>'+((Data.options.utc_time) ? ' UTC' : '');
	},
	// End Jawz

	// showStuff : function (){     // Jawz
	tabInfoOverview : function (){  // Jawz
		var t = Tabs.Info;
		//logit (inspectObj (Seed.s, 8, 1));
		clearTimeout (t.timer);    // Jawz - reactivated

		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabInfoOverview']).className='selected';
		document.getElementById(UID['tabInfoOverview']).style.zIndex=1;
		t.lastSubTab = 'tabInfoOverview';
		t.contentType = 0;
		Data.options.info.current_tab = t.contentType;
		
		var city = Seed.cities[CAPITAL_ID];
		//var m = cityTitle(0);                              // Jawz
		var m = '<div class=' + UID['status_ticker'] + '>';  // Jawz - Added border
		var alliance_name = (Seed.player.alliance) ? Seed.player.alliance.name : '';
		var wallStatus = translate((Seed.cities[CAPITAL_ID].defended) ? 'Defend' : 'Hiding').toUpperCase();
		m += '<div class=' + UID['subtitle'] + '><table class=' + UID['table'] + '>'
			+'<tr><td align=left width=35%>'+ city.name +'</td>'
			+'<td align=center width=30%>'+ city.x +','+ city.y + '</td>'
			+'<td align=center width=200px><font color=yellow>' + alliance_name +'</font></td>'
			+'<TD width=35% align=right><input id='+ setUID('tabInfo_setDefense') +' type=button value='+ wallStatus +' class=' + UID[(Seed.cities[CAPITAL_ID].defended ? 'btn_off' : 'btn_on')] + '></input></td>'
			+'</tr></table></div>';

		m += dispCurrRessources(CAPITAL_ID);
		m += '<table style="margin-top:3px" width=100%>'
		+'	<tr class=' + UID['row_headers'] + ' align=center>'
		+'		<td width=60%>'+ translate('Troops').toUpperCase() +'</td>'   // Jawz - Changed for translation & added width=60%
		+'		<td width=40%>'+ translate('Generals').toUpperCase() +'</td>' // Jawz - Added width=40%
		+'	</tr>'
		+'	<tr valign=top align=center>'
		+'		<td width=60% style="border-right: 1px solid;">'; // Jawz - Set width to 60%

		// Troops
		m += '		<table class=' + UID['table'] + '>';
		for (var i=0; i < all_unit_types.length; i++){
			var numTroops = getTroopNumbers(city, all_unit_types[i]);
			
			m += '		<tr>'
			+'				<td class=right width=50%>'+ translate(all_unit_types[i]) +':</td>' // Jawz - replaced class=left by right & added width
			+'				<td align=right width=24%>'+ nombreFormate(numTroops.incity,' ') +'</td>'  // Jawz - Added number formating & added width
			+'				<td align=right width=26%>'+ (numTroops.marches?'&nbsp;+&nbsp;<b>' + nombreFormate(numTroops.marches,' ') + '</b>':'') +'</td>'  // Jawz - Added number formating, removed ( ) & added width
			+'			</tr>';
		}
		
		m += '		</table>'
		+'		</td>'
		+'		<td width=40% style=" padding-left:7px">'; // Jawz - Set width to 40%
		
		// Generals
		m += '		<table class=' + UID['table'] + '>';
		
		var loc = '';
		for (var i=0; i < city.generals.length; i++)
		{
			var font2 = 'jewel';
			if (Seed.marches){
			//if (Seed.numMarches){
				for (var pm in Seed.marches) {
					// The general object will be null if the march is a transport
					if (Seed.marches[pm].march_type != "TransportMarch" && Seed.marches[pm].march_type != "SpyMarch") {  // Jawz - Added spy march type
						try {
							if (city.generals[i].name == Seed.marches[pm].general.first_name) {
								loc = Seed.marches[pm].x + ',' + Seed.marches[pm].y;
								if (Seed.marches[pm].status == 'encamped') className = 'bluejwl';
								else className = 'jewel';
							}
						}
						catch (e) {
							actionLog(translate('Error') + ': '+ 'general first_name not available' + e.name + ' ' + e.message);
						}
					}
				}
			}
			
			m += '		<tr>'
			+'			<td width=50% align=right>'+ city.generals[i].name +' ('+ city.generals[i].rank +')</td>'       // Jawz - Added width
			+'			<td width=50%>'+ (city.generals[i].busy ? '<span class="'+className+'">[' + loc +']</span>' :'') +'</td>' // Jawz - Set width to 50% instead of 75%
			+'			</tr>';
		}
		m +='	<tr class=' + UID['row_headers'] + ' align=center width=100%>'
		+'		<td colspan=2 width=100%>'+ translate('Great dragons').capitalize() +'</td>' // Jawz - Added width=40%
		+'		</tr>';
		for (var gd=0; gd < Seed.dragonList.length; gd++) {
			var dragon = Seed.dragons[Seed.dragonList[gd].type];
			var dragStatus = '';
			if (((dragon.life / dragon.maximum_life) >= 0.75) && dragon.is_in_city && dragon.can_attack) dragStatus = translate ('Ready');
			else if (!dragon.is_in_city && dragon.can_attack) dragStatus = translate ('Attacking');
			else if (!dragon.can_attack) dragStatus = translate ('Not ready');
			else if ((dragon.life / dragon.maximum_life) < 0.75) dragStatus = translate ('Healing');
			else dragStatus = translate ('Not ready');
			m += '		<tr>'
			+'			<td width=50% align=right>'+ translate(dragon.name) +'</td>'
			+'			<td width=50%><span class=jewel>' + dragStatus +'</span></td>'
			+'			</tr>';
		}

		m += '		</table>'
		+'		</td>'
		+'		</tr>'
		+'</table>'
		+'<br>'
		+'<table class=' + UID['table'] + '>' + dispProtection() + simpleSoundPlayer.alertString // Jawz - Added protection status + alert status
		+'	<tr>'
		+'		<td class=right width=20%>'+ translate('Marching') +': </td>'  // Jawz - Added width & replaced class=left by right
		+'		<td width=30%>'+ Seed.numMarches +'</td>'  // Jawz - Added width
		+'		<td class=right width=20%>'+ translate('Wildernesses') +': </td>'  // Jawz - Added wildernesses count & replaced class=left by right
		+'		<td width=30%>'+ dispWildsCount() +'</td>'  // Jawz - Added wildernesses count
		+'	</tr>'
		+ dispDragonJob(CAPITAL_ID)     // Jawz
		+ dispOutpostJob(CAPITAL_ID)    // Jawz
		+ dispBuildingJob(CAPITAL_ID)   // Jawz
		+ dispResearchJob(CAPITAL_ID)   // Jawz
		+ dispTrainingJobs(CAPITAL_ID)  // Jawz
		+'</table>'
		+'</div>'; // End Jawz - Added border

		// Jawz - Added outposts
		// Outposts ...
		if (Seed.cities.length > 0){
			for (var cityIdx=1; cityIdx < Seed.cities.length; ++cityIdx){
				if (Seed.cities[cityIdx]) {
					m += '<div class=' + UID['status_ticker'] + ' style="margin-top:6px !important">'
					+ t.cityTitle(cityIdx)
					+'<table class=' + UID['table'] + ' width=100%>'
					+ dispDragonJob(cityIdx)
					+ dispOutpostJob(cityIdx)
					+ dispBuildingJob(cityIdx) 
					+ dispTrainingJobs(cityIdx)
					+ dispResurrectionJobs(cityIdx)
					+'</table>'
					+'</div>';
				}
			}
		}
		m += '<br>';
		// End Jawz - Added outposts
	
		// Marches, building, research, training
		document.getElementById(UID['tabInfo_Content']).innerHTML = m;
		document.getElementById(UID['tabInfo_Content']).scrollTop = t.infoScrollPos;                 // Jawz
		document.getElementById(UID['tabInfo_Content']).addEventListener('scroll', onScroll, false); // Jawz
		document.getElementById(UID['tabInfo_setDefense']).addEventListener ('click', switchDefense, false);
		t.showClock();
		// Jawz
		t.timer = setTimeout (t.show, 1000);

		function onScroll (e){
			if (t.contentType == 0)
				t.infoScrollPos = document.getElementById(UID['tabInfo_Content']).scrollTop;
		}

		// Jawz - Display current resources
		function dispCurrRessources (cityIdx){
			var m = '<table style="margin-top:3px" width=100%>'
				+'	<tr class=' + UID['row_headers'] + ' align=center>'
				+'		<td width=20%>' + translate('Type') + '</td>'
				+'		<td width=20%>' + translate('Reserves') + '</td>'
				+'		<td width=15%>' + translate('Per Hour') + '</td>'
				+'		<td width=20%>' + translate('Consumption') + '</td>'
				+'		<td width=25%>' + translate('Capacity') + '</td>'
				+'	</tr>';

			for (var p=0; p<all_resource_types.length; p++){
				var production = Seed.cities[cityIdx].figures.resource_rates[all_resource_types[p]];
				var actualStock = nombreFormate(parseInt(Seed.cities[cityIdx].resources[all_resource_types[p]]));
				m += '	<tr valign=top align=center>'
					+'		<td align=right class=jewel>' + translate(all_resource_types[p]) + '</td>'
					+'		<td align=right class=jewel>' + actualStock + '</td>'
					+'		<td align=right class=jewel>' + nombreFormate(parseInt(production.rate)) + '</td>'
					+'		<td align=right class=jewel>' + nombreFormate(parseInt(production.unit_consumption || production.general_salaries || 0)) + '</td>'
					+'		<td align=right class=jewel>' +	( production.capacity === 1E+18 ? translate('Unlimited') : nombreFormate(production.capacity) ) + '</td>'
					+'	</tr>';
			}
			m += '</table>';
			return m;
		}
		// Jawz - Display dragon healing jobs

		// Jawz - Display protection status
		function dispProtection (){
			var m = '';
			if (Seed.cities[CAPITAL_ID].protected){
				var expir = timestr(Seed.player.boosts.safety - serverTime(), true);
				m += '<tr><td width=100% colspan=4><div class=' + UID['info_protect'] + '>Protection : '+ expir +'</div></td></tr>';
			}
			return m;
		}
		// Jawz - Display wildernesses count
		function dispWildsCount (){
			var max = isEmpty(Seed.player.max_wildernesses, 0);
			var cur = isEmpty(Seed.player.player_wildernesses.length, 0);
			var m = (cur < max) ? '<span class=' + UID['bold_red'] + '>'+ cur +'</span>' : cur;
			m += ' / ' + max;
			return m;
		}
		// Jawz - Display dragon healing jobs
		function dispDragonJob (cityIdx){
			var m = '';
			var job = getDragonJob (cityIdx);
			if (job && job.run_at > serverTime()) {
				m += '<tr><td class=right width=20%>' + translate('Healing') + ':</td>'
				  +'	<td width=50% colspan=2><span class=' + UID['bold_red'] + '>'+ translate ('Dragon healing') + '</span></td>'
				  +'	<td width=30%><font color=' + TIMER_COLOR + '>'+ timestr(job.run_at - serverTime(), true) +'</font></td></tr>';
			}
			return m;
		}
		// Jawz - Display outpost repairing jobs
		function dispOutpostJob (cityIdx){
			var m = '';
			var job = getOutpostJob (cityIdx);
			if (job && job.run_at > serverTime()) {
				m += '<tr><td class=right width=20%>' + translate('Repairing') + ':</td>'
				  +'	<td width=50% colspan=2><span class=' + UID['bold_red'] + '>'+ translate ('Outpost damages') + '</span></td>'
				  +'	<td width=30%><font color=' + TIMER_COLOR + '>'+ timestr(job.run_at - serverTime(), true) +'</font></td></tr>';
			}
			return m;
		}
		// Jawz - Display build queue
		function dispBuildingJob (cityIdx){
			var m = '<tr><td width=20% class=right>'+ translate('Building') +': </td>';
			var job = getBuildingJob (cityIdx);
			if (job && job.job.run_at > serverTime())
			{
				m += '<td width=50% align=left colspan=2>'+ translate(job.building.type) +' ('+ job.job.level +') &nbsp;</td>'
				  + '<td width=30%><font color=' + TIMER_COLOR + '>' + timestr(job.job.run_at - serverTime(), true) + '</font></td>'
				  + '</tr>';
			} else {
				m += '<td align=left width=80% colspan=3><span class=' + UID['bold_red'] + '>' + translate('None').toUpperCase() + '</span></td></tr>';
			}
			return m;
		}
		// Jawz - Display research queue
		function dispResearchJob (cityIdx){
			var m = '<tr>'
				+ '		<td class=right width=20%>'+ translate('Researching') +': </td>';
			var job = getResearchJob (cityIdx);
			if (job && job.run_at > serverTime())
			{
				m += '<td width=50% align=left colspan=2>'+ translate(job.research_type) +' ('+ job.level +') &nbsp;</td>'
				  + '<td width=30%><font color=' + TIMER_COLOR + '>' + timestr(job.run_at - serverTime(), true) + '</font></td>'
				  +'</tr>';
			} else {
				m += '<td align=left width=80% colspan=3><span class=' + UID['bold_red'] + '>' + translate('None').toUpperCase() + '</span></td></tr>';
			}
			return m;
		}
		// Jawz - Display training queues
		function dispTrainingJobs (cityIdx){
			var m = '', last = serverTime(), trains = [];
			for (var i=0; i < Seed.cities[cityIdx].jobs.length; i++){
				if (Seed.cities[cityIdx].jobs[i].queue=='units' && 
					Seed.cities[cityIdx].jobs[i].unit_type && 
					Seed.cities[cityIdx].jobs[i].run_at > last
					){
						trains.push (Seed.cities[cityIdx].jobs[i]);
				}
			}
			trains.sort(function(a,b){return a.run_at-b.run_at});
			for (var i=0; i < trains.length; i++){
				var left='', tot='', timeRemaining = 0;
				if (i==0){
					left = translate('Training') + ':';
				}
				else if (i==trains.length-1) {
					timeRemaining = (trains[i].run_at-serverTime() > 0) ? trains[i].run_at-serverTime() : 0;
					tot = '&nbsp;<b>(' + timestrShort(timeRemaining) + ')</b>';
				}
				timeRemaining = (trains[i].run_at-last > 0) ? trains[i].run_at-last : 0;
				m += '<tr>'
				+ '		<td class=right width=20%>' + left + '</td>'
				+ '		<td align=left width=50% colspan=2>' + nombreFormate(trains[i].quantity, ' ') + '&nbsp;&nbsp;' + translate(trains[i].unit_type) + '&nbsp;</td>'
				+ '     <td width=30%><font color=' + TIMER_COLOR + '>' + timestr(timeRemaining, true) + '</font>&nbsp' + tot + '</td>'
				+ '</tr>';
				last = trains[i].run_at;
			}      
			return m;
		}
		// Jawz - Display training queues
		function dispResurrectionJobs (cityIdx){
			var m = '', last = serverTime(), trains = [];
			for (var i=0; i < Seed.cities[cityIdx].jobs.length; i++){
				if (Seed.cities[cityIdx].jobs[i].queue=='resurrection' && 
					Seed.cities[cityIdx].jobs[i].unit_type && 
					Seed.cities[cityIdx].jobs[i].run_at > last
					){
						trains.push (Seed.cities[cityIdx].jobs[i]);
				}
			}
			trains.sort(function(a,b){return a.run_at-b.run_at});
			for (var i=0; i < trains.length; i++){
				var left='', tot='', timeRemaining = 0;
				if (i==0){
					left = translate('Resurrection') + ':';
				}
				else if (i==trains.length-1) {
					timeRemaining = (trains[i].run_at-serverTime() > 0) ? trains[i].run_at-serverTime() : 0;
					tot = '&nbsp;<b>(' + timestrShort(timeRemaining) + ')</b>';
				}
				timeRemaining = (trains[i].run_at-last > 0) ? trains[i].run_at-last : 0;
				m += '<tr>'
				+ '		<td class=right width=20%>' + left + '</td>'
				+ '		<td align=left width=50% colspan=2>' + nombreFormate(trains[i].quantity, ' ') + '&nbsp;&nbsp;' + translate(trains[i].unit_type) + '&nbsp;</td>'
				+ '     <td width=30%><font color=' + TIMER_COLOR + '>' + timestr(timeRemaining, true) + '</font>&nbsp' + tot + '</td>'
				+ '</tr>';
				last = trains[i].run_at;
			}      
			return m;
		}
		// End Jawz
		function switchDefense (event){
			var t = Tabs.Info;
			var button		= event.target;
			var cityId 		= Seed.cities[CAPITAL_ID].id;
			var wallStatus	= Seed.cities[CAPITAL_ID].defended;
			var targMsg		= translate('Switching defense');
			verboseLog(targMsg +' '+ translate('Attempted'));
			new MyAjax.switchDefense (cityId, wallStatus, function (rslt){
				if (rslt.ok){
					verboseLog(targMsg +' '+ translate('Successfully'));
					actionLog(targMsg);
					// Change again when recibe the real state from cityUpdate
					button.className = UID[(Seed.cities[CAPITAL_ID].defended ? 'btn_off' : 'btn_on')];
					button.value = translate(Seed.cities[CAPITAL_ID].defended ? 'Defend' : 'Hiding' ).toUpperCase();
				} else {
					verboseLog(targMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg);
				}
			});
			var state = Seed.cities[CAPITAL_ID].defended;
			button.className = UID[(state ? 'btn_off' : 'btn_on')];
			button.value = translate(state ? 'Defend' : 'Hiding').toUpperCase();
		}
	},

	// Jawz
	tabInfoInventory : function (){
		var t = Tabs.Info;
		clearTimeout (t.timer);    // Jawz - reactivated
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabInfoInventory']).className='selected';
		document.getElementById(UID['tabInfoInventory']).style.zIndex=1;
		t.lastSubTab = 'tabInfoInventory';
		t.contentType = 1;
		Data.options.info.current_tab = t.contentType;

		var city = Seed.cities[CAPITAL_ID];
		var item = '';
		var itmRessources = [];
		var itmProduction = [];
		var itmTime       = [];
		var itmGeneral    = [];
		var itmChest      = [];
		var itmArsenal    = [];
		for (item=0; item<resource_item_list.length; item++){
			num = isEmpty(Seed.player.items[resource_item_list[item]],0);
			if (num > 0) itmRessources.push ({desc:translate(resource_item_list[item]), qty:num});
		}
		for (item=0; item<production_item_list.length; item++){
			num = isEmpty(Seed.player.items[production_item_list[item]],0);
			if (num > 0) itmProduction.push ({desc:translate(production_item_list[item]), qty:num});
		}
		for (item=0; item<time_item_list.length; item++){
			num = isEmpty(Seed.player.items[time_item_list[item]],0);
			if (num > 0) itmTime.push ({desc:translate(time_item_list[item]), qty:num});
		}
		for (item=0; item<general_item_list.length; item++){
			num = isEmpty(Seed.player.items[general_item_list[item]],0);
			if (num > 0) itmGeneral.push ({desc:translate(general_item_list[item]), qty:num});
		}
		for (item=0; item<chest_item_list.length; item++){
			num = isEmpty(Seed.player.items[chest_item_list[item]],0);
			if (num > 0) itmChest.push ({desc:translate(chest_item_list[item]), qty:num});
		}
		for (item=0; item<arsenal_item_list.length; item++){
			num = isEmpty(Seed.player.items[arsenal_item_list[item]],0);
			if (num > 0) itmArsenal.push ({desc:translate(arsenal_item_list[item]), qty:num});
		}
        itmRessources.sort	(function(a, b){a = a.desc.toLowerCase(); b = b.desc.toLowerCase(); if (a>b) return 1; if (a<b) return -1; return 0;});
        itmProduction.sort	(function(a, b){a = a.desc.toLowerCase(); b = b.desc.toLowerCase(); if (a>b) return 1; if (a<b) return -1; return 0;});
        itmTime.sort		(function(a, b){a = a.desc.toLowerCase(); b = b.desc.toLowerCase(); if (a>b) return 1; if (a<b) return -1; return 0;});
        itmGeneral.sort		(function(a, b){a = a.desc.toLowerCase(); b = b.desc.toLowerCase(); if (a>b) return 1; if (a<b) return -1; return 0;});
        itmChest.sort		(function(a, b){a = a.desc.toLowerCase(); b = b.desc.toLowerCase(); if (a>b) return 1; if (a<b) return -1; return 0;});
        itmArsenal.sort		(function(a, b){a = a.desc.toLowerCase(); b = b.desc.toLowerCase(); if (a>b) return 1; if (a<b) return -1; return 0;});

		var m = '<div class=' + UID['status_ticker'] + '>';
		m += t.cityTitle(CAPITAL_ID);
		m += '<table style="margin-top:3px" width=100%>';

		if (itmRessources.length > 0) {
			m+= '<tr class=' + UID['row_headers'] + ' align=center><td style="border-bottom: 1px solid; border-bottom: 1px solid;" colspan=2>'+ translate('Resources') +'</td></tr><tr valign=top align=center>'
			 +'<td width=50% style="border-right: 1px solid;"><table class=' + UID['table'] + ' width=100%>';
			for (var i=0; i<Math.ceil(itmRessources.length/2); i++)
				m += '<tr><td align=left width=80%>'+ itmRessources[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmRessources[i].qty,' ') +'</td></tr>';
			m+= '</table></td><td width=50%><table class=' + UID['table'] + ' width=100%>';
			for (var i=Math.ceil(itmRessources.length/2); i<itmRessources.length; i++)
				m += '<tr><td align=left width=80%>'+ itmRessources[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmRessources[i].qty,' ') +'</td></tr>';
			m += '</table></td></tr><tr><td> &nbsp </td></tr>';
		}
		if (itmProduction.length > 0) {
			m+= '<tr class=' + UID['row_headers'] + ' align=center><td style="border-bottom: 1px solid; border-bottom: 1px solid;" colspan=2>'+ translate('Production') +'</td></tr><tr valign=top align=center>'
			 +'<td width=50% style="border-right: 1px solid;"><table class=' + UID['table'] + ' width=100%>';
			for (var i=0; i<Math.ceil(itmProduction.length/2); i++)
				m += '<tr><td align=left width=80%>'+ itmProduction[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmProduction[i].qty,' ') +'</td></tr>';
			m+= '</table></td><td width=50%><table class=' + UID['table'] + ' width=100%>';
			for (var i=Math.ceil(itmProduction.length/2); i<itmProduction.length; i++)
				m += '<tr><td align=left width=80%>'+ itmProduction[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmProduction[i].qty,' ') +'</td></tr>';
			m += '</table></td></tr><tr><td> &nbsp </td></tr>';
		}
		if (itmTime.length > 0) {
			m+= '<tr class=' + UID['row_headers'] + ' align=center><td style="border-bottom: 1px solid; border-bottom: 1px solid;" colspan=2>'+ translate('Speedup') +'</td></tr><tr valign=top align=center>'
			 +'<td width=50% style="border-right: 1px solid;"><table class=' + UID['table'] + ' width=100%>';
			for (var i=0; i<Math.ceil(itmTime.length/2); i++)
				m += '<tr><td align=left width=80%>'+ itmTime[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmTime[i].qty,' ') +'</td></tr>';
			m+= '</table></td><td width=50%><table class=' + UID['table'] + ' width=100%>';
			for (var i=Math.ceil(itmTime.length/2); i<itmTime.length; i++)
				m += '<tr><td align=left width=80%>'+ itmTime[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmTime[i].qty,' ') +'</td></tr>';
			m += '</table></td></tr><tr><td> &nbsp </td></tr>';
		}
		if (itmGeneral.length > 0) {
			m+= '<tr class=' + UID['row_headers'] + ' align=center><td style="border-bottom: 1px solid; border-bottom: 1px solid;" colspan=2>'+ translate('General') +'</td></tr><tr valign=top align=center>'
			 +'<td width=50% style="border-right: 1px solid;"><table class=' + UID['table'] + ' width=100%>';
			for (var i=0; i<Math.ceil(itmGeneral.length/2); i++)
				m += '<tr><td align=left width=80%>'+ itmGeneral[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmGeneral[i].qty,' ') +'</td></tr>';
			m+= '</table></td><td width=50%><table class=' + UID['table'] + ' width=100%>';
			for (var i=Math.ceil(itmGeneral.length/2); i<itmGeneral.length; i++)
				m += '<tr><td align=left width=80%>'+ itmGeneral[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmGeneral[i].qty,' ') +'</td></tr>';
			m += '</table></td></tr><tr><td> &nbsp </td></tr>';
		}
		if (itmChest.length > 0) {
			m+= '<tr class=' + UID['row_headers'] + ' align=center><td style="border-bottom: 1px solid; border-bottom: 1px solid;" colspan=2>'+ translate('Chest') +'</td></tr><tr valign=top align=center>'
			 +'<td width=50% style="border-right: 1px solid;"><table class=' + UID['table'] + ' width=100%>';
			for (var i=0; i<Math.ceil(itmChest.length/2); i++)
				m += '<tr><td align=left width=80%>'+ itmChest[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmChest[i].qty,' ') +'</td></tr>';
			m+= '</table></td><td width=50%><table class=' + UID['table'] + ' width=100%>';
			for (var i=Math.ceil(itmChest.length/2); i<itmChest.length; i++)
				m += '<tr><td align=left width=80%>'+ itmChest[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmChest[i].qty,' ') +'</td></tr>';
			m += '</table></td></tr><tr><td> &nbsp </td></tr>';
		}
		if (itmArsenal.length > 0) {
			m+= '<tr class=' + UID['row_headers'] + ' align=center><td style="border-bottom: 1px solid; border-bottom: 1px solid;" colspan=2>'+ translate('Arsenal') +'</td></tr><tr valign=top align=center>'
			 +'<td width=50% style="border-right: 1px solid;"><table class=' + UID['table'] + ' width=100%>';
			for (var i=0; i<Math.ceil(itmArsenal.length/2); i++)
				m += '<tr><td align=left width=80%>'+ itmArsenal[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmArsenal[i].qty,' ') +'</td></tr>';
			m+= '</table></td><td width=50%><table class=' + UID['table'] + ' width=100%>';
			for (var i=Math.ceil(itmArsenal.length/2); i<itmArsenal.length; i++)
				m += '<tr><td align=left width=80%>'+ itmArsenal[i].desc +'</td><td align=left width=20%>'+ nombreFormate(itmArsenal[i].qty,' ') +'</td></tr>';
			m += '</table></td></tr><tr><td> &nbsp </td></tr>';
		}
		m += '</table></div>';
		document.getElementById(UID['tabInfo_Content']).innerHTML = m; 
		t.showClock();
		// Jawz
		t.timer = setTimeout (t.show, 1000);
	},
	// End Jawz

	// Jawz
	tabInfoQuests : function (){
		var t = Tabs.Info;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabInfoQuests']).className='selected';
		document.getElementById(UID['tabInfoQuests']).style.zIndex=1;
		t.lastSubTab = 'tabInfoQuests';
		t.contentType = 2;
		Data.options.info.current_tab = t.contentType;

		var city = Seed.cities[CAPITAL_ID];
		var m = '<div class=' + UID['status_ticker'] + ' stype="width:540px; max-width:540px;">';
		m += t.cityTitle(CAPITAL_ID);
		m += '<table style="margin-top:3px" width=100%>';

		for (var i=0; i<Seed.quests.category.length; i++) {
			if (Data.options.collapsed.quests[i] == undefined) {
				Data.options.collapsed.quests[i] = false;
			}
		}

		var cl = [], ql = [];
		for (var i=0; i<Seed.quests.category.length; i++) {
			var questListId = 'tabInfo_questList_' + i;
			var categoryId 	= 'tabInfo_categ_' + i;
			var first = true;
			for (var j=0; j<Seed.quests.list[Seed.quests.category[i]].length; j++) {
				var quest		= Seed.quests.list[Seed.quests.category[i]][j];
				var questId 	= 'tabInfo_quest_' + i + '_' + j;
				var questFbId 	= 'tabInfo_QFb_' + i + '_' + j;
				var questname	= Translation.xml['quests'][_normalize(quest.name)];
				var completed	= isCompleted (quest.name);
				var claimed		= isClaimed (quest.name);
				if (!claimed) {
					if (first) {
						m += '<tr class=' + UID['row_headers'] + ' align=center>'
						  +'	<td style="border-bottom: 1px solid; border-bottom: 1px solid;" width=100%>'
						  +'		<A><div id=' + setUID(categoryId) + ' ref="' + i + '" >'+ translate(Seed.quests.category[i]) +'</div></A>'
						  +'	</td>'
						  +'</tr>'
						  +'<tr valign=top>'
						  +'	<td width=100%>'
						  +'		<div id=' + setUID(questListId) + '>'
						  +'			<table>';
						cl.push(UID[categoryId]);
						first = false;
					}

					var recommended = (quest.recommended && !completed) ? '<span class=' + UID['red'] + '>'+ questname +'</span>' : questname;
					m += '<tr valign=top><td align=left width="160px" style="padding-bottom: 3px; border-bottom: 1px solid #898989;">' + recommended + '</td>'
					  +'	<td align=left width="328px" style="padding-bottom: 3px; border-bottom: 1px solid #898989;">' + Translation.xml['quests'][_normalize(quest.name+'-objectives')] + '<br>'
					  +'		<font color=' + TIMER_COLOR + '>' + getRewards (quest.reward) + '</font>';
					if (completed) {
						m +='<td align=center valign=middle width="50px" style="padding-bottom: 3px; border-bottom: 1px solid #898989;"><div id=' + setUID(questFbId) + '>'
						  +'<input id='+ setUID(questId) +' class="' + UID['bnt_green'] + ' small" ref="' + i + '_' + j + '" style="width:auto !important;" type=submit value=" ' + translate('Claim') + ' " />'
						  +'</div></td>'
						  +'</tr>';
						ql.push(UID[questId]);
					} else m+= '<td width="50px" style="padding-bottom: 3px; border-bottom: 1px solid #898989;"></td></tr>';
				}
			}
			if (!first) m += '</table></div></td></tr>';
		}
		m += '</table></div>';
		document.getElementById(UID['tabInfo_Content']).innerHTML = m;
		for (var c=0; c<cl.length; c++) {
			document.getElementById(cl[c]).addEventListener('click', toggleHideShow, false);
			var categ = document.getElementById(cl[c]).getAttribute('ref');
			var id = 'tabInfo_questList_' + categ;
			var el = document.getElementById(UID[id]);
			if (Data.options.collapsed.quests[categ])
				el.style.display = 'none';
			else
				el.style.display = 'block';
		}

		for (var q=0; q<ql.length; q++)
			document.getElementById(ql[q]).addEventListener('click', claimRewards, false);

		function isClaimed (name){
			var found = false;
			if (Seed.player.quests.claimed) {
				for (var x=0; x<Seed.player.quests.claimed.length && !found; x++) {
					if (name == Seed.player.quests.claimed[x]) found = true;
				}
			}
			return found;
		}

		function isCompleted (name){
			var found = false;
			if (Seed.player.quests.completed) {
				for (var x=0; x<Seed.player.quests.completed.length && !found; x++) {
					if (name == Seed.player.quests.completed[x]) found = true;
				}
			}
			return found;
		}

		function getRewards (list) {
			var result = '';
			var tRes = [];
			for (var i in list) {
				if (list[i] > 0)
					tRes.push (nombreFormate(list[i],' ') + ' ' + translate (i)); 
			}
			if (tRes.length>0) result = tRes.join(', ');
			return result;
		}

		function toggleHideShow (evt){
			var categ = evt.target.getAttribute('ref');
			var id = 'tabInfo_questList_' + categ;
			var el = document.getElementById(UID[id]);
			if (el.style.display == 'none') {
				el.style.display = 'block';
				Data.options.collapsed.quests[categ] = false;
			} else {
				el.style.display = 'none';
				Data.options.collapsed.quests[categ] = true;
			}
		}

		function claimRewards (evt){
			var id   = evt.target.getAttribute('ref').split('_');
			var name = Seed.quests.list[Seed.quests.category[id[0]]][id[1]].name;
			evt.target.disabled = true;
			Element.removeClassName(evt.target, UID['bnt_green']);
			Element.addClassName(evt.target, UID['bnt_disabled']);
			var FBid = 'tabInfo_QFb_' + evt.target.getAttribute('ref');
			var FBel = document.getElementById(UID[FBid]);
			new MyAjax.claimQuest (name, function (rslt) {
				if (rslt.ok) {
					actionLog('<B>' + translate('Quest') + ' ' + name + '</B> ' + translate('claimed') + ' ' + translate('Successfully'));
					FBel.innerHTML = '<font color=#898989>' + translate('Claimed') + '</font>';
				} else {
					actionLog(translate('Claiming quest') + ' ' + name +' '+ translate('failed and returned error') +': '+ rslt.errmsg);
					FBel.innerHTML = '<font color=#AA0000><B>' + translate('Error') + '</b></font>';
				}
			});	
		}

		function _normalize (str){
			return str.toLowerCase().replace(/_/g,'-');
		}
	},
	// End Jawz

	cityTitle : function (cityIdx, UID_button){
		var t = Tabs.Info;
		var city = Seed.cities[cityIdx];
		// Outposts are always defending (until further notice)
		var wallStatus = '';
		var alliance_name = (Seed.player.alliance) ? Seed.player.alliance.name : '';
		alliance_name = (city.type == kOutpost) ? '' : alliance_name;
		if (cityIdx == CAPITAL_ID){
			wallStatus = (Seed.cities[cityIdx].defended) ? '<font class='+ UID['defending'] +'>'+ translate('Defend').toUpperCase() +'</font>' : '<font class='+ UID['hiding'] +'>'+ translate('Hiding').toUpperCase() +'</font>';
		} else {
			wallStatus = ' &nbsp ';
		}
		return '<div class=' + UID['subtitle'] + '><table class=' + UID['table'] + '>'
				+'<tr><td align=left width=35%>'+ ( (city.type == kOutpost) ? translate(city.name) : city.name ) +'</td>'
				+'<td align=center width=30%>'+ city.x +','+ city.y + '</td>'
				+'<td align=center width=200px><font color=yellow>' + alliance_name +'</font></td>'
				+'<TD width=35% align=right>'+ wallStatus +'</td>'
				+'</tr></table></div>';
	},

	refresh : function (){
		logit('fetchPlayer from Tab.Info refresh');
		var t = Tabs.Info;
		// Jawz
		// Seed.fetchPlayer (t.showStuff());
		switch (t.contentType) {
			case 0: Seed.fetchPlayer (t.tabInfoOverview()); break;
			case 1: Seed.fetchPlayer (t.tabInfoInventory()); break;
		}
		// End Jawz
	},
}
//******************************** Info Tab *****************************


//*********************************** Wave Tab *********************************************
Tabs.Waves = {
	tabOrder	: WAVE_TAB_ORDER,
	tabLabel	: 'Wave',
	tabDisabled	: !WAVE_TAB_ENABLE,
	container	: null,
	enabled		: false,
	attackTimer	: null,
	marchTimer	: null,
	attackErrors: 0,
	contentType	: 0, // 0 = attack, 1 = history
	lastSubTab	: 'tabWaveAttack',
	running		: { start_at:0 },

	init : function (div) {
		var t = Tabs.Waves;
		Data.setDefaultValues ('waves');

		t.container = div;
		var m = ''
		+'<div class=' + UID['title'] + '>'+ translate('Wave') +'</div>'
		+'<div id=' + setUID('tabWave_Status') + ' class=' + UID['status_ticker'] + ' style="margin-bottom:5px !important">'
		+'	<center><input id=' + setUID('tabWave_OnOff') + ' type=button value="OnOff" /></center>'
		+'	<div id=' + setUID('tabWave_Report') + ' style="margin-top:5px;height:140px; max-height:140px; overflow-y:auto;">'
		+'		<table id=' + setUID('tabWave_Marches') + ' class=' + UID['table'] + '>'
		+'		</table>'
		+'	</div>'
		+'	<div id=' + setUID('tabWave_Feedback') + ' class='+ UID['status_feedback'] +'></div>'
		+'</div>'
		// Jawz
		+'<ul class=tabs>'
		+'	<li class="tab first"><a id='+ setUID('tabWaveAttack') +'>'+ translate('Attack') +'</a></li>'
		+'	<li class=tab><a id='+ setUID('tabWaveHistory') +'>'+ translate('History') +'</a></li>'
		+'</ul>'
		+'<div id='+ setUID('tabWave_Content') +' style="padding-top:0px; height:480px; overflow-y:auto"></div>';
		t.container.innerHTML = m;
		
		document.getElementById(UID['tabWaveAttack']).addEventListener ('click', t.tabWaveAttack, false);
		document.getElementById(UID['tabWaveHistory']).addEventListener ('click', t.tabWaveHistory, false);
		document.getElementById(UID['tabWave_OnOff']).addEventListener ('click', function(){
			t.setWaveEnable(!Data.options.waves.enabled);
		}, false);
		window.addEventListener('unload', t.onUnload, false);
		t.setWaveEnable (false);
		t.contentType = isEmpty(Data.options.waves.current_tab,0);
		t.show();
		Messages.addBattleReportListener(t.gotBattleReport);
	},

	tabWaveAttack : function (){
		var t = Tabs.Waves;
		
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabWaveAttack']).className='selected';
		document.getElementById(UID['tabWaveAttack']).style.zIndex=1;
		t.lastSubTab = 'tabWaveAttack';
		
		t.contentType = 0;

		var m = '<div class="' + UID['title'] + '">'+ translate('Attacks') + '</div>'
		// End Jawz
		+'<div class=' + UID['content'] + '>'
		+'	<div>'
		+'		<b>'+ translate('Coords') +':&nbsp;</b>&nbsp;'
		+'		X: <input id=' + setUID('tabWave_CoordsX') + ' size=1 maxlength=3 type=text value="'+ Data.options.waves.target.x +'" /> '
		+'		Y: <input id=' + setUID('tabWave_CoordsY') + ' size=2 maxlength=3 type=text value="'+ Data.options.waves.target.y +'" /> '
		+'		&nbsp <b>'+ translate('Distance') +':</b> <span id=' + setUID('tabWave_Distance') + '></span>'
		+'		&nbsp <input id='+ setUID('tabWave_Save') +' class="' + UID['bnt_green'] + ' small" style="width:auto !important;" type=submit value=" ' + translate('Save Attaque') + ' " /><BR>'
		+'		<div class=' + UID['status_ticker'] + ' style="height:auto !important;margin:5px 10px !important;">'
		+'			<center><span id=' + setUID('tabWave_Tile') + '></span></center>'
		+'		</div>'
		+'	</div>'
		+'  <div>'
		//+'  <center>'  // Jawz
		+'	<table id=' + setUID('tabWave_Troops') + ' class=' + UID['table'] + '>'
		+'		<tr align=center class=' + UID['row_headers'] + '>'
		+'			<td colspan=8>'+ translate('Troops for Wave Attack') +':&nbsp;</td>'
		+'		</tr>'
		+'	</table>'
		//+'  </center>'  // Jawz
		+'	</div>'
		//+'	<br>'  // Jawz
		+'	<table class=' + UID['table'] + '>'
		+'		<tr>'
		// Jawz
		+'			<td class=right> '+ translate('Include Great Dragon') +':&nbsp;</td>'
		+'			<td><input id=' + setUID('tabWave_includeGD') + ' type=checkbox '+ (Data.options.waves.include_great_dragon?'CHECKED':'') +' /></td>'
		+'		</tr><tr>'
		+'			<td class=right>&nbsp;</td>'
		+'		</tr><tr>'
		// End Jawz
		+'			<td class=right> '+ translate('Delete Battle Reports') +':&nbsp;</td>' // Jawz - replaced class=left by right
		+'			<td><input id=' + setUID('tabWave_DelReports') + ' type=checkbox '+ (Data.options.waves.delete_reports?'CHECKED':'') +' /></td>'
		+'		</tr><tr>'
		+'			<td class=right>'+ translate('Stop if any troops lost') +':&nbsp;</td>' // Jawz - replaced class=left by right
		+'			<td><input id=' + setUID('tabWave_StopOnLoss') + ' type=checkbox '+ (Data.options.waves.stop_on_loss?'CHECKED':'') +' /></td>'
		+'		</tr><tr>'
		+'			<td class=right>'+ translate('Delay Between Attacks') +':&nbsp;</td>' // Jawz - replaced class=left by right
		+'			<td>'
		+'				<input id=' + setUID('tabWave_DelayMin') + ' type=text size=1 maxlength=4 value="'+ Data.options.waves.delay_min +'" />'
		+'				 to <span id=' + setUID('tabWave_DelayMax') + '>'+ Data.options.waves.delay_max +'</span>&nbsp;'+ translate('Seconds')
		+'			</td>'
		// Jawz
		+'		</tr><tr>'
		+'			<td class=right> '+ translate('Maximum simultaneous marches') +':&nbsp;</td>'
		+'			<td><input id=' + setUID('tabWave_MaxMarches') + ' type=text size=1 maxlength=2 value="'+ Data.options.waves.max_marches +'" /></td>'
		// End Jawz
		+'		</tr>'
		+'	</table>'
		+'</div>'
		+'<div class=' + UID['status_ticker'] + ' style="margin-top:10px !important">'
		+'	<center><input id=' + setUID('tabWave_ResetStats') + ' type=button value="'+ translate('Reset Stats') +'" /></center>'
		+'	<div id=' + setUID('tabWave_Stats') + '  style="height:170px; max-height:170px; overflow-y:auto"></div>'  // Jawz - Set Height to 170 instead of 200px
		+'	<hr class=thin>'
		+'	<div id=' + setUID('tabWave_CurSpoil') + '> &nbsp; </div>'
		+'</div>';
		document.getElementById(UID['tabWave_Content']).innerHTML = m;
		
		document.getElementById(UID['tabWave_CoordsX']).addEventListener ('change', t.eventCoords, false);
		document.getElementById(UID['tabWave_CoordsY']).addEventListener ('change', t.eventCoords, false);
		document.getElementById(UID['tabWave_ResetStats']).addEventListener ('click', t.resetStats, false);
		document.getElementById(UID['tabWave_Save']).addEventListener ('click', saveCoords, false);
		// Jawz
		document.getElementById(UID['tabWave_includeGD']).addEventListener ('click', function(e){
			Data.options.waves.include_great_dragon=e.target.checked;
		}, false);
		// End Jawz
		document.getElementById(UID['tabWave_DelReports']).addEventListener ('click', function(e){
			Data.options.waves.delete_reports=e.target.checked;
		}, false);
		document.getElementById(UID['tabWave_StopOnLoss']).addEventListener ('click', function(e){
			Data.options.waves.stop_on_loss=e.target.checked;
		}, false);

		document.getElementById(UID['tabWave_DelayMin']).addEventListener ('change', delayChanged, false);
		document.getElementById(UID['tabWave_MaxMarches']).addEventListener('change', maxMarchesChanged, false); // Jawz

		troopTable (document.getElementById(UID['tabWave_Troops']), 1, 'AW', t.eventTroops);
		t.eventCoords();
		t.dispStats();

		function troopTable (tab, rownum, prefix, listener) {
			var t = Tabs.Waves;
			var row =[];
			row.push(tab.insertRow(rownum));
			row.push(tab.insertRow(rownum+1));
			//row.push(tab.insertRow(rownum+2));  // Jawz
			//row.push(tab.insertRow(rownum+3));  // Jawz
			//row[0].align='center';
			
			var val, r=0, c=0;
			for (var i=0; i < wave_unit_types.length; ++i)
			{
				/* Jawz - Put in comment to have troops on one line
				if (i == 5) {
					r = r + 2;
					c = 0;
				}
				*/
				row[r].insertCell(c).innerHTML = translate(Names.getTroopAbbr(wave_unit_types[i]));
				
				var inp = document.createElement ('input');
				inp.type = 'text';
				inp.size = '1';
				inp.style.width = '30px';
				inp.title = translate(wave_unit_types[i]);
				
				if (i < 3) {
					inp.style.border = '1px solid grey';
				} else if (i < 6) {
					inp.style.border = '1px solid green';
				} else {
					inp.style.border = '1px solid blue';
				}
				
				inp.maxlength = '6'; // Allow 100,000 troops to be sent
				
				if (prefix=='AW'){
					if (Data.options.waves.target.units[wave_unit_types[i]] == undefined){
						Data.options.waves.target.units[wave_unit_types[i]] = 0;
					}
					val = Data.options.waves.target.units[wave_unit_types[i]];
					// Jawz
					if (Data.options.waves.target.saved_units[wave_unit_types[i]] == undefined){
						Data.options.waves.target.saved_units[wave_unit_types[i]] = 0;
					}
					val = Data.options.waves.target.saved_units[wave_unit_types[i]];
					// End Jawz
				}
				
				if (!val){
					val = 0;
				}
				
				inp.value = val;
				inp.name = prefix +'_'+ i;
				inp.addEventListener ('change', listener, false);
				
				row[r+1].insertCell(c).appendChild (inp);
				
				c = c + 1;
				
			}
			return tab;
		}
		
		function delayChanged (e){
			var min = parseIntZero(e.target.value);
			var max = parseInt(min * 1.5);
			if (min < MIN_DELAY_BETWEEN_WAVE || min > 3600){
				// error dialog, etc ...
				e.target.style.backgroundColor = 'red';
				return;
			}
			document.getElementById(UID['tabWave_DelayMax']).innerHTML = max;
			e.target.style.backgroundColor = '';
			Data.options.waves.delay_min = min;
			Data.options.waves.delay_max = max;
		}

		function maxMarchesChanged (e){
			var val = parseIntNan(document.getElementById(UID['tabWave_MaxMarches']).value);
			if (val < 0 || val > Seed.cities[CAPITAL_ID].figures.marches.maximum){
				e.target.style.backgroundColor = 'red';
				return;
			}
			e.target.style.backgroundColor = '';
			Data.options.waves.max_marches = val;
		} 

		function saveCoords (){
			var t = Tabs.Waves;
			if (Data.options.waves.history && Data.options.waves.history.length>0) {
				var h = cloneProps(Data.options.waves.history);
				for (var i=h.length-1; i>=0; i--) {
					if ((h[i].x == Data.options.waves.target.x) && (h[i].y == Data.options.waves.target.y))
						Data.options.waves.history.splice(i,1);
				}
			}
			var rec = {
				x		: Data.options.waves.target.x,
				y		: Data.options.waves.target.y,
				type	: Data.options.waves.target.type,
				level	: Data.options.waves.target.level,
				units	: Data.options.waves.target.units
			};
			Data.options.waves.history.push(rec);
		}
	},

	// Jawz
	tabWaveHistory : function (){
		var t = Tabs.Waves;
		
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabWaveHistory']).className='selected';
		document.getElementById(UID['tabWaveHistory']).style.zIndex=1;
		t.lastSubTab = 'tabWaveHistory';
		
		t.contentType = 0;

		var m = '<div class="' + UID['title'] + '">'+ translate('History') + '</div>'
			+'	<div id=' + setUID('tabWave_HistoryList') + ' class=' + UID['status_ticker'] + ' style="height:450px; max-height:450px; width:540px; max-width:540px; overflow-y:auto ; overflow-x:auto ; margin-top:1px !important"></div>'
			+'	</div>';
		document.getElementById(UID['tabWave_Content']).innerHTML = m;

		var m = '<table class=' + UID['table'] + '>'
			+'	<tr class=' + UID['row_headers'] +'>'
			+'		<td width="35px"><A><span>' + translate('Dist') + '</span></A></td>'
			+'		<td width="50px"><A><span>' + translate('Coords') + '</span></A></td>'
			+'		<td width="160px"><A><span>' + translate('Target') + '</span></A></td>'
			+'		<td width="175px"><A><span>' + translate('Troops') + '</span></A></td>'
			+'	</tr>';
		for (var i=0; i<Data.options.waves.history.length; i++){
			m += '<tr valign=top><td style="border-bottom: 1px solid #898989;">' + getDistance(Seed.cities[CAPITAL_ID].x, Seed.cities[CAPITAL_ID].y, Data.options.waves.history[i].x, Data.options.waves.history[i].y) + '</td>'
			+'	<td align=center style="border-bottom: 1px solid #898989;">' + Data.options.waves.history[i].x +','+ Data.options.waves.history[i].y + '</td>'
			+'	<td align=left style="border-bottom: 1px solid #898989;">' + Data.options.waves.history[i].type + '</td>'
			+'	<td align=left style="border-bottom: 1px solid #898989;">' + getTroops(Data.options.waves.history[i].units) +'</td>'
			+'	<td><input id='+ setUID('tabWave_Recall_'+i) +' ref='+ i +' class="Xtrasmall '+UID['bnt_green']+'" style="width:auto !important;" type=submit value="' + translate('Recall') + '" /></td>'
			+'	<td><input id='+ setUID('tabWave_Delete_'+i) +' ref='+ i +' class="Xtrasmall '+UID['bnt_red']+'" style="width:auto !important;" type=submit value=" X " /></td>'
			+'</tr>';
		}
		document.getElementById(UID['tabWave_HistoryList']).innerHTML = m + '</table>';
		for (var i=0; i<Data.options.waves.history.length; i++){
			var butRecall = document.getElementById(UID['tabWave_Recall_'+ i]);
			var butDelete = document.getElementById(UID['tabWave_Delete_'+ i]);
			butRecall.addEventListener ('click', recallTarget, false);
			butDelete.addEventListener ('click', deleteTarget, false);
		}

		function recallTarget (e){
			var n = parseInt(e.target.getAttribute('ref'));
			Data.options.waves.target.x			  = Data.options.waves.history[n].x;
			Data.options.waves.target.y			  = Data.options.waves.history[n].y;
			Data.options.waves.target.type		  = Data.options.waves.history[n].type;
			Data.options.waves.target.level		  = Data.options.waves.history[n].level;
			Data.options.waves.target.units		  = cloneProps(Data.options.waves.history[n].units);
			Data.options.waves.target.saved_units = cloneProps(Data.options.waves.history[n].units);
			t.tabWaveAttack();
		}

		function deleteTarget (e){
			var n = parseInt(e.target.getAttribute('ref'));
			Data.options.waves.history.splice(n,1);
			t.tabWaveHistory();
		}

		function getTroops (trps) {
			var result = '';
			var tRes = [];
			for (var i in trps) {
				if (trps[i] > 0)
					tRes.push (nombreFormate(trps[i],' ') + ' ' + translate (i)); 
			}
			if (tRes.length>0) result = tRes.join(',<br>');
			return result;
		}
	},
	// End Jawz

	gotBattleReport : function (rpt_w){
		var t = Tabs.Waves;
		if (!rpt_w) return;	// Jawz
		if (rpt_w.report.location.x == Data.options.waves.target.x && 
			rpt_w.report.location.y == Data.options.waves.target.y
			){
				if (!Data.stats.waves.total_attacks || Data.stats.waves.total_attacks == undefined) Data.stats.waves.total_attacks = 0; // Jawz
				++Data.stats.waves.total_attacks;
				for (var i=0; i < rpt_w.report.spoils.items.length; i++){
					if ( !Data.stats.waves.spoils[rpt_w.report.spoils.items[i]] )
					{
						Data.stats.waves.spoils[rpt_w.report.spoils.items[i]] = 1;
					}
					else {
						++Data.stats.waves.spoils[rpt_w.report.spoils.items[i]];
					}
					document.getElementById(UID['tabWave_CurSpoil']).innerHTML = new Date().toTimeString().substring (0,8) +': '+ translate('Got') + ' '+ translate(rpt_w.report.spoils.items[i]);
				}
				t.dispStats();
				
				if (Data.options.waves.stop_on_loss)
				{
					for (var p in rpt_w.report.attacker.units)
					{
						if (rpt_w.report.attacker.units[p][0] != rpt_w.report.attacker.units[p][1])
						{
							var ts = new Date(rpt_w.report_notification.created_at * 1000).myString();
							t.setWaveEnable (false);
							t.dispFeedback (translate('Troops lost') + '! (' + ts +')');
							actionLog (translate('Wave')+': '+translate('Troops lost')+'! ('+ ts +')');
							return;
						}
					}
				}
				if (Data.options.waves.delete_reports && rpt_w.report.attacker.name == Seed.player.name){
					Messages.deleteMessage(rpt_w.report_notification.id);
				}
		}
	},

	resetStats : function (){
		var t = Tabs.Waves;
		var now = serverTime();

		Data.stats.waves = {
			start_at		: now,
			run_time		: 0,
			total_attacks	: 0,
			spoils			: {}
		};
		t.dispStats();
	},

	dispStats : function (){
		var t = Tabs.Waves;
		var run_time = Data.stats.waves.run_time;
		
		if (Data.options.waves.enabled){
			run_time += (serverTime()-t.running.start_at);
		}
		
		var msg = '<table class=' + UID['table'] + ' width=100%>'
		+'	<tr>'
		+'		<td class=right>'+ translate('Run Time') +': </td>' // Jawz - replaced class=left by right
		+'		<td width=90%>'+ timestr(run_time, true) +'</td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Attacks') +': </td>' // Jawz - replaced class=left by right
		+'		<td>'+ Data.stats.waves.total_attacks +'</td>'
		+'	</tr><tr>'
		+'		<td colspan=2><HR class=thin></td>'
		+'	</tr>';
		
		for (var p in Data.stats.waves.spoils)
		{
			var num = Data.stats.waves.spoils[p];
			var perHour = num / (run_time/3600);
			var item = Names.getItemAbbr(p);
			msg += '<tr>'
				+ '		<td class=right>'+ translate(item) +':</td>' // Jawz - replaced class=left by right
				+ '		<td>'+ num +' ('+ perHour.toFixed(2) +'&nbsp;'+ translate('per hour')+ ')</td>'
				+ '</tr>';
		}
		
		document.getElementById(UID['tabWave_Stats']).innerHTML = msg + '</table>';
	},

	dispFeedback : function (msg){
		if (msg && msg!='')
		msg = new Date().toTimeString().substring (0,8) +' '+ msg;
		document.getElementById(UID['tabWave_Feedback']).innerHTML = msg;
	},

	eventTroops : function (e){
		var t = Tabs.Waves;
		var args = e.target.name.split ('_');
		if (args[0] == 'AW'){
			var tt = wave_unit_types[args[1]];
			var tr = Data.options.waves.target.units;
			tr[tt] = e.target.value;
			// Jawz
			var tr = Data.options.waves.target.saved_units;
			tr[tt] = e.target.value;
			// End Jawz
		}
	},

	setWaveEnable : function (onOff){
		var t = Tabs.Waves;
		var but = document.getElementById(UID['tabWave_OnOff']);
		clearTimeout (t.attackTimer);
		Data.options.waves.enabled = onOff;
		if (onOff){
			but.value = translate('Attacking').toUpperCase();
			but.className = UID['btn_on'];
			t.waveAttackTick();
			t.running.start_at = serverTime();
			Data.stats.waves.start_at = serverTime();
		} 
		else {
			but.value = translate('Disabled').toUpperCase();
			but.className = UID['btn_off'];
			if ( t.running.start_at !== 0 ){
				Data.stats.waves.run_time += ( serverTime() - t.running.start_at );
			}
		}
	},

	onUnload : function (){
		var t = Tabs.Waves;
		if (Data.options.waves.enabled && t.running.start_at != 0){
			Data.stats.waves.run_time += ( serverTime() - t.running.start_at );
		}
	},


	waveAttackTick : function (){
		var t = Tabs.Waves, targetMsg, retryDelay, availableGeneral, waveUnits, marchCount = 0;
		clearTimeout (t.attackTimer);
		
		if (!Data.options.waves.enabled){
			return;
		}    
		
		targetMsg = Data.options.waves.target.type + translate(' at ') + Data.options.waves.target.x +'/'+ Data.options.waves.target.y;
		// targetMsg =  translate('level') + ' ' + Data.options.waves.target.lvl + ' ' + Data.options.waves.target.type + translate(' at ') + Data.options.waves.target.x +'/'+ Data.options.waves.target.y;

		var min_time = 700000;
		var max_time = 0;
		for (id in Seed.marches){
			++marchCount;
			var left_time = ( Seed.marches[id].run_at - parseInt(serverTime()) ) + (Seed.marches[id].status=='marching' ? Seed.marches[id].duration : 0);
			//fixed by Didi
			if (left_time > 0) {
				min_time = min_time < left_time ? min_time : left_time;
				max_time = max_time > left_time ? max_time : left_time;
			}
		}
		
		//fixed by Didi
		if ( min_time === 700000 || max_time === 0 ) {
			min_time = 3;
		}
		
		retryDelay = min_time + Math.randRange(2,5);
		//retryDelay = Math.floor(Math.random() * (-1) + 7);
		
		if (MyAjax.marchBusy > 0){
			MyAjax.marchBusy = marchCount;
			verboseLog(translate('Wave attack to ') + targetMsg + ' ' + translate('delayed due to pending march request') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('Another march request is pending') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
			return;
		}
		if (marchCount >= Data.options.waves.max_marches){
			verboseLog(translate('Wave attack to ') + targetMsg + ' ' + translate('delayed due to march limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('March limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
			return;
		}

		if (getMusterPointSlots(CAPITAL_ID) <= 0) {
			verboseLog(translate('Wave attack to ') + targetMsg + ' ' + translate('delayed due to muster point full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(translate('Muster Point Full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' '+translate('Seconds'));
			t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
			return;
		}
		
		availableGeneral = getAvailableGeneral();
		if (availableGeneral === null) {
			verboseLog(translate('Wave attack to ') + targetMsg + ' ' + translate('delayed due to no available generals') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(translate('No generals available') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
			return;
		}

		Data.options.waves.target.units = cloneProps(Data.options.waves.target.saved_units); // Jawz
		waveUnits = t.checkTroops(CAPITAL_ID, Data.options.waves.target.units);
		if (waveUnits !== null) {
			verboseLog(translate('Wave attack to ') + targetMsg + ' ' + translate('delayed due to') + ' ' + waveUnits + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(waveUnits + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
			return;
		}
		
		// Jawz
		if (Data.options.waves.include_great_dragon) {
			var greatDrag = null;
			if ((greatDrag = getAvailableDragon ()) == null){
				verboseLog(translate('Wave attack to ') + targetMsg + ' ' + translate('delayed due to no available Great Dragon') + ': ' + translate ('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
				t.dispFeedback(translate('No Great Dragon available') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
				t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
				return;
			}
			Data.options.waves.target.units[greatDrag] = 1;
		}
		// End Jawz
		
		// All prerequisite checks are done so march request can be sent
		verboseLog(translate('Wave attack to ') + targetMsg + ' '+translate('Attempted'));
		
		new MyAjax.marchSend (Seed.cities[CAPITAL_ID].id, Data.options.waves.target.x, Data.options.waves.target.y, availableGeneral.id, Data.options.waves.target.units, 'waves', function (rslt) {
			var t = Tabs.Waves, waveDelay, retryDelay;
			if (rslt.ok && rslt.dat.result.success) {
				Marches.add(rslt.dat.result.job.march_id, 'waves');
				t.attackErrors = 0;
				waveDelay = Math.floor(Math.random() * (Data.options.waves.delay_max - Data.options.waves.delay_min + 1) + Data.options.waves.delay_min);

				verboseLog(translate('Wave attack to ') + targetMsg + ' ' + translate('Successfully'));
				actionLog('<B>'+ translate('Wave attack to ') + '</B>' + targetMsg);
				
				t.dispFeedback (translate('Wave attack to ') + targetMsg);

				//target.lastAttack = serverTime();
				t.attackTimer = setTimeout (t.waveAttackTick, waveDelay * 1000);
			} else {
				t.attackErrors++
				retryDelay = 30 * (t.attackErrors * t.attackErrors);
				
				verboseLog(translate('Wave attack to ') + targetMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg+ ' - ' + translate('Retry in') + ' ' + retryDelay  + ' ' + translate('seconds'));
				actionLog('<B>' + translate('Wave attack to ') + '</B>' + targetMsg + ' ' + translate('failed'));

				if (rslt.status === 509){
					retryDelay = 600;
					verboseLog('<b>' + translate('Wave attack to ') + '</b> ' + targetMsg + ' ' + translate('failed') + ' - ' + translate('<b>Rate Limit Exceeded</b>, too many requests!') + ' - ' + translate('Retry in') + ' :' + retryDelay);
					t.dispFeedback(translate('Wave attack to ') + ' ' + targetMsg + ' ' + translate('failed')+' - '+translate('Rate Limit Exceeded because there were too many requests') + ' - ' + translate('Retry in') +' '+ retryDelay);
				} else
					t.dispFeedback(translate('Wave attack to ') + targetMsg + ' ' + translate('failed'));
				t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
			} 
		});
	},

	// returns null if ok, else error message
	checkTroops : function (cityIdx, units){
		var totalTroops = 0;
		for (var p in units){
			if (units[p] > 0){
				totalTroops += units[p];
				if (Seed.cities[cityIdx].units[p] < units[p]){
					return (translate('Not enough') + ' ' + translate(p));
				}
			}
		}
		if (totalTroops <= 0){
			return (translate('No Troops Defined'));
		}
		return null;
	},

	marchTick : function (){
		var t = Tabs.Waves;
		clearTimeout (t.marchTimer);
		Marches.updateTable ( document.getElementById(UID['tabWave_Marches']), 'waves' );
		t.marchTimer = setTimeout (t.marchTick, 1000);
	},
	
	// Calls Map.getTargetByCoords
	eventCoords : function (e){
		var ex = document.getElementById(UID['tabWave_CoordsX']);
		var ey = document.getElementById(UID['tabWave_CoordsY']);
		var x = parseIntZero (ex.value);
		var y = parseIntZero (ey.value);
		ex.value = x;
		ey.value = y;
		
		document.getElementById(UID['tabWave_Distance']).innerHTML = getDistance(Seed.cities[CAPITAL_ID].x, Seed.cities[CAPITAL_ID].y, x, y);
		
		document.getElementById(UID['tabWave_Tile']).innerHTML = '&nbsp;';
		
		if (x < 0 || x > 749){
			if(x < 0){
				while (x < 0){
					x = 750 + x;
				}
			} else {
				while (x > 749){
					x = x - 750;
				}
			}
			ex.style.backgroundColor = 'red';
			return;
		}
		if (y < 0 || y > 749){
			if(y < 0){
				while (y < 0){
					y = 750 + y;
				}
			} else {
				while (y > 749){
					y = y - 750;
				}
			}
			ey.style.backgroundColor = 'red';
			return;
		}
		
		Data.options.waves.target.x = x;
		Data.options.waves.target.y = y;
		
		ey.style.backgroundColor = '';
		ex.style.backgroundColor = '';
		Map.getTargetByCoords(x, y, function(target){
			if (target){
				var cfeedBack = ''; // Jawz
				Data.options.waves.target.level = target.lvl;

				var attColor = target.isAtt ? '#000' : '#C22';

				// Jawz
				var type = target.type.substr(0,1).toUpperCase();
				if ((type == "H") || (type == "G") || (type == "L") || (type == "M") || (type == "N") || (type == "F") || (type == "S") || (type == "P")) type = 'W';
				// End Jawz

				var tile = '<font color='+attColor+'>'
					+'<b>'+ translate(target.type) +'&nbsp;'+ translate('Level') +'&nbsp;'+ target.lvl +'</b>'
					+'</font>';
				if(target.pName != undefined && type != 'W'){
					tile += '<br>'+ translate('City') + ': <b>' + target.name +'</b> - '
						+ translate('Alliance')+': <b>'+(target.pAlli != undefined ? target.pAlli : '----') + '</b>'
						+ '<br>'+ translate('Name') +': <b>'+ target.pName + '</b> - '
						+ translate('Level') + ': <b>' + target.pLvl + '</b> - '
						+ translate('Might') + ': <b>' + target.pMight + '</b>';
					cFeedBack = translate(target.type) + ' ' + target.pName + ' (' + nombreFormate(target.pMight) + ')' + (target.pAlli != undefined ? ' / '+target.pAlli : '');
				} else {  // JAwz
					cFeedBack = translate(target.type) + ' ' + translate('Level') + ' ' + target.lvl;
				}
				Data.options.waves.target.type = cFeedBack;
				// End Jawz
				
				document.getElementById(UID['tabWave_Tile']).innerHTML = tile;
			}
		});
	},

	show : function () {
		var t = Tabs.Waves;
		t.marchTick();
		switch (t.contentType) {
			case 0: t.tabWaveAttack(); break;
			case 1: t.tabWaveHistory(); break;
		}
	},
	hide : function (){
		var t = Tabs.Waves;
		clearTimeout (t.marchTimer);
		Data.options.waves.current_tab = t.contentType;
	}

};
//*********************************** Wave Tab *********************************************


// Jawz *********************************** Multi Tab *********************************************
Tabs.Multiple = {
	tabOrder	: MULTI_TAB_ORDER,
	tabLabel	: 'Multi',
	tabDisabled	: !MULTI_TAB_ENABLE,
	container	: null,
	enabled		: false,
	attackTimer	: null,
	marchTimer	: null,
	attackErrors: 0,
	running		: { start_at:0 },

	init : function (div) {
		var t = Tabs.Multiple;
		Data.setDefaultValues ('multiple');

		t.container = div;
		//var gensel = htmlSelector (generalList(0), '', 'id='+ setUID('tabMulti_GenSel'));
		var m = ''
		+'<div class=' + UID['title'] + '>'+ translate('Attack One Target in Multiple waves') +'</div>'
		+'<div id=' + setUID('tabMulti_Status') + ' class=' + UID['status_ticker'] + ' style="margin-bottom:5px !important">'
		+'	<center><input id=' + setUID('tabMulti_OnOff') + ' type=button value="OnOff" /></center>'
		+'	<div id=' + setUID('tabMulti_Report') + ' style="margin-top:5px;height:140px; max-height:140px; overflow-y:auto;">'
		+'		<table id=' + setUID('tabMulti_Marches') + ' class=' + UID['table'] + '></table>'
		+'	</div>'
		+'	<div id=' + setUID('tabMulti_Feedback') + ' class='+ UID['status_feedback'] +'></div>'
		+'</div>'
		+'<div class=' + UID['content'] + '>'
		+'	<div>'
		+'		<b>'+ translate('Coords') +':&nbsp;</b>&nbsp;'
		+'		X: <input id=' + setUID('tabMulti_CoordsX') + ' size=1 maxlength=3 type=text value="'+ Data.options.multiple.target.x +'" /> '
		+'		Y: <input id=' + setUID('tabMulti_CoordsY') + ' size=2 maxlength=3 type=text value="'+ Data.options.multiple.target.y +'" /> '
		+'		&nbsp <b>'+ translate('Distance') +':</b> <span id=' + setUID('tabMulti_Distance') + '></span><BR>'
		+'		<div class=' + UID['status_ticker'] + ' style="height:auto !important;margin:5px 10px !important;">'
		+'			<center><span id=' + setUID('tabMulti_Tile') + '></span></center>'
		+'		</div>'
		+'	</div>'
		+'  <div>'
		+'	<table id=' + setUID('tabMulti_Troops') + ' class=' + UID['table'] + '>'
		+'		<tr align=center class=' + UID['row_headers'] + '>'
		+'			<td colspan=8>'+ translate('Troops for Primary Attack') +':&nbsp;</td>'
		+'		</tr>'
		+'	</table><br>'
		+'	<table id=' + setUID('tabMulti_Troops2') + ' class=' + UID['table'] + '>'
		+'		<tr align=center class=' + UID['row_headers'] + '>'
		+'			<td colspan=8>'+ translate('Troops for Secondary Attacks') +':&nbsp;</td>'
		+'		</tr>'
		+'	</table>'
		+'	</div>'
		+'	<table class=' + UID['table'] + '>'
		+'		<tr>'
		+'			<td class=right> '+ translate('Include Great Dragon') +':&nbsp;</td>'
		+'			<td><input id=' + setUID('tabMulti_includeGD') + ' type=checkbox '+ (Data.options.multiple.include_great_dragon?'CHECKED':'') +' /></td>'
		+'		</tr><tr>'
		+'			<td class=right>&nbsp;</td>'
		+'		</tr><tr>'
		// End Jawz
		+'			<td class=right> '+ translate('Delete Battle Reports') +':&nbsp;</td>'
		+'			<td><input id=' + setUID('tabMulti_DelReports') + ' type=checkbox '+ (Data.options.multiple.delete_reports?'CHECKED':'') +' /></td>'
		+'		</tr><tr>'
		+'			<td class=right>'+ translate('Stop if any troops lost') +':&nbsp;</td>'
		+'			<td><input id=' + setUID('tabMulti_StopOnLoss') + ' type=checkbox '+ (Data.options.multiple.stop_on_loss?'CHECKED':'') +' /></td>'
		+'		</tr><tr>'
		+'			<td class=right>'+ translate('Delay Between Attacks') +':&nbsp;</td>'
		+'			<td>'
		+'				<input id=' + setUID('tabMulti_DelayMin') + ' type=text size=1 maxlength=4 value="'+ Data.options.multiple.delay_min +'" />'
		+'				 to <span id=' + setUID('tabMulti_DelayMax') + '>'+ Data.options.multiple.delay_max +'</span>&nbsp;'+ translate('Seconds')
		+'			</td>'
		// Jawz
		+'		</tr><tr>'
		+'			<td class=right> '+ translate('Maximum simultaneous marches') +':&nbsp;</td>'
		+'			<td><input id=' + setUID('tabMulti_MaxMarches') + ' type=text size=1 maxlength=2 value="'+ Data.options.multiple.max_marches +'" /></td>'
		// End Jawz
		+'		</tr>'
		+'	</table>'
		+'</div>'
		+'<div class=' + UID['status_ticker'] + ' style="margin-top:10px !important">'
		+'	<center><input id=' + setUID('tabMulti_ResetStats') + ' type=button value="'+ translate('Reset Stats') +'" /></center>'
		+'	<div id=' + setUID('tabMulti_Stats') + '  style="height:180px; max-height:180px; overflow-y:auto"></div>'
		+'	<hr class=thin>'
		+'	<div id=' + setUID('tabMulti_CurSpoil') + '> &nbsp; </div>'
		+'</div>';
		
		t.container.innerHTML = m;
		
		document.getElementById(UID['tabMulti_OnOff']).addEventListener ('click', function(){
			t.setMultiEnable(!Data.options.multiple.enabled);
		}, false);
		document.getElementById(UID['tabMulti_CoordsX']).addEventListener ('change', t.eventCoords, false);
		document.getElementById(UID['tabMulti_CoordsY']).addEventListener ('change', t.eventCoords, false);
		document.getElementById(UID['tabMulti_ResetStats']).addEventListener ('click', t.resetStats, false);
		document.getElementById(UID['tabMulti_includeGD']).addEventListener ('click', function(e){
			Data.options.multiple.include_great_dragon=e.target.checked;
		}, false);
		document.getElementById(UID['tabMulti_DelReports']).addEventListener ('click', function(e){
			Data.options.multiple.delete_reports=e.target.checked;
		}, false);
		document.getElementById(UID['tabMulti_StopOnLoss']).addEventListener ('click', function(e){
			Data.options.multiple.stop_on_loss=e.target.checked;
		}, false);

		document.getElementById(UID['tabMulti_DelayMin']).addEventListener ('change', delayChanged, false);
		document.getElementById(UID['tabMulti_MaxMarches']).addEventListener('change', maxMarchesChanged, false); // Jawz

		troopTable (document.getElementById(UID['tabMulti_Troops']), 1, 'PW', t.eventTroops);
		troopTable2 (document.getElementById(UID['tabMulti_Troops2']), 1, 'SW', t.eventTroops2);
		window.addEventListener('unload', t.onUnload, false);
		t.setMultiEnable (false);
		t.marchTick();
		t.eventCoords();
		t.dispStats();
		Messages.addBattleReportListener(t.gotBattleReport);

		function troopTable (tab, rownum, prefix, listener) {
			var t = Tabs.Multiple;
			var row =[];
			row.push(tab.insertRow(rownum));
			row.push(tab.insertRow(rownum+1));
			
			var val, c=0;
			for (var i=0; i < wave_unit_types.length; ++i)
			{
				row[0].insertCell(c).innerHTML = translate(Names.getTroopAbbr(wave_unit_types[i]));
				
				var inp = document.createElement ('input');
				inp.type = 'text';
				inp.size = '1';
				inp.style.width = '30px';
				inp.title = translate(wave_unit_types[i]);
				
				if (i < 3) {
					inp.style.border = '1px solid grey';
				} else if (i < 6) {
					inp.style.border = '1px solid green';
				} else {
					inp.style.border = '1px solid blue';
				}
				
				inp.maxlength = '6'; // Allow 100,000 troops to be sent
				
				if (prefix=='PW'){
					if (Data.options.multiple.target.primary_units[wave_unit_types[i]] == undefined){
						Data.options.multiple.target.primary_units[wave_unit_types[i]] = 0;
					}
					val = Data.options.multiple.target.primary_units[wave_unit_types[i]];
				}
				
				if (!val){
					val = 0;
				}
				
				inp.value = val;
				inp.name = prefix +'_'+ i;
				inp.addEventListener ('change', listener, false);
				
				row[1].insertCell(c).appendChild (inp);
				
				c = c + 1;
				
			}
			return tab;
		}
		
		function troopTable2 (tab, rownum, prefix, listener) {
			var t = Tabs.Multiple;
			var row =[];
			row.push(tab.insertRow(rownum));
			row.push(tab.insertRow(rownum+1));
			
			var val, c=0;
			for (var i=0; i < wave_unit_types.length; ++i)
			{
				row[0].insertCell(c).innerHTML = translate(Names.getTroopAbbr(wave_unit_types[i]));
				
				var inp = document.createElement ('input');
				inp.type = 'text';
				inp.size = '1';
				inp.style.width = '30px';
				inp.title = translate(wave_unit_types[i]);
				
				if (i < 2) {
					inp.style.border = '1px solid grey';
				} else if (i < 5) {
					inp.style.border = '1px solid green';
				} else {
					inp.style.border = '1px solid blue';
				}
				
				inp.maxlength = '6'; // Allow 100,000 troops to be sent
				
				if (prefix=='SW'){
					if (Data.options.multiple.target.secondary_units[wave_unit_types[i]] == undefined){
						Data.options.multiple.target.secondary_units[wave_unit_types[i]] = 0;
					}
					val = Data.options.multiple.target.secondary_units[wave_unit_types[i]];
					// Jawz
					if (Data.options.multiple.target.saved_units[wave_unit_types[i]] == undefined){
						Data.options.multiple.target.saved_units[wave_unit_types[i]] = 0;
					}
					val = Data.options.multiple.target.saved_units[wave_unit_types[i]];
					// End Jawz
				}
				
				if (!val){
					val = 0;
				}
				
				inp.value = val;
				inp.name = prefix +'_'+ i;
				inp.addEventListener ('change', listener, false);
				
				row[1].insertCell(c).appendChild (inp);
				
				c = c + 1;
				
			}
			return tab;
		}

		function delayChanged (e){
			var min = parseIntZero(e.target.value);
			var max = parseInt(min * 1.5);
			if (min < MIN_DELAY_BETWEEN_WAVE || min > 3600){
				// error dialog, etc ...
				e.target.style.backgroundColor = 'red';
				return;
			}
			document.getElementById(UID['tabMulti_DelayMax']).innerHTML = max;
			e.target.style.backgroundColor = '';
			Data.options.multiple.delay_min = min;
			Data.options.multiple.delay_max = max;
		}

		function maxMarchesChanged (e){
			var val = parseIntNan(document.getElementById(UID['tabMulti_MaxMarches']).value);
			if (val < 0 || val > Seed.cities[CAPITAL_ID].figures.marches.maximum){
				e.target.style.backgroundColor = 'red';
				return;
			}
			e.target.style.backgroundColor = '';
			Data.options.multiple.max_marches = val;
		} 
	},

	primarySent : 0,

	gotBattleReport : function (rpt_m){
		var t = Tabs.Multiple;
		if (!rpt_m) return;	// Jawz
		if (rpt_m.report.location.x == Data.options.multiple.target.x && 
			rpt_m.report.location.y == Data.options.multiple.target.y
			){
				if (!Data.stats.multiple.total_attacks || Data.stats.multiple.total_attacks == undefined) Data.stats.multiple.total_attacks = 0;
				++Data.stats.multiple.total_attacks;
				for (var i=0; i < rpt_m.report.spoils.items.length; i++){
					if ( !Data.stats.multiple.spoils[rpt_m.report.spoils.items[i]] )
					{
						Data.stats.multiple.spoils[rpt_m.report.spoils.items[i]] = 1;
					}
					else {
						++Data.stats.multiple.spoils[rpt_m.report.spoils.items[i]];
					}
					document.getElementById(UID['tabMulti_CurSpoil']).innerHTML = new Date().toTimeString().substring (0,8) +': '+ translate('Got') + ' '+ translate(rpt_m.report.spoils.items[i]);
				}
				t.dispStats();
				
				if (Data.options.multiple.stop_on_loss)
				{
					for (var p in rpt_m.report.attacker.units)
					{
						if (rpt_m.report.attacker.units[p][0] != rpt_m.report.attacker.units[p][1])
						{
							var ts = new Date(rpt_m.report_notification.created_at * 1000).myString();
							t.setMultiEnable (false);
							t.dispFeedback (translate('Troops lost') + '! (' + ts +')');
							actionLog (translate('Multi')+': '+translate('Troops lost')+'! ('+ ts +')');
							return;
						}
					}
				}
				if (Data.options.multiple.delete_reports && rpt_m.report.attacker.name == Seed.player.name){
					Messages.deleteMessage(rpt_m.report_notification.id);
				}
		}
	},

	resetStats : function (){
		var t = Tabs.Multiple;
		var now = serverTime();

		Data.stats.multiple = {
			start_at		: now,
			run_time		: 0,
			total_attacks	: 0,
			spoils			: {}
		};
		t.dispStats();
	},

	dispStats : function (){
		var t = Tabs.Multiple;
		var run_time = Data.stats.multiple.run_time;
		
		if (Data.options.multiple.enabled){
			run_time += (serverTime()-t.running.start_at);
		}
		
		var msg = '<table class=' + UID['table'] + ' width=100%>'
		+'	<tr>'
		+'		<td class=right>'+ translate('Run Time') +': </td>'
		+'		<td width=90%>'+ timestr(run_time, true) +'</td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Attacks') +': </td>'
		+'		<td>'+ Data.stats.multiple.total_attacks +'</td>'
		+'	</tr><tr>'
		+'		<td colspan=2><HR class=thin></td>'
		+'	</tr>';
		
		for (var p in Data.stats.multiple.spoils)
		{
			var num = Data.stats.multiple.spoils[p];
			var perHour = num / (run_time/3600);
			var item = Names.getItemAbbr(p);
			msg += '<tr>'
				+ '		<td class=right>'+ translate(item) +':</td>'
				+ '		<td>'+ num +' ('+ perHour.toFixed(2) +'&nbsp;'+ translate('per hour')+ ')</td>'
				+ '</tr>';
		}
		
		document.getElementById(UID['tabMulti_Stats']).innerHTML = msg + '</table>';
	},

	dispFeedback : function (msg){
		if (msg && msg!='')
		msg = new Date().toTimeString().substring (0,8) +' '+ msg;
		document.getElementById(UID['tabMulti_Feedback']).innerHTML = msg;
	},

	eventTroops : function (e){
		var t = Tabs.Multiple;
		var args = e.target.name.split ('_');
		if (args[0] == 'PW'){
			var tt = wave_unit_types[args[1]];
			var tr = Data.options.multiple.target.primary_units;
			tr[tt] = e.target.value;
		}
	},

	eventTroops2 : function (e){
		var t = Tabs.Multiple;
		var args = e.target.name.split ('_');
		if (args[0] == 'SW'){
			var tt = wave_unit_types[args[1]];
			var tr = Data.options.multiple.target.secondary_units;
			tr[tt] = e.target.value;
			// Jawz
			var tr = Data.options.multiple.target.saved_units;
			tr[tt] = e.target.value;
			// End Jawz
		}
	},

	setMultiEnable : function (onOff){
		var t = Tabs.Multiple;
		var but = document.getElementById(UID['tabMulti_OnOff']);
		clearTimeout (t.attackTimer);
		Data.options.multiple.enabled = onOff;
		if (onOff){
			but.value = translate('Attacking').toUpperCase();
			but.className = UID['btn_on'];
			t.multiAttackTick();
			t.running.start_at = serverTime();
			Data.stats.multiple.start_at = serverTime();
		} 
		else {
			but.value = translate('Disabled').toUpperCase();
			but.className = UID['btn_off'];
			if ( t.running.start_at !== 0 ){
				Data.stats.multiple.run_time += ( serverTime() - t.running.start_at );
			}
		}
	},

	onUnload : function (){
		var t = Tabs.Multiple;
		if (Data.options.multiple.enabled && t.running.start_at != 0){
			Data.stats.multiple.run_time += ( serverTime() - t.running.start_at );
		}
	},

	// For primary attack wave
	multiAttackTick : function (){
		var t = Tabs.Multiple, targetMsg, retryDelay, availableGeneral, multiUnits, marchCount = 0;
		clearTimeout (t.attackTimer);
		
		if (!Data.options.multiple.enabled){
			return;
		}    
		
		targetMsg = Data.options.multiple.target.type + translate(' at ') + Data.options.multiple.target.x +'/'+ Data.options.multiple.target.y;
		//targetMsg =  translate('level') + ' ' + Data.options.multiple.target.lvl + ' ' + Data.options.multiple.target.type + translate(' at ') + Data.options.multiple.target.x +'/'+ Data.options.multiple.target.y;

		var min_time = 700000;
		var max_time = 0;
		for (id in Seed.marches){
			++marchCount;
			var left_time = ( Seed.marches[id].run_at - parseInt(serverTime()) ) + (Seed.marches[id].status=='marching' ? Seed.marches[id].duration : 0);
			//fixed by Didi
			if (left_time > 0) {
				min_time = min_time < left_time ? min_time : left_time;
				max_time = max_time > left_time ? max_time : left_time;
			}
		}
		
		//fixed by Didi
		if ( min_time === 700000 || max_time === 0 ) {
			min_time = 3;
		}
		
		retryDelay = min_time + Math.randRange(2,5);
		//retryDelay = Math.floor(Math.random() * (-1) + 7);

		if (MyAjax.marchBusy > 0){
			MyAjax.marchBusy = marchCount;
			verboseLog(translate('Primary attack to ') + targetMsg + ' ' + translate('delayed due to pending march request') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('Another march request is pending') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			return;
		}
		if (marchCount >= Data.options.multiple.max_marches){
			verboseLog(translate('Primary attack to ') + targetMsg + ' ' + translate('delayed due to march limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('March limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
			return;
		}

		if (getMusterPointSlots(CAPITAL_ID) <= 0) {
			verboseLog(translate('Primary attack to ') + targetMsg + ' ' + translate('delayed due to muster point full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(translate('Muster Point Full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' '+translate('Seconds'));
			t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			return;
		}
		
		availableGeneral = getAvailableGeneral();
		if (availableGeneral === null) {
			verboseLog(translate('Primary attack to ') + targetMsg + ' ' + translate('delayed due to no available generals') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(translate('No generals available') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			return;
		}

		multiUnits = t.checkTroops(CAPITAL_ID, Data.options.multiple.target.primary_units);
		if (multiUnits !== null) {
			verboseLog(translate('Primary attack to ') + targetMsg + ' ' + translate('delayed due to') + ' ' + multiUnits + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(multiUnits + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			return;
		}
		
		if (t.primarySent == 0 || t.primarySent == null)
			t.primarySent = serverTime();
		// All prerequisite checks are done so march request can be sent
		verboseLog(translate('Primary attack to ') + targetMsg + ' '+translate('Attempted'));
		
		new MyAjax.marchSend (Seed.cities[CAPITAL_ID].id, Data.options.multiple.target.x, Data.options.multiple.target.y, availableGeneral.id, Data.options.multiple.target.primary_units, 'multiple', function (rslt) {
			var t = Tabs.Multiple, multiDelay, retryDelay;
			if (rslt.ok && rslt.dat.result.success) {
				Marches.add(rslt.dat.result.job.march_id, 'multiple');
				t.attackErrors = 0;
				multiDelay = Math.floor(Math.random() * (Data.options.multiple.delay_max - Data.options.multiple.delay_min + 1) + Data.options.multiple.delay_min);

				verboseLog(translate('Primary attack to ') + targetMsg + ' ' + translate('Successfully'));
				actionLog('<B>' + translate('Primary attack to ') + '</B>' + targetMsg);
				
				t.dispFeedback (translate('Primary attack to ') + targetMsg);

				//target.lastAttack = serverTime();
				t.attackTimer = setTimeout (t.multiAttackTick2, (multiDelay+10) * 1000);
			} else {
				t.attackErrors++
				retryDelay = 30 * (t.attackErrors * t.attackErrors);
				
				verboseLog(translate('Primary attack to ') + targetMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg+ ' - ' + translate('Retry in') + ' ' + retryDelay  + ' ' + translate('seconds'));
				actionLog('<B>' + translate('Primary attack to ') + '</B>' + targetMsg + ' ' + translate('failed'));

				if (rslt.status === 509){
					retryDelay = 600;
					verboseLog('<b>' + translate('Primary attack to ') + '</b> ' + targetMsg + ' ' + translate('failed') + ' - ' + translate('<b>Rate Limit Exceeded</b>, too many requests!') + ' - ' + translate('Retry in') + ' ' + retryDelay);
					t.dispFeedback(translate('Primary attack to ') + ' ' + targetMsg + ' ' + translate('failed')+' - '+translate('Rate Limit Exceeded because there were too many requests') + ' - ' + translate('Retry in') +' '+ retryDelay);
				} else
					t.dispFeedback(translate('Primary attack to ') + targetMsg + ' ' + translate('failed'));

				t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			} 
		});
	},

	// For secondary attack waves
	multiAttackTick2 : function (){
		var t = Tabs.Multiple, targetMsg, retryDelay, availableGeneral, multiUnits, marchCount = 0;
		clearTimeout (t.attackTimer);
		
		if (!Data.options.multiple.enabled){
			return;
		}    
		
		targetMsg = Data.options.multiple.target.type + translate(' at ') + Data.options.multiple.target.x +'/'+ Data.options.multiple.target.y;
		//targetMsg =  translate('level') + ' ' + Data.options.multiple.target.lvl + ' ' + Data.options.multiple.target.type + translate(' at ') + Data.options.multiple.target.x +'/'+ Data.options.multiple.target.y;

		var min_time = 700000;
		var max_time = 0;
		for (id in Seed.marches){
			++marchCount;
			var left_time = ( Seed.marches[id].run_at - parseInt(serverTime()) ) + (Seed.marches[id].status=='marching' ? Seed.marches[id].duration : 0);
			//fixed by Didi
			if (left_time > 0) {
				min_time = min_time < left_time ? min_time : left_time;
				max_time = max_time > left_time ? max_time : left_time;
			}
		}
		
		//fixed by Didi
		if ( min_time === 700000 || max_time === 0 ) {
			min_time = 3;
		}
		
		retryDelay = min_time + Math.randRange(2,5);
		//retryDelay = Math.floor(Math.random() * (-1) + 7);
		
		if (MyAjax.marchBusy > 0){
			MyAjax.marchBusy = marchCount;
			verboseLog(translate('Secondary attack to ') + targetMsg + ' ' + translate('delayed due to pending march request') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('Another march request is pending') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			return;
		}
		if (marchCount >= Data.options.multiple.max_marches){
			verboseLog(translate('Secondary attack to ') + targetMsg + ' ' + translate('delayed due to march limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('March limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
			return;
		}
		
		if (getMusterPointSlots(CAPITAL_ID) <= 0) {
			verboseLog(translate('Secondary attack to ') + targetMsg + ' ' + translate('delayed due to muster point full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(translate('Muster Point Full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' '+translate('Seconds'));
			t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			return;
		}
		
		availableGeneral = getAvailableGeneral();
		if (availableGeneral === null) {
			verboseLog(translate('Secondary attack to ') + targetMsg + ' ' + translate('delayed due to no available generals') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(translate('No generals available') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			return;
		}

		Data.options.multiple.target.secondary_units = cloneProps(Data.options.multiple.target.saved_units);
		multiUnits = t.checkTroops(CAPITAL_ID, Data.options.multiple.target.secondary_units);
		if (multiUnits !== null) {
			verboseLog(translate('Secondary attack to ') + targetMsg + ' ' + translate('delayed due to') + ' ' + multiUnits +': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(multiUnits + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			return;
		}
		
		if (Data.options.multiple.include_great_dragon) {
			var greatDrag = null;
			if ((greatDrag = getAvailableDragon ()) == null){
				verboseLog(translate('Secondary attack to ') + targetMsg + ' ' + translate('delayed due to no available Great Dragon') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
				t.dispFeedback(translate('No Great Dragon available') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
				t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
				return;
			}
			Data.options.multiple.target.secondary_units[greatDrag] = 1;
		}

		var timeSpentSinceFirstWave = parseInt(serverTime()) - t.primarySent;
		// For close target, if secondary waves are always sent (return before muster point full for instance), this allow to stop secondary waves, wait for defense respawn and resend primary attack.
		if (timeSpentSinceFirstWave > 210 && timeSpentSinceFirstWave < 270 ){
			t.dispFeedback (timestr(timeSpentSinceFirstWave,true) + translate(' spent. 2 min timeout (defense respawn)'));
			t.primarySent = null;
			t.attackTimer = setTimeout (t.multiAttackTick, 120000);
			return;
		}
		// For target at between 2min 15 and 2min 45 away, this is a particular case : First primary attack break the defense. Then several secondary waves follow...
		// Then after troups return, another primary attack is sent but before respawn. Then defense respawn occurs during secondary waves assaults.
		// So the following statements allow to stop the second wave of secondary attacks in order to avoid troups lost, by sending again a primary attack.
		if (timeSpentSinceFirstWave >= 270 && timeSpentSinceFirstWave < 330 ){
			t.dispFeedback (timestr(timeSpentSinceFirstWave,true) + translate(' spent. 1 min timeout (defense respawn)'));
			t.primarySent = null;
			t.attackTimer = setTimeout (t.multiAttackTick, 60000);
			return;
		}
		
		// All prerequisite checks are done so march request can be sent
		verboseLog(translate('Secondary attack to ') + targetMsg + ' '+translate('Attempted'));
		
		new MyAjax.marchSend (Seed.cities[CAPITAL_ID].id, Data.options.multiple.target.x, Data.options.multiple.target.y, availableGeneral.id, Data.options.multiple.target.secondary_units, 'multiple', function (rslt) {
			var t = Tabs.Multiple, multiDelay, retryDelay;
			if (rslt.ok && rslt.dat.result.success) {
				Marches.add(rslt.dat.result.job.march_id, 'multiple');
				t.attackErrors = 0;
				multiDelay = Math.floor(Math.random() * (Data.options.multiple.delay_max - Data.options.multiple.delay_min + 1) + Data.options.multiple.delay_min);

				verboseLog(translate('Secondary attack to ') + targetMsg + ' ' + translate('Successfully'));
				actionLog('<B>' + translate('Secondary attack to ') + '</B>' + targetMsg);
				
				t.dispFeedback (translate('Secondary attack to ') + targetMsg);

				//target.lastAttack = serverTime();
				if (Data.options.multiple.include_great_dragon)
					t.attackTimer = setTimeout (t.multiAttackTick, 60000);
				else
					t.attackTimer = setTimeout (t.multiAttackTick2, multiDelay * 1000);
			} else {
				t.attackErrors++
				retryDelay = 30 * (t.attackErrors * t.attackErrors);
				
				verboseLog(translate('Secondary attack to ') + targetMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg+ ' - ' + translate('Retry in') + ' ' + retryDelay  + ' ' + translate('seconds'));
				actionLog('<B>' + translate('Secondary attack to ') + '</B>' + targetMsg + ' ' + translate('failed'));

				if (rslt.status === 509){
					retryDelay = 600;
					verboseLog('<b>' + translate('Secondary attack to ') + '</b> ' + targetMsg + ' ' + translate('failed') + ' - ' + translate('<b>Rate Limit Exceeded</b>, too many requests!') + ' - ' + translate('Retry in') + ' ' + retryDelay);
					t.dispFeedback(translate('Secondary attack to ') + ' ' + targetMsg + ' ' + translate('failed')+' - '+translate('Rate Limit Exceeded because there were too many requests') + ' - ' + translate('Retry in') +' '+ retryDelay);
				} else
					t.dispFeedback(translate('Secondary attack to ') + targetMsg + ' ' + translate('failed'));

				t.attackTimer = setTimeout(t.multiAttackTick, retryDelay * 1000);
			} 
		});
	},

	// returns null if ok, else error message
	checkTroops : function (cityIdx, units){
		var totalTroops = 0;
		for (var p in units){
			if (units[p] > 0){
				totalTroops += units[p];
				if (Seed.cities[cityIdx].units[p] < units[p]){
					return (translate('Not enough') + ' ' + translate(p));
				}
			}
		}
		if (totalTroops <= 0){
			return (translate('No Troops Defined'));
		}
		return null;
	},

	marchTick : function (){
		var t = Tabs.Multiple;
		clearTimeout (t.marchTimer);
		Marches.updateTable ( document.getElementById(UID['tabMulti_Marches']), 'multiple' );
		t.marchTimer = setTimeout (t.marchTick, 1000);
	},
	
	// Calls Map.getTargetByCoords
	eventCoords : function (e){
		var ex = document.getElementById(UID['tabMulti_CoordsX']);
		var ey = document.getElementById(UID['tabMulti_CoordsY']);
		var x = parseIntZero (ex.value);
		var y = parseIntZero (ey.value);
		ex.value = x;
		ey.value = y;
		
		document.getElementById(UID['tabMulti_Distance']).innerHTML = getDistance(Seed.cities[CAPITAL_ID].x, Seed.cities[CAPITAL_ID].y, x, y);
		
		document.getElementById(UID['tabMulti_Tile']).innerHTML = '&nbsp;';
		
		if (x < 0 || x > 749){
			if(x < 0){
				while (x < 0){
					x = 750 + x;
				}
			} else {
				while (x > 749){
					x = x - 750;
				}
			}
			ex.style.backgroundColor = 'red';
			return;
		}
		if (y < 0 || y > 749){
			if(y < 0){
				while (y < 0){
					y = 750 + y;
				}
			} else {
				while (y > 749){
					y = y - 750;
				}
			}
			ey.style.backgroundColor = 'red';
			return;
		}
		
		Data.options.multiple.target.x = x;
		Data.options.multiple.target.y = y;
		
		ey.style.backgroundColor = '';
		ex.style.backgroundColor = '';
		Map.getTargetByCoords(x, y, function(target){
			if (target){
				var cfeedBack = ''; // Jawz
				Data.options.multiple.target.level = target.lvl;

				var attColor = target.isAtt ? '#000' : '#C22';

				var type = target.type.substr(0,1).toUpperCase();
				if ((type == "H") || (type == "G") || (type == "L") || (type == "M") || (type == "N") || (type == "F") || (type == "S") || (type == "P")) type = 'W';

				var tile = '<font color='+attColor+'>'
					+'<b>'+ translate(target.type) +'&nbsp;'+ translate('Level') +'&nbsp;'+ target.lvl +'</b>'
					+'</font>';
				if(target.pName != undefined && type != 'W'){
					tile += '<br>'+ translate('City') + ': <b>' + target.name +'</b> - '
						+ translate('Alliance')+': <b>'+(target.pAlli != undefined ? target.pAlli : '----') + '</b>'
						+ '<br>'+ translate('Name') +': <b>'+ target.pName + '</b> - '
						+ translate('Level') + ': <b>' + target.pLvl + '</b> - '
						+ translate('Might') + ': <b>' + target.pMight + '</b>';
					cFeedBack = translate(target.type) + ' ' + target.pName + ' (' + nombreFormate(target.pMight) + ')' + (target.pAlli != undefined ? ' / '+target.pAlli : '');
				} else {  // JAwz
					cFeedBack = translate(target.type) + ' ' + translate('Level') + ' ' + target.lvl;
				}
				Data.options.multiple.target.type = cFeedBack;
				// End Jawz

				document.getElementById(UID['tabMulti_Tile']).innerHTML = tile;
			}
		});
	},


	show : function () {
		var t = Tabs.Multiple;
		t.marchTick();
	},
	hide : function (){
		var t = Tabs.Multiple;
		clearTimeout (t.marchTimer);
	}

}
// Jawz *********************************** Multi Tab *********************************************


// Jawz *********************************** Spy Tab *********************************************
Tabs.Spies = {
	tabOrder	: SPY_TAB_ORDER,
	tabLabel	: 'Spy',
	tabDisabled	: !SPY_TAB_ENABLE,
	container	: null,
	enabled		: false,
	attackTimer	: null,
	marchTimer	: null,
	attackErrors: 0,
	running		: { start_at:0 },

	init : function (div) {
		var t = Tabs.Spies;
		Data.setDefaultValues ('spies');

		t.container = div;
		var m = ''
		+'<div class=' + UID['title'] + '>'+ translate('Spy One Target') +'</div>'
		+'<div id=' + setUID('tabSpy_Status') + ' class=' + UID['status_ticker'] + ' style="margin-bottom:5px !important">'
		+'	<center><input id=' + setUID('tabSpy_OnOff') + ' type=button value="OnOff" /></center>'
		+'	<div id=' + setUID('tabSpy_Report') + ' style="margin-top:5px;height:140px; max-height:140px; overflow-y:auto;">'
		+'		<table id=' + setUID('tabSpy_Marches') + ' class=' + UID['table'] + '></table>'
		+'	</div>'
		+'	<div id=' + setUID('tabSpy_Feedback') + ' class='+ UID['status_feedback'] +'></div>'
		+'</div>'
		+'<div class=' + UID['content'] + '>'
		+'	<div>'
		+'		<b>'+ translate('Coords') +':&nbsp;</b>&nbsp;'
		+'		X: <input id=' + setUID('tabSpy_CoordsX') + ' size=1 maxlength=3 type=text value="'+ Data.options.spies.target.x +'" /> '
		+'		Y: <input id=' + setUID('tabSpy_CoordsY') + ' size=2 maxlength=3 type=text value="'+ Data.options.spies.target.y +'" /> '
		+'		&nbsp <b>'+ translate('Distance') +':</b> <span id=' + setUID('tabSpy_Distance') + '></span><BR>'
		+'		<div class=' + UID['status_ticker'] + ' style="height:auto !important;margin:5px 10px !important;">'
		+'			<center><span id=' + setUID('tabSpy_Tile') + '></span></center>'
		+'		</div>'
		+'	</div>'
		+'  <div>'
		+'	<table id=' + setUID('tabSpy_Troops') + ' class=' + UID['table'] + '>'
		+'		<tr align=center class=' + UID['row_headers'] + '>'
		+'			<td colspan=8>'+ translate('Spies number') +':&nbsp;</td>'
		+'		</tr>'
		+'	</table>'
		+'	</div>'
		+'	<br>'
		+'	<table class=' + UID['table'] + '>'
		+'		<tr>'
		+'			<td class=right> '+ translate('Delete spy reports') +':&nbsp;</td>'
		+'			<td><input id=' + setUID('tabSpy_DelReports') + ' type=checkbox '+ (Data.options.spies.delete_reports?'CHECKED':'') +' /></td>'
		+'		</tr><tr>'
		+'			<td class=right>'+ translate('Stop if any troops lost') +':&nbsp;</td>'
		+'			<td><input id=' + setUID('tabSpy_StopOnLoss') + ' type=checkbox '+ (Data.options.spies.stop_on_loss?'CHECKED':'') +' /></td>'
		+'		</tr><tr>'
		+'			<td class=right>'+ translate('Delay Between Attacks') +':&nbsp;</td>'
		+'			<td>'
		+'				<input id=' + setUID('tabSpy_DelayMin') + ' type=text size=1 maxlength=4 value="'+ Data.options.spies.delay_min +'" />'
		+'				 to <span id=' + setUID('tabSpy_DelayMax') + '>'+ Data.options.spies.delay_max +'</span>&nbsp;'+ translate('Seconds')
		+'			</td>'
		// Jawz
		+'		</tr><tr>'
		+'			<td class=right> '+ translate('Maximum simultaneous marches') +':&nbsp;</td>'
		+'			<td><input id=' + setUID('tabSpy_MaxMarches') + ' type=text size=1 maxlength=2 value="'+ Data.options.spies.max_marches +'" /></td>'
		// End Jawz
		+'		</tr>'
		+'	</table>'
		+'</div>'
		+'<div class=' + UID['status_ticker'] + ' style="margin-top:10px !important">'
		+'	<center><input id=' + setUID('tabSpy_ResetStats') + ' type=button value="'+ translate('Reset Stats') +'" /></center>'
		+'	<div id=' + setUID('tabSpy_Stats') + '  style="height:200px; max-height:200px; overflow-y:auto"></div>'
		+'	<hr class=thin>'
		+'	<div id=' + setUID('tabSpy_CurSpoil') + '> &nbsp; </div>'
		+'</div>';
		
		t.container.innerHTML = m;
		
		document.getElementById(UID['tabSpy_OnOff']).addEventListener ('click', function(){
			t.setSpyEnable(!Data.options.spies.enabled);
		}, false);
		document.getElementById(UID['tabSpy_CoordsX']).addEventListener ('change', t.eventCoords, false);
		document.getElementById(UID['tabSpy_CoordsY']).addEventListener ('change', t.eventCoords, false);
		document.getElementById(UID['tabSpy_ResetStats']).addEventListener ('click', t.resetStats, false);
		document.getElementById(UID['tabSpy_DelReports']).addEventListener ('click', function(e){
			Data.options.spies.delete_reports=e.target.checked;
		}, false);
		document.getElementById(UID['tabSpy_StopOnLoss']).addEventListener ('click', function(e){
			Data.options.spies.stop_on_loss=e.target.checked;
		}, false);

		document.getElementById(UID['tabSpy_DelayMin']).addEventListener ('change', delayChanged, false);
		document.getElementById(UID['tabSpy_MaxMarches']).addEventListener('change', maxMarchesChanged, false); // Jawz

		troopTable (document.getElementById(UID['tabSpy_Troops']), 1, 'SP', t.eventTroops);

		window.addEventListener('unload', t.onUnload, false);
		t.setSpyEnable (false);
		t.marchTick();
		t.eventCoords();
		t.dispStats();
		Messages.addBattleReportListener(t.gotBattleReport);

		function troopTable (tab, rownum, prefix, listener) {
			var t = Tabs.Spies;
			var row =[];
			row.push(tab.insertRow(rownum));
			row.push(tab.insertRow(rownum+1));
			
			var val, c=0;
			for (var i=0; i < spy_unit_types.length; ++i)
			{
				row[0].insertCell(c).innerHTML = translate(Names.getTroopAbbr(spy_unit_types[i]));
				
				var inp = document.createElement ('input');
				inp.type = 'text';
				inp.size = '1';
				inp.style.width = '30px';
				inp.title = translate(spy_unit_types[i]);
				inp.style.border = '1px solid grey';
				inp.maxlength = '6'; // Allow 100,000 troops to be sent
				if (prefix=='SP'){
					if (Data.options.spies.target.units[spy_unit_types[i]] == undefined){
						Data.options.spies.target.units[spy_unit_types[i]] = 0;
					}
					val = Data.options.spies.target.units[spy_unit_types[i]];
				}
				
				if (!val){
					val = 0;
				}
				
				inp.value = val;
				inp.name = prefix +'_'+ i;
				inp.addEventListener ('change', listener, false);
				
				row[1].insertCell(c).appendChild (inp);
				
				c = c + 1;
				
			}
			return tab;
		}
		
		function delayChanged (e){
			var min = parseIntZero(e.target.value);
			var max = parseInt(min * 1.5);
			if (min < MIN_DELAY_BETWEEN_WAVE || min > 3600){
				// error dialog, etc ...
				e.target.style.backgroundColor = 'red';
				return;
			}
			document.getElementById(UID['tabSpy_DelayMax']).innerHTML = max;
			e.target.style.backgroundColor = '';
			Data.options.spies.delay_min = min;
			Data.options.spies.delay_max = max;
		}

		function maxMarchesChanged (e){
			var val = parseIntNan(document.getElementById(UID['tabSpy_MaxMarches']).value);
			if (val < 0 || val > Seed.cities[CAPITAL_ID].figures.marches.maximum){
				e.target.style.backgroundColor = 'red';
				return;
			}
			e.target.style.backgroundColor = '';
			Data.options.spies.max_marches = val;
		} 
	},

	gotBattleReport : function (rpt_s){
		var t = Tabs.Spies;
		if (!rpt_s) return;	// Jawz
		if (rpt_s.report.location.x == Data.options.spies.target.x && 
			rpt_s.report.location.y == Data.options.spies.target.y
			){
				if (!Data.stats.spies.total_attacks || Data.stats.spies.total_attacks == undefined) Data.stats.spies.total_attacks = 0; // Jawz
				++Data.stats.spies.total_attacks;
				t.dispStats();
				
				if (Data.options.spies.stop_on_loss)
				{
					for (var p in rpt_s.report.attacker.units)
					{
						if (rpt_s.report.attacker.units[p][0] != rpt_s.report.attacker.units[p][1])
						{
							var ts = new Date(rpt_s.report_notification.created_at * 1000).myString();
							t.setSpyEnable (false);
							t.dispFeedback (translate('Troops lost') + '! (' + ts +')');
							actionLog (translate('Spy')+': '+translate('Troops lost')+'! ('+ ts +')');
							return;
						}
					}
				}
				if (Data.options.spies.delete_reports && rpt_s.report.attacker.name == Seed.player.name){
					Messages.deleteMessage(rpt_s.report_notification.id);
				}
		}
	},

	resetStats : function (){
		var t = Tabs.Spies;
		var now = serverTime();

		Data.stats.spies = {
			start_at		: now,
			run_time		: 0,
			total_attacks	: 0
		};
		t.dispStats();
	},

	dispStats : function (){
		var t = Tabs.Spies;
		var run_time = Data.stats.spies.run_time;
		
		if (Data.options.spies.enabled){
			run_time += (serverTime()-t.running.start_at);
		}
		
		var msg = '<table class=' + UID['table'] + ' width=100%>'
		+'	<tr>'
		+'		<td class=right>'+ translate('Run Time') +': </td>'
		+'		<td width=90%>'+ timestr(run_time, true) +'</td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Spies done') +': </td>'
		+'		<td>'+ Data.stats.spies.total_attacks +'</td>'
		+'	</tr><tr>'
		+'		<td colspan=2><HR class=thin></td>'
		+'	</tr>';
		document.getElementById(UID['tabSpy_Stats']).innerHTML = msg + '</table>';
	},

	dispFeedback : function (msg){
		if (msg && msg!='')
		msg = new Date().toTimeString().substring (0,8) +' '+ msg;
		document.getElementById(UID['tabSpy_Feedback']).innerHTML = msg;
	},

	eventTroops : function (e){
		var t = Tabs.Spies;
		var args = e.target.name.split ('_');
		if (args[0] == 'SP'){
			var tt = spy_unit_types[args[1]];
			var tr = Data.options.spies.target.units;
			tr[tt] = e.target.value;
		}
	},

	setSpyEnable : function (onOff){
		var t = Tabs.Spies;
		var but = document.getElementById(UID['tabSpy_OnOff']);
		clearTimeout (t.attackTimer);
		Data.options.spies.enabled = onOff;
		if (onOff){
			but.value = translate('Attacking').toUpperCase();
			but.className = UID['btn_on'];
			t.spyAttackTick();
			t.running.start_at = serverTime();
			Data.stats.spies.start_at = serverTime();
		} else {
			but.value = translate('Disabled').toUpperCase();
			but.className = UID['btn_off'];
			if ( t.running.start_at !== 0 ){
				Data.stats.spies.run_time += ( serverTime() - t.running.start_at );
			}
		}
	},

	onUnload : function (){
		var t = Tabs.Spies;
		if (Data.options.spies.enabled && t.running.start_at != 0){
			Data.stats.spies.run_time += ( serverTime() - t.running.start_at );
		}
	},


	spyAttackTick : function (){
		var t = Tabs.Spies, targetMsg, retryDelay, availableGeneral, spyUnits, marchCount = 0;
		clearTimeout (t.attackTimer);
		
		if (!Data.options.spies.enabled){
			return;
		}    
		
		targetMsg = Data.options.spies.target.type + translate(' at ') + Data.options.spies.target.x +'/'+ Data.options.spies.target.y;
		//targetMsg =  translate('level') + ' ' + Data.options.spies.target.lvl + ' ' + Data.options.spies.target.type + translate(' at ') + Data.options.spies.target.x +'/'+ Data.options.spies.target.y;

		var min_time = 700000;
		var max_time = 0;
		for (id in Seed.marches){
			++marchCount;
			var left_time = ( Seed.marches[id].run_at - parseInt(serverTime()) ) + (Seed.marches[id].status=='marching' ? Seed.marches[id].duration : 0);
			//fixed by Didi
			if (left_time > 0) {
				min_time = min_time < left_time ? min_time : left_time;
				max_time = max_time > left_time ? max_time : left_time;
			}
		}
		
		//fixed by Didi
		if ( min_time === 700000 || max_time === 0 ) {
			min_time = 3;
		}
		
		retryDelay = min_time + Math.randRange(2,5);
		//retryDelay = Math.floor(Math.random() * (-1) + 7);
		
		if (MyAjax.marchBusy > 0){
			MyAjax.marchBusy = marchCount;
			verboseLog(translate('Spy to ') + targetMsg + ' ' + translate('delayed due to pending march request') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('Another march request is pending') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.spyAttackTick, retryDelay * 1000);
			return;
		}
		if (marchCount >= Data.options.spies.max_marches){
			verboseLog(translate('Spy to ') + targetMsg + ' ' + translate('delayed due to march limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('March limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.waveAttackTick, retryDelay * 1000);
			return;
		}
		
		if (getMusterPointSlots(CAPITAL_ID) <= 0) {
			verboseLog(translate('Spy to ') + targetMsg + ' ' + translate('delayed due to muster point full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(translate('Muster Point Full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' '+translate('Seconds'));
			t.attackTimer = setTimeout(t.spyAttackTick, retryDelay * 1000);
			return;
		}
		
		spyUnits = t.checkTroops(CAPITAL_ID, Data.options.spies.target.units);
		if (spyUnits !== null) {
			verboseLog(translate('Spy to ') + targetMsg + ' ' + translate('delayed due to') + ' ' + spyUnits + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
			t.dispFeedback(spyUnits + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.spyAttackTick, retryDelay * 1000);
			return;
		}
		
		// All prerequisite checks are done so march request can be sent
		verboseLog(translate('Spy to ') + targetMsg + ' '+translate('Attempted'));
		
		new MyAjax.marchSpy (Seed.cities[CAPITAL_ID].id, Data.options.spies.target.x, Data.options.spies.target.y, Data.options.spies.target.units, 'spies', function (rslt) {
			var t = Tabs.Spies, spyDelay, retryDelay;
			if (rslt.ok && rslt.dat.result.success) {
				Marches.add(rslt.dat.result.job.march_id, 'spies');
				t.attackErrors = 0;
				spyDelay = Math.floor(Math.random() * (Data.options.spies.delay_max - Data.options.spies.delay_min + 1) + Data.options.spies.delay_min);

				verboseLog(translate('Spy to ') + targetMsg + ' ' + translate('Successfully'));
				actionLog('<B>' + translate('Spy to ') + '</B>' + targetMsg);
				
				t.dispFeedback (translate('Spy to ') + targetMsg);

				//target.lastAttack = serverTime();
				t.attackTimer = setTimeout (t.spyAttackTick, spyDelay * 1000);
			} else {
				t.attackErrors++
				retryDelay = 30 * (t.attackErrors * t.attackErrors);
				
				verboseLog(translate('Spy to ') + targetMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg+ ' - ' + translate('Retry in') + ' ' + retryDelay  + ' ' + translate('seconds'));
				actionLog('<B>' + translate('Spy to ') + '</B>' + targetMsg + ' ' + translate('failed'));

				if (rslt.status === 509){
					retryDelay = 600;
					verboseLog('<b>' + translate('Spy to ') + '</b> ' + targetMsg + ' ' + translate('failed') + ' - ' + translate('<b>Rate Limit Exceeded</b>, too many requests!') + ' - ' + translate('Retry in') + ' ' + retryDelay);
					t.dispFeedback(translate('Spy to ') + ' ' + targetMsg + ' ' + translate('failed')+' - '+translate('Rate Limit Exceeded because there were too many requests') + ' - ' + translate('Retry in') +' '+ retryDelay);
				} else
					t.dispFeedback(translate('Spy to ') + targetMsg + ' ' + translate('failed'));

				t.attackTimer = setTimeout(t.spyAttackTick, retryDelay * 1000);
			} 
		});
	},

	// returns null if ok, else error message
	checkTroops : function (cityIdx, units){
		var totalTroops = 0;
		for (var p in units){
			if (units[p] > 0){
				totalTroops += units[p];
				if (Seed.cities[cityIdx].units[p] < units[p]){
					return (translate('Not enough') + ' ' + translate(p));
				}
			}
		}
		if (totalTroops <= 0){
			return (translate('No Troops Defined'));
		}
		return null;
	},

	marchTick : function (){
		var t = Tabs.Spies;
		clearTimeout (t.marchTimer);
		Marches.updateTable ( document.getElementById(UID['tabSpy_Marches']), 'spies' );
		t.marchTimer = setTimeout (t.marchTick, 1000);
	},
	
	// Calls Map.getTargetByCoords
	eventCoords : function (e){
		var ex = document.getElementById(UID['tabSpy_CoordsX']);
		var ey = document.getElementById(UID['tabSpy_CoordsY']);
		var x = parseIntZero (ex.value);
		var y = parseIntZero (ey.value);
		ex.value = x;
		ey.value = y;
		
		document.getElementById(UID['tabSpy_Distance']).innerHTML = getDistance(Seed.cities[CAPITAL_ID].x, Seed.cities[CAPITAL_ID].y, x, y);
		
		document.getElementById(UID['tabSpy_Tile']).innerHTML = '&nbsp;';
		
		if (x < 0 || x > 749){
			if(x < 0){
				while (x < 0){
					x = 750 + x;
				}
			} else {
				while (x > 749){
					x = x - 750;
				}
			}
			ex.style.backgroundColor = 'red';
			return;
		}
		if (y < 0 || y > 749){
			if(y < 0){
				while (y < 0){
					y = 750 + y;
				}
			} else {
				while (y > 749){
					y = y - 750;
				}
			}
			ey.style.backgroundColor = 'red';
			return;
		}
		
		Data.options.spies.target.x = x;
		Data.options.spies.target.y = y;
		
		ey.style.backgroundColor = '';
		ex.style.backgroundColor = '';
		Map.getTargetByCoords(x, y, function(target){
			if (target){
				var cfeedBack = ''; // Jawz
				Data.options.spies.target.level = target.lvl;

				var attColor = target.isAtt ? '#000' : '#C22';

				var type = target.type.substr(0,1).toUpperCase();
				if ((type == "H") || (type == "G") || (type == "L") || (type == "M") || (type == "N") || (type == "F") || (type == "S") || (type == "P")) type = 'W';

				var tile = '<font color='+attColor+'>'
					+'<b>'+ translate(target.type) +'&nbsp;'+ translate('Level') +'&nbsp;'+ target.lvl +'</b>'
					+'</font>';
				if(target.pName != undefined && type != 'W'){
					tile += '<br>'+ translate('City') + ': <b>' + target.name +'</b> - '
						+ translate('Alliance')+': <b>'+(target.pAlli != undefined ? target.pAlli : '----') + '</b>'
						+ '<br>'+ translate('Name') +': <b>'+ target.pName + '</b> - '
						+ translate('Level') + ': <b>' + target.pLvl + '</b> - '
						+ translate('Might') + ': <b>' + target.pMight + '</b>';
					cFeedBack = translate(target.type) + ' ' + target.pName + ' (' + nombreFormate(target.pMight) + ')' + (target.pAlli != undefined ? ' / '+target.pAlli : '');
				} else {  // JAwz
					cFeedBack = translate(target.type) + ' ' + translate('Level') + ' ' + target.lvl;
				}
				Data.options.spies.target.type = cFeedBack;
				// End Jawz

				document.getElementById(UID['tabSpy_Tile']).innerHTML = tile;
			}
		});
	},


	show : function () {
		var t = Tabs.Spies;
		t.marchTick();
	},
	hide : function (){
		var t = Tabs.Spies;
		clearTimeout (t.marchTimer);
	}

}
// Jawz *********************************** Spy Tab *********************************************


//*********************************** Attacks Tab *********************************************
// References to camp and camps changed to mapObject to make sure that other data does not overwrite the camps
Tabs.Attacks = {
	tabOrder		: ATTACK_TAB_ORDER,
	tabLabel		: 'Attacks',
	tabDisabled		: !ATTACK_TAB_ENABLE,
	lastSubTab		: 'tabAttackLevels',
	container		: null,
	attackTimer		: null,
	marchTimer		: null,
	lastAttack		: 0,
	attackErrors	: 0,
	checkMapBusy	: false,
	MAX_DISTANCE	: 60,
	curRunStart		: 0,
	contentType		: 0, // 0 = levels, 1 = config, 2 = targets, 3 = stats, 4 = mapTypes these should be enums but Javascript doesn't support that type
	selectedMapName	: kAnthropusCamp,

	init : function (div){
		var t = Tabs.Attacks;
		t.container = div;
		
		Data.setDefaultValues ('attacks');

		div.innerHTML = ''
		+'<div id='+setUID('tabAttack_Title')+' class=' + UID['title'] + '>' + translate('Attack') + ' ' + translate(Data.options.attacks.choice) + ' </div>'
		+'<div class=' + UID['status_ticker'] + ' id='+ setUID('tabAttack_Status') +' style="margin-bottom:5px !important">'
		+'	<center><input type=button value="OnOff" id='+ setUID('tabAttack_OnOff') +' /></center>'
		+'	<div id='+ setUID('tabAttack_Report') +' style="margin-top:5px;height:140px; max-height:140px; overflow:auto;">'
		+'		<table id=' + setUID('tabAttack_Marches') + ' class=' + UID['table'] + '></table>'
		+'	</div>'
		+'	<div id='+ setUID('tabAttack_Feedback') +' class='+ UID['status_feedback'] +'></div>'
		+'</div>'
		+'<ul class=tabs>'
		+'	<li class="tab first"><a id='+ setUID('tabAttackLevels') +'>'+ translate('Levels') +'</a></li>'
		+'	<li class=tab><a id='+ setUID('tabAttackTarget') +'>'+ translate('Targets') +'</a></li>'
		+'	<li class=tab><a id='+ setUID('tabAttackStats') +'>'+ translate('Statistics') +'</a></li>'
		+'	<li class=tab><a id='+ setUID('tabAttackMaps') +'>'+ translate('Map') +'</a></li>'
		+'	<li class=tab><a id='+ setUID('tabAttackConfig') +'>'+ translate('Config') +'</a></li>'
		+'</ul>'
		+'<div id='+ setUID('tabAttack_Content') +' style="padding-top:0px; height:480px; overflow-y:auto"></div>'; // Jawz - height set to 480 instead of 400, added overflow-y, set padding-top to 0px and removed background
		

		// Add the event listeners
		document.getElementById(UID['tabAttack_OnOff']).addEventListener ('click', function (){
			t.setAttackEnable (!Data.options.attacks.enabled);
		}, false);
		document.getElementById(UID['tabAttackLevels']).addEventListener ('click', t.tabAttackLevels, false);
		document.getElementById(UID['tabAttackConfig']).addEventListener ('click', t.tabAttackConfig, false);
		document.getElementById(UID['tabAttackTarget']).addEventListener ('click', t.tabAttackTarget, false);
		document.getElementById(UID['tabAttackStats']).addEventListener ('click', t.tabAttackStats, false);
		document.getElementById(UID['tabAttackMaps']).addEventListener ('click', t.tabAttackMaps, false);
		
		if (Data.stats.attacks == null){
			t.clearStats();
		}
		
		Messages.addBattleReportListener(t.gotBattleReport);
		setTimeout (Marches.check, 60000);
		t.tabAttackLevels();
		window.addEventListener ('unload', t.onUnload, false);
		t.setAttackEnable (Data.options.attacks.enabled);
	},

	firstShow : true,
	show : function () {
		var t = Tabs.Attacks;
		t.marchTick();
/*		if (t.firstShow){
			t.marchTick();
			setTimeout (function (){
				// Do not automatically scan the map, wait for the user to initiate the scan on the maps sub-tab
				//t.checkMapData();
				t.firstShow = false;
			}, 0);
		}
*/		Data.options.attacks.current_tab = (t.contentType || Data.options.attacks.current_tab);
		if (t.contentType == 2){
			document.getElementById(UID['tabAttack_Content']).scrollTop = gAttScrollPos;
		}

		switch (t.contentType) {
			case 0: t.tabAttackLevels(); break;
			case 1: t.tabAttackConfig(); break;
			case 2: t.tabAttackTarget(); break;
			case 3: t.tabAttackStats(); break;
			case 4: t.tabAttackMaps(); break;
		}
	},
	hide : function (){
		var t = Tabs.Attacks;
		clearTimeout (t.marchTimer);
	},

	onUnload : function () {
		logit('Tabs.Attacks.onUnload');
		var t = Tabs.Attacks;
		if (Data.options.attacks.enabled){
			Data.stats.attacks.run_time += (serverTime()-t.curRunStart);
		}
		Data.options.attacks.current_tab = t.contentType;
	},

	checkMapData : function () {
		var t = Tabs.Attacks;
		
		if (t.checkMapBusy){
			return false;
		}
		else if (Data.map.terrains[kAnthropusCamp].length==0) {
		
			t.checkMapBusy = true;
			
			t.setAttackEnable (false);
			
			Data.options.attacks.choice = kAnthropusCamp;

			var x = Data.map.position.x;
			var y = Data.map.position.y;
			var radius = 15;

			var steps = parseInt(Math.pow (parseInt(((radius*2)+14)/15),2));
			progressBar.init (800+Math.randRange(1,50), 100, 300, 150, translate('Message'), 200, true, t.container);
			progressBar.start({ steps:steps, delay:1, byCount:true, title:translate('Scanning map')+'...', stepText:translate('Please wait...') });

			Map.scanMap (x,y, radius, function(res){
				if (res == null){
					progressBarPop.getContentDiv().innerHTML = '<B>' + translate('Bummer, there was an error while scanning the map') + '.</B>';
					progressBarPop.allowClose (true);
					Tabs.Attacks.checkMapBusy = false;
					return;
				}
				if(res.done){
					actionLog('<B>scanMap</B>: '+ translate('complete'));
					// Sort by Distance
					for (var type in Data.map.terrains){
						Map.sortByDist(Data.map.terrains,type);
					}

					Tabs.Attacks.checkMapBusy = false;
					progressBarPop.destroy();

					// Refresh the Tab Content
					t.tabAttackTarget();
				}
			});
			return false;
		}
		return true;
	},

	gotBattleReport : function (rpt_a){
		var t = Tabs.Attacks;
		// tie report to march id ...
		if (!rpt_a) return;	// Jawz
		var march_id = null;
		for (var id in Data.marches.attacks )
		{
			var march = Data.marches.attacks[id];
			
			if (march.x === rpt_a.report.location.x && 
				march.y === rpt_a.report.location.y &&
				march.general.id === rpt_a.report.attacker.general.id
				){  // TODO: time and units check here
					march_id = id;
					break;
			}
		}

		if (march_id && march_id != null) {
			t.trackStats (march_id, rpt_a);
		}

		//fetchPlayer when new item (Didi modif)
		var items = rpt_a.report.spoils.items;
		if (items.length !== 0) {
			// Don't fetch Cities, only player.json
			Seed.fetchPlayer ( {noCities:true} ); 
		}

		if (!Data.options.attacks.delete_reports && !Data.options.attacks.stop_on_loss ){
			return;
		}
		//logit (inspectObj (rpt_a, 8, 1));
		if (Data.options.attacks.stop_on_loss)
		{
			for (var p in rpt_a.report.attacker.units)
			{
				if (rpt_a.report.attacker.units[p][0] != rpt_a.report.attacker.units[p][1])
				{
					var ts = new Date(rpt_a.report_notification.created_at * 1000).myString();
					t.abort (translate('Troops lost') +'! ('+ ts +')');
					return;
				}
			}
		}
		if (Data.options.attacks.delete_reports && rpt_a.report.attacker.name == Seed.player.name){
			Messages.deleteMessage (rpt_a.report_notification.id);
		}
	},

	setAttackEnable : function (onOff){
		var t = Tabs.Attacks;
		clearTimeout (t.attackTimer);
		var but = document.getElementById(UID['tabAttack_OnOff']);
		Data.options.attacks.enabled = onOff;
		if (onOff){
			but.value = translate('Attacking').toUpperCase();
			but.className = UID['btn_on'];
			t.curRunStart = serverTime();
			t.autoCheckTargets();
		} 
		else {
			if (t.curRunStart != 0)
			Data.stats.attacks.run_time += (serverTime()-t.curRunStart);
			but.value = translate('Disabled').toUpperCase();
			but.className = UID['btn_off'];
			t.dispFeedback ('');
		}
	},

	abort : function (msg){
		var t = Tabs.Attacks;
		t.setAttackEnable (false);
		t.dispFeedback (msg);
		actionLog (msg);
	},

	marchTick : function (){
		var t = Tabs.Attacks;
		clearTimeout (t.marchTimer);
		Marches.updateTable ( document.getElementById(UID['tabAttack_Marches']), 'attacks' );
		t.marchTimer = setTimeout (t.marchTick, 1000);
	},

	dispFeedback : function (msg){
		if (msg && msg!=''){
			msg = new Date().toTimeString().substring (0,8) +'&nbsp;'+ msg;
		}
		document.getElementById(UID['tabAttack_Feedback']).innerHTML = msg;
	},

	autoCheckTargets : function (){
		var t = Tabs.Attacks;
		var now = serverTime();
		var cityIdx = CAPITAL_ID;
		var targetMsg, retryDelay, availableGeneral, marchCount = 0, p;
		
		clearTimeout (t.attackTimer);
		
		targetMsg = ''; 
		
		// Don't do anything if attacks are not enabled
		if (!Data.options.attacks.enabled){
			return;
		}

		var min_time = 700000;
		var max_time = 0;
		for (id in Seed.marches){
			++marchCount;
			var left_time = ( Seed.marches[id].run_at - parseInt(serverTime()) ) + (Seed.marches[id].status=='marching' ? Seed.marches[id].duration : 0);
			//fixed by Didi
			if (left_time > 0) {
				min_time = min_time < left_time ? min_time : left_time;
				max_time = max_time > left_time ? max_time : left_time;
			}
		}
		
		//fixed by Didi
		if ( min_time === 700000 || max_time === 0 ) {
			min_time = 3;
		}
		
		retryDelay = min_time + Math.randRange(2,5);
		//retryDelay = Math.floor(Math.random() * (-1) + 7);
		
		// back off for 1 second and retry if MyAjax.march busy (general,units,etc may about to be used)
		if (MyAjax.marchBusy > 0){
			MyAjax.marchBusy = marchCount;
			verboseLog('Attack to ' + targetMsg + ' ' + translate('delayed due to pending march request') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('Another march request is pending') + ': ' +translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.autoCheckTargets, retryDelay * 1000);
			return;
		}
		
		// Find the map data
		if ( !t.checkMapData() ){
			return;
		}

		if (marchCount >= Data.options.attacks.max_marches){
			verboseLog('Attack to ' + targetMsg + ' ' + translate('delayed due to march limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('March limit reached') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.autoCheckTargets, retryDelay * 1000);
			return;
		}
		
		if (getMusterPointSlots (CAPITAL_ID) <= 0){
			verboseLog('Attack to ' + targetMsg + ' ' + translate('delayed due to muster point full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback (translate('Muster Point Full') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.autoCheckTargets, retryDelay * 1000);
			return;
		}
		
		availableGeneral = getAvailableGeneral();

		if (availableGeneral === null) {
			verboseLog('Attack to ' + targetMsg + ' ' + translate('delayed due to no available generals') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('No Generals Available') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.autoCheckTargets, retryDelay * 1000);
			return;
		}

		// Get the next target, make sure we have sufficient troops
		var nextTarget = t.getNextAttackTarget();
		if(nextTarget){
			// Jawz
			var greatDrag = null;
			if (Data.options.attacks.include_great_dragon[nextTarget.lvl]) {
				if ((greatDrag = getAvailableDragon (Data.options.attacks.except_great_dragon[nextTarget.lvl])) == null){
					verboseLog('Attack to ' + targetMsg + ' ' + translate('delayed due to no available Great Dragon') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));
					t.dispFeedback(translate('No Great Dragon available') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
					t.attackTimer = setTimeout(t.autoCheckTargets, retryDelay * 1000);
					return;
				}
			}
			// End Jawz

			if (t.checkTroops (CAPITAL_ID, nextTarget.lvl) == null) {
				t.sendAttack (CAPITAL_ID, nextTarget, availableGeneral, greatDrag, function (rslt){
					var t = Tabs.Attacks, attackDelay, retryDelay;
					if (rslt){
						attackDelay = Math.floor(Math.random() * (Data.options.attacks.delay_max - Data.options.attacks.delay_min + 1) + Data.options.attacks.delay_min);
						t.attackTimer = setTimeout(t.autoCheckTargets, attackDelay * 1000);
					} else {
						retryDelay = 30 * (t.attackErrors * t.attackErrors);
						if ( rslt.status === 509 ) {
							retry_delay = 600;
							verboseLog('<b>Attack</b> to ' + targetMsg + ' ' + translate('failed') + ' - ' + translate('<b>Rate Limit Exceeded</b>, too many requests!') + ' - ' + translate('Retry in') + ' ' + retryDelay);
							t.dispFeedback(translate('Attack to') + ' ' + targetMsg + ' ' + translate('failed')+' - '+translate('Rate Limit Exceeded because there were too many requests') + ' - ' + translate('Retry in') +' '+ retryDelay);
						}
						t.attackTimer = setTimeout(t.autoCheckTargets, retryDelay * 1000);
					}
				});
				return;                
			} else {
				verboseLog('Attack to ' + targetMsg + ' ' + translate('delayed due to insufficient troops') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('seconds'));

				t.dispFeedback(translate('Not enough') + ' ' + translate('Troops') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
				t.attackTimer = setTimeout(t.autoCheckTargets, retryDelay * 1000);
			}
		} else {
			verboseLog('Attack to ' + targetMsg + translate('Requirements Unmet') + ': ' + translate('Retry in') + retryDelay + ' ' + translate('seconds'));

			t.dispFeedback(translate('Requirements Unmet') + ': ' + translate('Retry in') + ' ' + retryDelay + ' ' + translate('Seconds'));
			t.attackTimer = setTimeout(t.autoCheckTargets, retryDelay * 1000);
		}
	},

	// notifies with true for success, false if error
	sendAttack : function (cityIdx, target, general, great_dragon, notify){
		var t = Tabs.Attacks;
		var now = serverTime();
		if (t.attackBusy){
			t.dispFeedback (translate('Error')+ ': ' +translate('sendAttack is busy, no response from server?'));
			return;
		}
		var units = cloneProps(Data.options.attacks.units[target.lvl]);
		if (great_dragon != undefined && great_dragon != null) units[great_dragon] = 1;

		//var targMsg =  '<B>' + translate('Attack sent to') + '</B>: ' + translate(Data.options.attacks.choice) + ' ' + translate('Level') + ' ' + target.lvl + ' ' + translate('at') + ' ' + target.x +'/'+ target.y;
		var targMsg =  translate('Attack sent to') + ': ' + translate(Data.options.attacks.choice) + ' ' + translate('Level') + ' ' + target.lvl + ' ' + translate('at') + ' ' + target.x +'/'+ target.y;
		
		verboseLog(targMsg +' '+ translate('Attempted'));
		
		t.attackBusy = true;
		t.lastAttack = now;

		new MyAjax.marchSend (Seed.cities[cityIdx].id, target.x, target.y, general.id, units, 'attacks', function (rslt) {
			t.attackBusy = false;
			if (rslt.ok && rslt.dat.result.success) {
				Marches.add(rslt.dat.result.job.march_id, 'attacks');
				t.attackErrors = 0;

				verboseLog(targMsg +' '+ translate('Successfully'));
				if (Data.options.attacks.log_attacks){
					actionLog(targMsg);
				}
				t.dispFeedback(targMsg);

				target.last = now;
				if (notify){
					notify(true);
				}
			} else {
				t.attackErrors++;

				verboseLog(targMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg);
				actionLog(targMsg + ' ' + translate('failed'));
				t.dispFeedback(targMsg + ' ' + translate('failed'));
					if (notify){
						notify(false);
					}
			}
		});
	},

	// returns null if ok, else error message
	checkTroops : function (cityIdx, objLevel){
		var units = Data.options.attacks.units[objLevel];
		var total = 0;
		for (var p in units){
			if (units[p] > 0){
				total += units[p];
				if (Seed.cities[cityIdx].units[p] < units[p]){
					return (translate('Not enough') +' '+ translate(p));
				}
			}
		}
		
		if (total <= 0){
			return (translate('No Troops Defined'));
		}
		return null;
	},

	// return the nextTarget that is next to be attacked, if we are at the last object in the last, return the first object
	getNextAttackTarget : function (type){
		var t = Tabs.Attacks;
		var lastAttack = 0;
		var nextTarget = null;
		var target = null;
		var attacks = Data.options.attacks;
		
		type = type || Data.options.attacks.choice;
		
		if(Data.map.terrains[type] == undefined) {
			return null;
		}
		
		// Look through all the targets
		for (var i=0; i < Data.map.terrains[type].length; i++){
			target = (Data.map.terrains[type])[i];
			// Is this target attackable?
			if (target.isAtt) {
				// Does it fit within the config specifications (distance and level)?
				if ( attacks.level_enable[target.lvl] && 
					 (attacks.level_distance[target.lvl] == 0 || target.dist <= attacks.level_distance[target.lvl]) &&
					 t.checkTroops (CAPITAL_ID, target.lvl) == null
					) {
					 // Has the target never been attacked?
						if (target.last === null) {
							nextTarget = target;
							break;
						} 
						else if (lastAttack === 0) {
							// Yes, this target is next (so far)
							lastAttack = target.last;
							nextTarget = target;
						}
						else if (lastAttack > target.last) { // Was the previous target attacked before this target?
							// Yes, this target is next (so far)
							lastAttack = target.last;
							nextTarget = target;
							break;
						}
				}
			}
		}
		
		// No target reaches the specified requirements
		if(nextTarget == null){
			return;
		}
		
		// This is complicated by the fact that the last attacked target in the list may not be the last physical entry, just the one that fits
		// the config info (distance, level enables, attackable)
		// Find the last matching target in the list
		
		var objs = Data.map.terrains[type];
		var lastMatchingTarget = null;
		for (var j=objs.length-1; j>0; j--) {
			target = objs[j];
			if (target.isAtt) {
				if ( attacks.level_enable[target.lvl] &&
					(attacks.level_distance[target.lvl] == 0 || target.dist <= attacks.level_distance[target.lvl])
					){
						lastMatchingTarget = target;
						break;
				}
			}  
		}
		
		// Is the next target the last matching target?
		if (nextTarget == lastMatchingTarget) {
			for (var k=0; j < objs.length; k++) {
				target = objs[k];
				if (target.isAtt) {
					if ( attacks.level_enable[target.lvl] &&
					(attacks.level_distance[target.lvl] == 0 || target.dist <= attacks.level_distance[target.lvl])
					){
						// Make the next target the first matching target in the list
						nextTarget = target;
						break;
					}
				}
			}
		}

		// Return the next target
		return nextTarget;
	},

	// return array of targets that satisfy config (max distance, level enables)
	getActiveObjectList : function (type){
		var t = Tabs.Attacks;
		var ret = [];
		
		type = (type != undefined ? type : Data.options.attacks.choice);
		
		if(Data.map.terrains[type]){
			for (var i=0; i < Data.map.terrains[type].length; i++){
				var target = (Data.map.terrains[type])[i];
				if ( Data.options.attacks.level_enable[target.lvl] &&
					(Data.options.attacks.level_distance[target.lvl] == 0 || target.dist <= Data.options.attacks.level_distance[target.lvl])
				  ){
						ret.push (target);
				}
			}
		}
		return ret;
	},

	checkAttack : function (target, notify){
		var t = Tabs.Attacks;
		var cityId = Seed.cities[CAPITAL_ID].id;
		var cityIdx = CAPITAL_ID;
		var availableGeneral;
		
		// check units
		var units = cloneProps(Data.options.attacks.units[target.lvl]);
		var totalTroops = 0;
		for (var p in units){
			if (units[p] > 0){
				totalTroops += units[p];
				if (Seed.cities[cityIdx].units[p] < units[p]){
					notify (translate('Not enough') +' '+ translate(p));
					return;
				}
			}
		}
		
		if (totalTroops <= 0){
			notify (translate('No Troops Defined'));
			return;
		}
		
		// TODO: 'too many troops for muster point level'

		// Jawz
		//var musterPointLvl = getMusterPointLevel (cityIdx);
		var authMaxTroops = getMusterPointMaxTroops (cityIdx);
		for (var p in units) {
			if (units[p] > 0) {
				//if (musterPointLvl < units[p] / 10000) {
				if (units[p] > authMaxTroops) {
					notify (translate('Too many troops for muster point level'));
					return;
				}
			}
		}
		
		// if (musterPointLvl < totalTroops / 10000) {
		if (totalTroops > authMaxTroops) {
			notify (translate('Too many troops for muster point level'));
			return;
		}
		// End Jawz
		
		if (getMusterPointSlots (cityIdx) <= 0){
			notify (translate('Muster Point Full'));
			return;
		}
		
		if ((availableGeneral = getAvailableGeneral ()) == null){
			notify (translate('No Generals Available'));
			return;
		}
		
		// Jawz
		var greatDrag = null;
		if (Data.options.attacks.include_great_dragon[target.lvl]) {
			if ((greatDrag = getAvailableDragon (Data.options.attacks.except_great_dragon[target.lvl])) == null){
				notify(translate('No Great Dragon available'));
				return;
			}
			if (greatDrag && greatDrag != null) units[greatDrag] = 1;
		}
		// End Jawz
		var targMsg =  translate('Manual attack sent to') + ': ' + translate(Data.options.attacks.choice) + ' ' + translate('Level') + ' ' + target.lvl + ' ' +  translate('at') + ' ' + target.x +'/'+ target.y;
		
		verboseLog(targMsg +' '+ translate('Attempted'));
		
		new MyAjax.marchSend (cityId, target.x, target.y, availableGeneral.id, units, 'attacks', function (rslt) {
			if (rslt.ok) {
				Marches.add(rslt.dat.result.job.march_id, 'attacks');
				verboseLog(targMsg +' '+ translate('Successfully'));
				if (Data.options.attacks.log_attacks){
					actionLog(targMsg);
				}
				t.dispFeedback(targMsg);
				target.last = serverTime();
				notify('OK');  // Jawz - Test 'OK' instead of null
			} else {
				verboseLog(targMsg +' '+ translate('failed and returned error') +': '+ rslt.errmsg);

				t.dispFeedback (translate('Error') + ': ' + rslt.errmsg);
				notify(translate('Error') + ': ' + rslt.errmsg);
			}
		});	
	},

	// Jawz
	checkSpy : function (target, notify){
		var t = Tabs.Attacks;
		var cityId = Seed.cities[CAPITAL_ID].id;
		var cityIdx = CAPITAL_ID;
		
		// check troops
		var units = [];
		units['Spy'] = 1;
		var totalTroops = 0;
		for (var p in units){
			if (units[p] > 0){
				totalTroops += units[p];
				if (Seed.cities[cityIdx].units[p] < units[p]){
					notify (translate('Not enough') +' '+ translate(p));
					return;
				}
			}
		}
		
		if (totalTroops <= 0){
			notify (translate('No Troops Defined'));
			return;
		}
		
		// TODO: 'too many troops for muster point level'
		var authMaxTroops = getMusterPointMaxTroops (cityIdx);
		for (var p in units) {
			if (units[p] > 0) {
				if (units[p] > authMaxTroops) {
					notify (translate('Too many troops for muster point level'));
					return;
				}
			}
		}
		
		if (totalTroops > authMaxTroops) {
			notify (translate('Too many troops for muster point level'));
			return;
		}
		
		if (getMusterPointSlots (cityIdx) <= 0){
			notify (translate('Muster Point Full'));
			return;
		}
		
		var targMsg =  translate('Manual spy sent to') + ': ' + translate(Data.options.attacks.choice) + ' ' + translate('Level') + ' ' + target.lvl + ' ' +  translate('at') + ' ' + target.x +'/'+ target.y;
		
		verboseLog(targMsg +' '+ translate('Attempted'));
		
		new MyAjax.marchSpy (cityId, target.x, target.y, units, 'attacks', function (rslt) {
			if (rslt.ok) {
				Marches.add(rslt.dat.result.job.march_id, 'attacks');
				verboseLog(targMsg +' '+ translate('Successfully'));
				if (Data.options.attacks.log_attacks){
					actionLog(targMsg);
				}
				t.dispFeedback(targMsg);
				target.last = serverTime();
				notify('OK');
			} else {
				verboseLog(targMsg +' '+ translate('failed and returned error') +': '+ rslt.errmsg);

				t.dispFeedback (translate('Error') + ': ' + rslt.errmsg);
				notify(translate('Error') + ': ' + rslt.errmsg);
			}
		});	
	},
	// End Jawz

	// Data.options.campAttack {enabled:false, maxDist:7, repeat_delay:3660, delay_min:15, delay_max:25, level_enable:[], level_distance:[]}

	
	
	//*** Attacks Tab - Levels Sub-Tab ***
	//----------------------------------------------------------------------------
	tabAttackLevels : function (){
		var t = Tabs.Attacks;
		
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabAttackLevels']).className='selected';
		document.getElementById(UID['tabAttackLevels']).style.zIndex=1;
		t.lastSubTab = 'tabAttackLevels';
		
		t.contentType = 0;
		
		var city = Seed.cities[CAPITAL_ID];

		// New content area here
		var m = '<div class="' + UID['title'] + '">'+ translate('Attacks') + '&nbsp;' + translate(Data.options.attacks.choice) +'</div>'
		// Jawz
		+'<div id=' + setUID('tabAAttackLevels_Statbox') + ' class=' + UID['status_ticker'] + ' style="height:430px; max-height:430px; overflow-y:auto; margin-top:1px !important">'
		// +'<div style="overflow:auto">'
		// End Jawz
		+'	<table class=' + UID['compact_table'] + ' width=100%>'
		+'		<tr class=' + UID['row_top_headers'] + '>'
		+'			<td style="background:none !important;"></td>'
		+'			<td align=center colspan=11>&nbsp;'+ translate('Levels') +'&nbsp;</td>'
		+'		</tr>'
		+'		<tr align=center class=' + UID['row_headers'] + '>'
		+'			<td width=12% style="background:none !important;"></td>' // Jawz - added width
		+'			<td width=8%>1</td>'
		+'			<td width=8%>2</td>'
		+'			<td width=8%>3</td>'
		+'			<td width=8%>4</td>'
		+'			<td width=8%>5</td>'
		+'			<td width=8%>6</td>'
		+'			<td width=8%>7</td>'
		+'			<td width=8%>8</td>'
		+'			<td width=8%>9</td>'
		+'			<td width=8%>10</td>' // End Jawz
		+'			<td width=8%>11</td>' // End Jawz
		+'		</tr>'
		+'		<tr align=center>'
		+'			<td class=right>'+ translate('Enable') +': </td>'; // Jawz - replaced class=left by right
		
		for (var x=1; x < 12; x++){
			m += '		<td><label><input type=checkbox id='+ setUID('tabAttackLevels_LvlOnOff_'+ x) + ' ref='+ x +' ' +(Data.options.attacks.level_enable[x]?' checked':'')   +' /></label></td>';
		}
		
		m += '		</tr><tr align=center>'
		+'			<td class=right>'+ translate('Max') +' '+ translate('Distance').truncate(4,'') +': </td>'; // Jawz - replaced class=left by right
		
		for (var x=1; x < 12; x++){
			m += '		<td><input type=text id='+ setUID('tabAttackLevels_LvlDist_'+ x) +' ref='+ x +' maxlength=2 style="width:37px" value="'+ Data.options.attacks.level_distance[x] +'" /></td>';
		}
		m += '		</tr><tr>'
		+'				<td><div class=short></div></td>'
		+'			</tr>';
		
		var currentTroops = [];
		for (var i=0; i < attack_unit_types.length; i++)
		{
			var color = '#FFF';
			if ( i < 5 ) color = '#DDD';
			else if ( i < 8 ) color = '#BEB';
			else if ( i < 10 ) color = '#EEB';
			else if ( i < 12 ) color = '#BBE';
			else if ( i < 16 ) color = '#EBB';
			else color = '#EBB';
			// if(getTroopNumbers(city, attack_unit_types[i]).total) // Jawz
			// { // Jawz
				m += '<tr style="background-color:' + color + ';">'
				+'		<td class=right><span title="'+translate(attack_unit_types[i])+'">'+ translate(Names.getTroopAbbr(attack_unit_types[i])) +':<span></td>'; // Jawz - replaced class=left by right
				for (var x=1; x < 12; x++)
				{
					var num = Data.options.attacks.units[x][attack_unit_types[i]];
					if (!num){
						num = 0;
					}
					m += '<td><input type=text id='+ setUID('tabAttackLevels_LvlTroops_'+ x +'_'+ i) +' ref='+ (x +'_'+ i) +' maxlength=6 size=2 style="width:38px;'+(num?'':'color:#888;')+'" value="'+ num +'" title="" /></td>';
				}
				m += '</tr>';
				currentTroops.push(i);
			// } // Jawz
		}
		
		m += '<tr>'
		+'		<td><div class=short></div></td>'
		+'	</tr>'
		+'	<tr>'
		+'		<td style="background:none !important;"></td>'
		+'		<td align=center colspan=11 align=center>'
		+'			<table cellpadding=1 cellspacing=1 width=90%>'
		+'				<tr><td width=40%><hr></td><td>&nbsp &nbsp'+ translate('Great dragons') +'&nbsp &nbsp</td><td width=40%><hr></td></tr>'
		+'			</table></td>'
		+'	</tr><tr align=center>'
		+'		<td class=right><span title="'+translate('Include Great Dragon')+'">'+ translate('Dragons') +':<span></td>';
		for (var x=1; x < 12; x++){
			m += '		<td><label><input type=checkbox id='+ setUID('tabAttackLevels_GreatDrag_'+ x) + ' ref='+ x +' ' +(Data.options.attacks.include_great_dragon[x]?' checked':'')   +' /></label></td>';
		}
		m += '</tr><tr align=center>'
		+'		<td class=left><span title="'+translate('Check the following great dragons to exclude them from being sent')+'">'+ translate('Except') +':<span></td>';
		+'	</tr>'
		var currentDragons = [];
		for (var j=0; j < Seed.dragonList.length; j++)
		{
			var dragon = Seed.dragonList[j];
			color = '#EBB';
			m += '<tr style="background-color:' + color + ';">'
			+'		<td class=right><span title="'+translate(dragon.type)+'">'+ translate(Names.getTroopAbbr(dragon.type)) +':<span></td>'; // Jawz - replaced class=left by right
			for (var x=1; x < 12; x++)
			{
				m += '<td align=center><input type=checkbox id='+ setUID('tabAttackLevels_LvlDragons_'+ x +'_'+ j) +' ref='+ (x +'_'+ j) +' ' + (Data.options.attacks.except_great_dragon[x][dragon.type]?' checked':'') +' /></td>';
			}
			m += '</tr>';
			currentDragons.push(j);
		}

		m += '</table><div class=short></div></div>';
		document.getElementById(UID['tabAttack_Content']).innerHTML = m;

		// add event listeners ...
		for (var x=1; x < 12; x++){
			document.getElementById(UID['tabAttackLevels_LvlOnOff_'+ x]).addEventListener('change', enableChanged, false);
			document.getElementById(UID['tabAttackLevels_LvlDist_'+ x]).addEventListener('change', distChanged, false);
			document.getElementById(UID['tabAttackLevels_GreatDrag_'+ x]).addEventListener('change', dragChanged, false);
		}

		for (var i=0; i < currentTroops.length; ++i){
			for (var x=1; x < 12; x++){
				document.getElementById(UID['tabAttackLevels_LvlTroops_'+ x +'_'+ currentTroops[i]]).addEventListener('change', troopsChanged, false);
			}
		}

		for (var j=0; j < currentDragons.length; ++j){
			for (var x=1; x < 12; x++){
				document.getElementById(UID['tabAttackLevels_LvlDragons_'+ x +'_'+ currentDragons[j]]).addEventListener('change', exceptDragonsChanged, false);
			}
		}

		function enableChanged (e){
			var n = parseInt(e.target.getAttribute('ref'));
			Data.options.attacks.level_enable[n] = e.target.checked;
		}
		
		function distChanged (e){
			var n = parseInt(e.target.getAttribute('ref'));
			var x = parseIntZero(e.target.value);
			if (isNaN(x) || x < 0 || x > t.MAX_DISTANCE){
				e.target.style.backgroundColor = 'red';
				dispError (translate('Distance must be between') + ' 0 ' + translate('and') +' '+ t.MAX_DISTANCE, t.container);
			} 
			else {
				e.target.value = x;
				e.target.style.backgroundColor = '';
				Data.options.attacks.level_distance[n] = x;
			}
		}
		
		function dragChanged (e){
			var n = parseInt(e.target.getAttribute('ref'));
			Data.options.attacks.include_great_dragon[n] = e.target.checked;
		}

		function exceptDragonsChanged (e){
			var args = e.target.getAttribute('ref').split('_');
			Data.options.attacks.except_great_dragon[args[0]][Seed.dragonList[args[1]].type] = e.target.checked;
		}

		function troopsChanged (e){
			var args = e.target.getAttribute('ref').split('_');
			var x = parseIntZero(e.target.value);
			if (isNaN(x) || x<0 || x>200000){  // JAwz - set max up to 200 000
				e.target.style.backgroundColor = 'red';
				dispError (translate('Invalid number of troops',t.container));
			}
			else {
				e.target.value = x;
				Data.options.attacks.units[args[0]][attack_unit_types[args[1]]] = x;
				e.target.style.backgroundColor = '';
				if(parseInt(e.target.value)>0){
					e.target.style.color = '#000';
				}
			}
		}
	},

	//*** Attacks Tab - Config Sub-Tab ***
	//----------------------------------------------------------------------------
	tabAttackConfig : function (){
		var t = Tabs.Attacks;
		
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;

		document.getElementById(UID['tabAttackConfig']).className='selected';
		document.getElementById(UID['tabAttackConfig']).style.zIndex=1;
		t.lastSubTab = 'tabAttackConfig';

		t.contentType = 1;

		var m = '<div class=' + UID['title'] + '>'+ translate('Attacks Configuration') + '</div>'
		+'<div id='+ setUID('tabAttackConfig_Status') +' class=' + UID['status_ticker'] + ' style="overflow:auto">' // Jawz
		// +'<div style="overflow:auto">' // Jawz
		+'	<table class=' + UID['table'] + ' width=100%>' // Jawz - Added width
		+'	<tr>'
		+'		<td width=50% class=right>'+ translate('Delay Between Attacks') +':&nbsp;</td>' // Jawz - Added width & replaced class=left by right
		+'		<td width=50%>' // Jawz - Added width
		+'		<input class=short id='+ setUID('tabAttackConfig_DelayMin') +' maxlength=4 type=text value="'+ Data.options.attacks.delay_min +'" />&nbsp;'+ translate('to')
		+'		<input class=short id='+ setUID('tabAttackConfig_DelayMax') +' maxlength=4 type=text value="'+ Data.options.attacks.delay_max +'" />&nbsp;'+ translate('Seconds').toLowerCase() 
		+'		</td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Delete Battle Reports') +':&nbsp;</td>' // Jawz - replaced class=left by right
		+'		<td><input id='+ setUID('tabAttackConfig_DelAttacks') +' '+ (Data.options.attacks.delete_reports?'CHECKED ':'') +' type=checkbox /></td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Stop if any troops lost') +':&nbsp;</td>' // Jawz - replaced class=left by right
		+'		<td><input id='+ setUID('tabAttackConfig_StopOnLoss') +' '+ (Data.options.attacks.stop_on_loss?'CHECKED ':'') +' type=checkbox /></td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Maximum simultaneous marches') +':&nbsp;</td>' // Jawz - replaced class=left by right
		+'		<td><input id='+ setUID('tabAttackConfig_MaxMarches') +' class=short maxlength=2 type=text value="'+ Data.options.attacks.max_marches +'" /></td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Activate Attacks Logs') +':&nbsp;</td>' // Jawz - replaced class=left by right
		+'		<td><input id='+ setUID('tabAttackConfig_LogAttack') +' '+ (Data.options.attacks.log_attacks?'CHECKED ':'') +' type=checkbox /></td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Clear last attack on current map') +'&nbsp;</td>' // Jawz - replaced class=left by right
		+'		<td><input id='+ setUID('tabAttackConfig_ClearLast') +'  type=button value="'+translate('Delete')+'" /></td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Clear last attack on all maps') +'&nbsp;</td>' // Jawz - replaced class=left by right
		+'		<td><input id='+ setUID('tabAttackConfig_ClearAll') +' '+ (Data.options.attacks.clear_all_targets?'CHECKED ':'') +' type=checkbox /></td>'
		+'	</tr></table>';
		
		document.getElementById(UID['tabAttack_Content']).innerHTML = m;
		
		// Add event listeners
		document.getElementById(UID['tabAttackConfig_DelAttacks']).addEventListener('change', function (e){
			Data.options.attacks.delete_reports = e.target.checked;
		}, false);
		document.getElementById(UID['tabAttackConfig_StopOnLoss']).addEventListener('change', function (e){
			Data.options.attacks.stop_on_loss = e.target.checked;
		}, false);
		document.getElementById(UID['tabAttackConfig_LogAttack']).addEventListener('change', function (e){
			Data.options.attacks.log_attacks = e.target.checked;
		}, false);
		document.getElementById(UID['tabAttackConfig_ClearAll']).addEventListener('change', function (e){
			Data.options.attacks.clear_all_targets = e.target.checked;
		}, false);
		document.getElementById(UID['tabAttackConfig_DelayMin']).addEventListener('change', delayChanged, false);
		document.getElementById(UID['tabAttackConfig_DelayMax']).addEventListener('change', delayChanged, false);
		document.getElementById(UID['tabAttackConfig_MaxMarches']).addEventListener('change', maxMarchesChanged, false);
		document.getElementById(UID['tabAttackConfig_ClearLast']).addEventListener('click', clearLast, false);
		
		
		function delayChanged (e){
			var min = parseIntNan(document.getElementById(UID['tabAttackConfig_DelayMin']).value);
			var max = parseIntNan(document.getElementById(UID['tabAttackConfig_DelayMax']).value);
			if (min < MIN_DELAY || min > 3600 || (max-min) < 5){
				var dial = new ModalDialog (t.container, 300, 150, '', true);
				dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Error') + '</b></center></div>';
				dial.getContentDiv().innerHTML = '<b>'+ translate('Invalid delays') +'</b><br><br>'
				+translate('First value must be between') + ' ' + MIN_DELAY +' '+ translate('and') + ' 3600. '
				+translate('Second value must be at least') + ' 5 ' + translate('above the first value');
				return;
			}
			Data.options.attacks.delay_min = min;
			Data.options.attacks.delay_max = max;
		}
		
		function maxMarchesChanged (e){
			var val = parseIntNan(document.getElementById(UID['tabAttackConfig_MaxMarches']).value);
			if (val < 0 || val > Seed.cities[CAPITAL_ID].figures.marches.maximum){
				e.target.style.backgroundColor = 'red';
				return;
			}
			e.target.style.backgroundColor = '';
			Data.options.attacks.max_marches = val;
		} 
		
		// Clear the information about when the target was last attacked
		// This is useful because attacks always start with the oldest target or, 
		// if no target has been attacked (last == 0), the first target in the list
		function clearLast (e){
			if (Data.options.attacks.clear_all_targets) {
				// Make sure the user has scanned the map
				for (var type in Data.map.terrains) {
					for (var i=0; i<Data.map.terrains[type].length; i++) {
						(Data.map.terrains[type])[i].last = 0;
					}
				}
			}
			else {
				// Clear the last attacked field of the currently selected target
				var targets = Data.map.terrains[Data.options.attacks.choice];
				for (var i=0; i < targets.length; i++) {
					targets[i].last = 0;
				}
			}
		}
	},
	

	//*** Attacks Tab - Targets Sub-Tab ***
	//----------------------------------------------------------------------------
	tabAttackTarget : function (){
		var t = Tabs.Attacks;

		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabAttackTarget']).className='selected';
		document.getElementById(UID['tabAttackTarget']).style.zIndex=1;
		t.lastSubTab = 'tabAttackTarget';

		t.contentType = 2;

		var timer = null;
		
		t.checkMapData();
		
		// Owned resources have a red background color and white text
		var targets = t.getActiveObjectList(); 
		if (targets.length == 0){
			t.dispFeedback ( translate('Use the Levels Tab to select attack areas') );
		}

		targets.sort( function(a,b){return a.dist - b.dist;} );

		document.getElementById(UID['tabAttack_Title']).innerHTML = translate('Attack') + ' ' + translate(Data.options.attacks.choice);
	
		var m = '<div class=' + UID['title'] + '>'
		+ translate('Attacks') + '&nbsp;' + translate(Data.options.attacks.choice)
		+	'</div>';
		
		// MapChoice Selector
		setUID('tabAttackTarget_MapChoice');
		m += '<div id=' + setUID('tabAAttackTarget_Statbox') + ' class=' + UID['status_ticker'] + ' style="height:450px; max-height:450px">' // Jawz
		m += '<table><tr>'
		  + '<td align=right>'
		  + '&nbsp;<b>' + translate('Select')+ ' ' +translate('Targets')+'</b>' // Jawz - Removed <br> between select and targets
		  + '</td>'
		  + '<td>'
		  + ':&nbsp;<select id='+ UID['tabAttackTarget_MapChoice'] +'>';
		
		for (var type in Data.map.terrains){
			if ( type == kCity ) {
				m += '<option disabled="disabled">-----------------------</option>';
			}
			m += '<option value="'+ type +'" '+ (type==Data.options.attacks.choice ? 'selected' : '') +'>'
			  + translate(type) 
			  +'</option>'
		}
		m += '</select>&nbsp;'
		  + '</td>'
		  + '<td>'
		  + '<span class=jewel>'+ targets.length + ' ' + translate('of') + ' ' + Data.map.terrains[Data.options.attacks.choice].length +'</span>'
		  + '</td>'
		  + '</tr></table><br>';
		
		m +='<div class="' + UID['scrollable'] + '" style="height:390px;">'  // Jawz - Height set to 390 instead of 365
		+ '<table id='+ setUID('tabAttackTarget_Tab') +' class=' + UID['table'] + '>'// width=100%>' // Jawz - Added width
		+ '	<tr class='+ UID['row_headers'] +'>'
		+ '		<td valign=middle width="20px"><b>'+ translate('Distance').substring(0,4) +'</b></td>'  // Jawz - Added width
		+ '		<td valign=middle width="30px"><b>'+ translate('Coords') +'</b></td>'                   // Jawz - Added width
		+ '		<td valign=middle width="15px"><b>'+ translate('Level') +' </b></td>'                   // Jawz - Added width
		+ '		<td valign=middle width="80px"><b>'+ translate('Last Attack') +'</b></td>'              // Jawz - Added width and removed .split(' ').join('<br/>')
		+ '		<td colspan=2 style="background:none"></td>' // Jawz
		+	'</tr>';
		
		// Hilite owned wildernesses
		var ownedWilderness = Seed.player.player_wildernesses; 
		var bFound = false;
		for (var i=0; i < targets.length; i++){
			m += '<tr id='+ setUID('tabAttackTarget_TabRow_'+i);
			if (Data.options.attacks.choice == kCity || 
				Data.options.attacks.choice == kOutpost || 
				Data.options.attacks.choice == kWildernesses
				){
					m+= '  title="'
					+ targets[i].name + '  ('+ translate(targets[i].type) + ') \n'
					+ targets[i].pName + ' (lvl '+ targets[i].pLvl + ') - Pwr: '+ targets[i].pMight +' \n'
					+ translate('Alliance') + ': ' + (targets[i].pAlli || '---')
					+'"'
			}
			
			m += '>'
			+		'<td>'+ targets[i].dist +'</td>'
			+		'<td align=center>'+ targets[i].x +'/'+ targets[i].y +'</td>'
			+		'<td align=center>'+ targets[i].lvl +'</td>'
			+		'<td><span id='+ setUID('tabAttackTarget_List_'+i) +'> --- </span></td>'
			+		'<td><input id='+ setUID('tabAttackTarget_AttackNow_'+i) +' ref='+ i +' class=small style="width:auto !important;" type=button value="  ' + translate('Attack') + ' !  "/>'
			+		'&nbsp;&nbsp;<input id='+ setUID('tabAttackTarget_SpyNow_'+i) +' ref='+ i +' class=small style="width:auto !important;" type=button value="  ' + translate('Spy') + ' !  " />';  // Jawz
			
			// Add the skip attack button for cities and outposts
			if (Data.options.attacks.choice == kCity || 
				Data.options.attacks.choice == kOutpost || 
				Data.options.attacks.choice == kWildernesses
				){
					m += '&nbsp;&nbsp;<input id='+ setUID('tabAttackTarget_SkipAttack_'+i) +' ref='+ i +' type=checkbox '+ (targets[i].isAtt?'CHECKED':'') +' /></td>'
					+ '<td><b>' + targets[i].pName.truncate(13).replace('...','<span class=jewel>...</span>') + '</b></td>'
					+ '<td>' + (targets[i].pAlli || '---').truncate(16).replace('...','<span class=jewel>...</span>');
			}
			
			m += '</td></tr>';

		}
		
		m += '</table></div>';

		document.getElementById(UID['tabAttack_Content']).innerHTML = m;
		document.getElementById(UID['tabAttack_Content']).scrollTop = gAttScrollPos;
		
		// Hilight owned resources and don't attack them
		for (var i=0; i < targets.length; i++){
			for (var j=0; j < ownedWilderness.length; j++) {
				if (ownedWilderness[j].x == targets[i].x && ownedWilderness[j].y == targets[i].y) {
					document.getElementById(UID['tabAttackTarget_TabRow_'+i]).className=UID['row_owned'];
					targets[i].isAtt = false;
					break;
				}
			}
		}
		
		// Add the event listeners
		document.getElementById(UID['tabAttack_Content']).addEventListener('scroll', onScroll, false);
		document.getElementById(UID['tabAttackTarget_MapChoice']).addEventListener('change', onMapChoice, false);
		
		for (var i=0; i < targets.length; i++) {
			var butAttack = document.getElementById(UID['tabAttackTarget_AttackNow_'+ i]);
			butAttack.addEventListener ('click', butAttackNow, false);
			// Jawz
			var butSpy = document.getElementById(UID['tabAttackTarget_SpyNow_'+ i]);
			butSpy.addEventListener ('click', butSpyNow, false);
			// End Jawz
			if (t.selectedMapName == kCity || t.selectedMapName == kOutpost || t.selectedMapName == kWildernesses) {
				document.getElementById(UID['tabAttackTarget_SkipAttack_'+ i]).addEventListener ('click', toggleAttackable, false);
			}
			setButtonStyle (butAttack, targets[i].isAtt);    
			setButtonStyle (butSpy, targets[i].isAtt);    
		}
		
		tick();
		
		function setButtonStyle (el, enabled) {
			if (enabled) {
				el.disabled = false;
				Element.removeClassName(el, UID['bnt_red']);
				Element.addClassName(el, UID['bnt_green']);
			}
			else {
				el.disabled = true;
				Element.removeClassName(el, UID['bnt_green']);
				Element.addClassName(el, UID['bnt_red']);
			}
		}
		
		function onScroll (e){
			if (t.contentType == 2)
			gAttScrollPos = document.getElementById(UID['tabAttack_Content']).scrollTop;
		}
		
		function onMapChoice (e){
			var t = Tabs.Attacks;
			
			if (Data.options.attacks.enabled) {
				// It would be very bad to leave attack on when switching targets. Imagine sending the troops for a wilderness to a city or an ant camp...
				clearTimeout (timer);
				t.setAttackEnable(false);
				t.dispFeedback (translate('Safe Mode') +': '+ translate('Attacks') +' '+ translate('Turned Off'));
			}
			
			var el = e.target;
			
			Data.options.attacks.choice = Tabs.Attacks.selectedMapName = el.options[el.selectedIndex].value;
			//Data.map.targets = Data.map.terrains[Data.options.attacks.choice].clone();
			t.tabAttackTarget();
		}

		function butAttackNow (e){
			var n = parseInt(e.target.getAttribute('ref'));
			var dial = new ModalDialog (t.container, 300, 150, '', false);
			dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
			dial.getContentDiv().innerHTML = translate('Attacking');
			t.checkAttack (targets[n], notify);
			function notify (rslt){
				if (rslt!='OK'){  // Jawz - Test 'OK' instead of null
					dial.getContentDiv().innerHTML = '<b>'+ rslt +'</b>';
					dial.allowClose (true);
				} else {
					dial.getContentDiv().innerHTML = '<b>'+ translate('OK') +'</b>';
					setTimeout (function(){dial.destroy()}, 1000);
				}
			}
		}

		// Jawz
		function butSpyNow (e){
			var n = parseInt(e.target.getAttribute('ref'));
			var dial = new ModalDialog (t.container, 300, 150, '', false);
			dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
			dial.getContentDiv().innerHTML = translate('Spying');
			t.checkSpy (targets[n], notify);
			function notify (rslt){
				if (rslt!='OK'){
					dial.getContentDiv().innerHTML = '<b>'+ rslt +'</b>';
					dial.allowClose (true);
				} else {
					dial.getContentDiv().innerHTML = '<b>'+ translate('OK') +'</b>';
					setTimeout (function(){dial.destroy()}, 1000);
				}
			}
		}
		// End Jawz

		function toggleAttackable (e){
			var n = parseInt(e.target.getAttribute('ref'));
			targets[n].isAtt = (!targets[n].isAtt);
			setButtonStyle (document.getElementById(UID['tabAttackTarget_AttackNow_'+n]), targets[n].isAtt);     
		}
		
		function tick (){
			var now = serverTime();
			var ts;
			clearTimeout (timer);
			if (!document.getElementById(UID['tabAttackTarget_Tab']))
			return;
			for (var i=0; i < targets.length; i++){
				var list = document.getElementById(UID['tabAttackTarget_List_'+i]);
				if (list == undefined){
					continue;
				}
				
				if (!targets[i].last || targets[i].last == undefined || targets[i].last == null){
					ts = '---';
				}
				else {
					var time = now-targets[i].last;
					// fix this :P
					if (time > 3600){
						ts = '<font color=#550000><b>'+ timestr (now-targets[i].last, false) +'</b></font>';
					}
					else {
						ts = timestr (now-targets[i].last, false);
					}
				}
				list.innerHTML = ts;
			}
			timer = setTimeout (tick, 5000);
		}
	},

	
	//*** Attacks Tab - Stats Sub-tab ***
	//----------------------------------------------------------------------------
	tabAttackStats : function (){
		var t = Tabs.Attacks;

		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabAttackStats']).className='selected';
		document.getElementById(UID['tabAttackStats']).style.zIndex=1;
		t.lastSubTab = 'tabAttackStats';
		
		t.contentType = 3;

		var m = '<div class=' + UID['title'] + '>'+translate('Attacks Stats')+'</div>'
		+'<div id='+ setUID('tabAttackStats_Statbox') +' class=' + UID['status_ticker'] + '>' // Jawz
		+'<div id='+ setUID('tabAttackStats_Status') +'></div>' // Jawz
		+'<div id='+ setUID('tabAttackStats_Percent') +'></div>' // Jawz
		+'<br/>'
		+'<center><input id='+ setUID('tabAttackStats_Clear') +' type=button value="'+ translate('Clear Stats') +'" /></center>'
		+'<br></div>'; // Jawz
		
		document.getElementById(UID['tabAttack_Content']).innerHTML = m;
		
		document.getElementById(UID['tabAttackStats_Clear']).addEventListener('click', function(){
			t.clearStats();
			t.showStats();
		}, false);
		
		t.showStats();
	},

	// by_level.resources
	clearStats : function (){
		var t = Tabs.Attacks;
		var now = serverTime();
		Data.stats.attacks = {start_at:now, run_time:0, total_attacks:0, items:{}, resources:{}, by_level:[]};
		t.curRunStart = now;
		for (var i=0; i < 12; i++){
			Data.stats.attacks.by_level[i] = {total_attacks:0, items:{}, resources:{}};
		}
		t.showStats(); 
	},
	
	trackStats : function (marchId, rpt_st){   // called when battle report received
		var t = Tabs.Attacks;
		if (DEBUG_MARCHES){
			WinLog.write ('Tabs.Attacks.trackStats: '+ marchId);
		}
		var objLevel = rpt_st.report.location.level;
		
		if (objLevel < 1 || objLevel > 12){
			objLevel = 0;
		}
		
		++Data.stats.attacks.total_attacks;
		++Data.stats.attacks.by_level[objLevel].total_attacks;
		var res =  rpt_st.report.spoils.resources;
		for (var p in res){
			objAddTo (Data.stats.attacks.resources, p, parseInt(res[p]));
			objAddTo (Data.stats.attacks.by_level[objLevel].resources, p, parseInt(res[p]));
		}  
		var killRes =  rpt_st.report.spoils.kill_items;
		for (var p in killRes){
			objAddTo (Data.stats.attacks.resources, p, parseInt(killRes[p]));
			objAddTo (Data.stats.attacks.by_level[objLevel].resources, p, parseInt(killRes[p]));
		}  
		
		var items =  rpt_st.report.spoils.items;
		for (var i=0; i < items.length; i++){
			objAddTo (Data.stats.attacks.items, items[i], 1);
			objAddTo (Data.stats.attacks.by_level[objLevel].items, items[i], 1);
		}  

		Data.marches.attacks[marchId].has_report = true;
		t.showStats();    
	},

	showStats : function (){
		var div = document.getElementById(UID['tabAttackStats_Status']);
		var t = Tabs.Attacks;
		
		if (div==null){
			return;
		}
		
		var run_time = Data.stats.attacks.run_time;
		if (Data.options.attacks.enabled){
			run_time += (serverTime()-t.curRunStart);
		}
		
		var trueRunTime = (run_time > 0) ? (run_time/3600) : 1;
		
		var m = '<table class=' + UID['table'] + '>'
		+'	<tr>'
		+'		<td class=right>'+ translate('Start Date') +': </td>' // Jawz - replaced class=left by right
		+'		<td>'+  new Date(Data.stats.attacks.start_at * 1000).myString() +'</td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Run Time') +': </td>' // Jawz - replaced class=left by right
		+'		<td>'+ timestr(run_time, true) +'</td>'
		+'	</tr><tr>'
		+'		<td class=right>'+ translate('Attacks') +': </td>' // Jawz - replaced class=left by right
		+'		<td>'+ Data.stats.attacks.total_attacks +'</td>'
		+'	</tr><tr valign=top>'
		+'		<td class=right>'+ translate('Resources') +': </td>' // Jawz - replaced class=left by right
		+'		<td>'
		+'			<table class=' + UID['table'] + '>';
		
		for (var name in Data.stats.attacks.resources)
		{
			var perHour = Math.round(Data.stats.attacks.resources[name] / trueRunTime);
			m += '	<tr align=right>'
			+'			<td>'+ translate(name) +':</td>'
			+'			<td>'+ nombreFormate(Data.stats.attacks.resources[name],' ') +'</td>' //.intToCommas()
			+'			<td>('+ nombreFormate(perHour,' ') +' /'+ translate('h')+ ')</td>'  //.intToCommas()
			+'		</tr>';
		}
		
		m += '		</table>'
		+'		</td>'
		+'</tr></table>';
		
		m += '<br><div class=' + UID['subtitle'] + '>'+ translate('Statistics') +'&nbsp;'+ translate('of') +'&nbsp;'+ translate('Attack') +' '+ translate('and') +' '+ translate('Items') +'</div>'
		+'<div style="overflow:auto">'
		+'	<table class=' + UID['table'] + '>'
		+'		<tr class=' + UID['row_top_headers'] + ' align=center>'
		+'			<td style="background:none !important;"></td>'
		+'			<td align=right colspan=11>'+ translate('Levels') +'</td>'
		+'		</tr><tr align=right class=' + UID['row_headers'] + '>'
		+'			<td style="background:none !important;"></td>';
		
		for (i=1; i < 12; i++) {
			m += '	<td width=45>'+ i +'</td>';
		}
		
		m += '	</tr><tr>'
		+'			<td colspan=12><HR class=thin></td>'
		+'		</tr><tr align=right>'
		+'			<td class=right># '+translate('Attacks')+':</td>'; // Jawz - replaced class=left by right
		
		for (i=1; i < 12; i++){
			m += '	<td>'+ Data.stats.attacks.by_level[i].total_attacks +'</td>';
		}
		
		m += '	</tr><tr>'
		+'			<td colspan=12><HR class=thin></td>'
		+'		</tr>'; 
		
		var items =  flipStats ('items');     
		for (var p in items){
			m += '<tr align=right>'
			+'		<td class=right>'+ translate(Names.getItemAbbr(p)) +':</td>'; // Jawz - replaced class=left by right and show item by Abbr
			for (i=1; i < 12; i++) {
				m += '<td>'+ items[p][i] +'</td>';
			}

			// Jawz - Added percentage of items per attack
			m += '</tr><tr align=right>'
			+'		<td class=right>&nbsp</td>';
			for (i=1; i < 12; i++) {
				m += '<td>'+ ((Data.stats.attacks.by_level[i].total_attacks == 0 || items[p][i] == 0) ? '' : '('+ Math.round ((items[p][i] / Data.stats.attacks.by_level[i].total_attacks) * 100)+'%)') +'</td>';
			}
			m += '</tr><tr>'
			+'		<td colspan=12><HR class=thin></td>'
			+'	</tr>'; 
		}
		
		m += '</table></div>';
		div.innerHTML = m;

		function flipStats (name){
			var o = {};
			for (var i=1; i < 12; i++){
				for (var p in Data.stats.attacks.by_level[i][name]){
					if (!o[p])
					{
						o[p] = [];
						for (var x=1; x < 12; x++){
							o[p][x] = 0;
						}
					}
					o[p][i] += Data.stats.attacks.by_level[i][name][p];
				}
			}
			return o;
		}
	},
	

	
	//*** Attacks Tab - Maps Sub-tab ***
	//----------------------------------------------------------------------------
	tabAttackMaps : function(){
		var t = Tabs.Attacks;

		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabAttackMaps']).className='selected';
		document.getElementById(UID['tabAttackMaps']).style.zIndex=1;
		t.lastSubTab = 'tabAttackMaps';

		t.contentType = 4;

		var m = '<div class=' + UID['subtitle'] + '>'+ translate('Search') + ' ' + translate('Location') +'</div>'
			+'<div id=' + setUID('tabAttackMaps_Statbox') + ' class=' + UID['status_ticker'] + ' style="overflow:auto; margin-top:1px !important">' // Jawz
			// +'<div style="overflow:auto">' // Jawz
			+ '<b>' + translate('Search Radius') + ':</b> '
			+'	<select id='+setUID('tabAttackMaps_Radius')+'>';
			
			for (var i=5; i <= t.MAX_DISTANCE; i+=5){
				m +='		<option value="'+ i +'" '+ (Data.map.radius == i ? 'selected' : '') +'>'+i+'</option>';
			}
		  
			m += '	<select> '
			+ translate('miles') + '.&nbsp;&nbsp;'
			+'<input id='+ setUID('tabAttackMaps_Search') +' type=button value="'+ translate('Search') +'" />'
			+'<br><br>'
			+'	<table class=' + UID['table'] + '>'
			+'		<tr align=center class=' + UID['row_headers'] + '>'
			+'			<td>'+translate('type')+'</td>'
			+'			<td>'+translate('total')+'</td>'
			+'		</tr>';
		
		// Add Search Report
		for (var type in Data.map.terrains){
			m += '<tr>'
			+ '	<td>'+ translate(type) +'</td>'
			+ '	<td align=right><span class=jewel>'+ Data.map.terrains[type].length +'</span></td>'
			+ '</tr>'
		}

		m += '</table></div>';
		
		// Display the inputs
		document.getElementById(UID['tabAttack_Content']).innerHTML = m;

		// add event listeners
		document.getElementById(UID['tabAttackMaps_Search']).addEventListener ('click', butSearchNow, false);
		
		document.getElementById(UID['tabAttackMaps_Radius']).addEventListener ('change', function(ev){
			var el = ev.target;
			Data.map.radius = parseInt(el.options[el.selectedIndex].value);
		}, false);
		
		
		// search the map for the selected type
		function butSearchNow (e){
			actionLog('<B>scanMap</B>: begin');
			var t = Tabs.Attacks;

			var ix=0; iy=0;
			var x = Data.map.position.x;
			var y = Data.map.position.y;
			var radius = Data.map.radius;
			
			var options = {
				//noTerrains	: true,
				//noWildernesses: true,
				//minLevel		: 9,
				//withAlliance	: true,
				//printCSV		: true,
			}

			var steps = parseInt(Math.pow (parseInt(((radius*2)+14)/15),2));
			progressBar.init (800+Math.randRange(1,50), 100, 300, 150, translate('Message'), 200, true, t.container);
			progressBar.start({ steps:steps, delay:1, byCount:true, title:translate('Scanning map')+'...', stepText:translate('Please wait...') });

			Map.scanMap (x,y, radius, function(res){
				if (res == null){
					progressBarPop.getContentDiv().innerHTML = '<B>' + translate('Bummer, there was an error while scanning the map') + '.</B>';
					progressBarPop.allowClose (true);
					Tabs.Attacks.checkMapBusy = false;
					return;
				}
				if(res.done){
					actionLog('<B>scanMap</B>: '+ translate('complete'));
					// Sort by Distance
					for (var type in Data.map.terrains){
						Map.sortByDist(Data.map.terrains,type);
					}

					Tabs.Attacks.checkMapBusy = false;
					progressBarPop.destroy();

					// Refresh the Tab Content
					t.tabAttackMaps();
				}
			}, options);
			
		}
		
	}
};
//*********************************** Attacks Tab *********************************************


//*********************************** Jobs Tab *********************************************
Tabs.Jobs = {
	tabOrder		: JOBS_TAB_ORDER,
	tabLabel		: 'Tasks',
	tabDisabled		: !JOBS_TAB_ENABLE,
	lastSubTab		: 'tabJobInfo',
	container		: null,
	timer			: null,
	contentType		: 0, // 0 = info, 1 = train, 2 = build, 3 = research, 4 = resurrect these should be enums but Javascript doesn't support that type
	trainContentType: 0, // 0 = train, 1 = config
	buildScrollPos	: 0,
	selectedQ		: 'min_housing',

	trainTimer		: null,
	trainStatTimer	: null,
	trainErrorCount : 0,
	trainRetryTime	: 20000,

	buildTimer		: null,
	buildStatTimer	: null,
	buildErrorCount : 0,
	buildRetryTime	: 20000,

	researchTimer	: null,
	researchStatTimer	: null,
	resErrorCount	: 0,
	resRetryTime	: 20000,

	resurrectTimer	: null,
	resurrectStatTimer	: null,
	revErrorCount	: 0,
	revRetryTime	: 20000,
	
	init : function (div){
		var t = Tabs.Jobs;

		Data.setDefaultValues ('jobs');

		// Tab initialization
		t.container = div;
		var m =  '<ul class=tabs>\
			<li class="tab first"><a id=' + setUID('tabJobInfo') + '>'+ translate('Summary') +'</a></li>\
			<li class=tab><a id=' + setUID('tabJobTrain') + '>'+ translate('Train') +'</a></li>\
			<li class=tab><a id=' + setUID('tabJobBuild') + '>'+ translate('Build') +'</a></li>\
			<li class=tab><a id=' + setUID('tabJobResearch') + '>'+ translate('Research') +'</a></li>';
		if (Seed.cities[CAPITAL_ID].souls && Seed.cities[SPECTRAL_OUTPOST_ID])
			m += '<li class=tab><a id=' + setUID('tabJobResurrect') + '>'+ translate('Resurrect') +'</a></li>';
		m += '</ul>\
			<div id=' + setUID('tabJob_Header') + ' style="height:225px; max-height:225px; margin-bottom:5px;"></div>\
			<div id=' + setUID('tabJob_Content') + ' class="' + UID['scrollable'] + '" style="padding-top:5px; height:435px; max-height:700px;"></div>';
		
		div.innerHTML = m;

		document.getElementById(UID['tabJobInfo']).addEventListener ('click', t.tabJobInfo, false);
		document.getElementById(UID['tabJobTrain']).addEventListener ('click', t.tabJobTrain, false);	
		document.getElementById(UID['tabJobBuild']).addEventListener ('click', t.tabJobBuild, false);
		document.getElementById(UID['tabJobResearch']).addEventListener ('click', t.tabJobResearch, false);
		if (Seed.cities[CAPITAL_ID].souls && Seed.cities[SPECTRAL_OUTPOST_ID])
			document.getElementById(UID['tabJobResurrect']).addEventListener ('click', t.tabJobResurrect, false);
		
		// Restore the views
		t.contentType = Data.options.jobs.current_tab;
		t.trainContentType = Data.options.training.current_tab;

		// Enable the jobs
		t.setTrainEnable (Data.options.training.enabled);	
		t.selectedQ = Data.options.training.mode;
		t.setBuildEnable (Data.options.building.enabled);
		t.setResearchEnable (Data.options.research.enabled);
		if (Seed.cities[SPECTRAL_OUTPOST_ID])
			t.setResurrectEnable (Data.options.resurrect.enabled);
		
		// Add the unload event listener
		window.addEventListener('unload', t.onUnload, false);
		
	},

	show : function (){
		var t = Tabs.Jobs;
		
		switch (t.contentType) {
			case 0: t.tabJobInfo(); break;
			case 1: t.tabJobTrain(); break;
			case 2: t.tabJobBuild(); break;
			case 3: t.tabJobResearch(); break;
			case 4:
				if (Seed.cities[SPECTRAL_OUTPOST_ID]) t.tabJobResurrect();
				else t.tabJobInfo();
				break;
		}
	},
	
	hide : function (){
		var t = Tabs.Jobs;
		//t.clearTimers();
	},
	
	onUnload : function () {
		logit('Tabs.Jobs.onUnload');
		var t = Tabs.Jobs;
		Data.options.jobs.current_tab = t.contentType;
		Data.options.training.current_tab = t.trainContentType;
		Data.options.training.mode = t.selectedQ;
	},

	clearTimers : function (){
		var t = Tabs.Jobs;
		clearTimeout (t.jobsStatTimer);
		clearTimeout (t.trainStatTimer);
		clearTimeout (t.buildStatTimer);
		clearTimeout (t.researchStatTimer);
		clearTimeout (t.resurrectStatTimer);
	},
	
	// ** Tab: Jobs - SubTab:  Info
	//--------------------------------------------------------------------
	tabJobInfo : function (){
		var t = Tabs.Jobs;
		document.getElementById(UID[t.lastSubTab]).className ='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabJobInfo']).className ='selected';
		document.getElementById(UID['tabJobInfo']).style.zIndex=1;
		t.lastSubTab = 'tabJobInfo';
		
		t.contentType = 0;
		
		var city = Seed.cities[CAPITAL_ID];

		var n = '<div class=' + UID['title'] + '>'+translate('Info')+'</div>'
			+'	<table width=100%><tr><td><input id='+ setUID('tabJobInfo_Refresh') +' type=button value='+ translate('Refresh') +'></input></td></tr></table>';  // Jawz

		// n += cityTitle(0); // Jawz - put in comment, call to cityTitle done in jobsStatTick
		
		document.getElementById(UID['tabJob_Header']).style.height = "45px";  // Jawz - Set to 63 instead of 45px
		document.getElementById(UID['tabJob_Header']).innerHTML = n;
		document.getElementById(UID['tabJobInfo_Refresh']).addEventListener ('click', refresh, false);  // Jawz
		
		document.getElementById(UID['tabJob_Content']).style.height = "593px";  // Jawz - Set to 593 instead of 610px
		document.getElementById(UID['tabJob_Content']).innerHTML = '<div id="' + setUID('tabJob_Container') + '"></div>'; 

		var container = document.getElementById(UID['tabJob_Container']);
		
		function jobsStatTick(){
			// Main City
			var m = '<div class=' + UID['status_ticker'] + '>'  // Jawz - added border
				+ cityTitle(CAPITAL_ID) // Jawz
				+'<table class=' + UID['table'] + ' width=100%>' // Jawz - Added width=100%
				// Jawz
				+ dispCurrRessources(CAPITAL_ID)
				+ dispDragonJob(CAPITAL_ID) 
				// End Jawz
				+ dispBuildingJob(CAPITAL_ID) 
				// + '<tr><td>&nbsp;</td></tr>' // Jawz - Put in comment
				+ dispResearchJob(CAPITAL_ID) 
				// + '<tr><td>&nbsp;</td></tr>' // Jawz - Put in comment
				+ dispTrainingJobs(CAPITAL_ID) 
				// + '</td></tr></table>'; // Jawz
				+'	</table>'        // Jawz
				+'</div>';

			// Outposts ...
			for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx){
				if(cityIdx != CAPITAL_ID && Seed.cities[cityIdx]){
					m += '<div class=' + UID['status_ticker'] + ' style="margin-top:6px !important">'  // Jawz - added border
					//m += '<div class=short></div>' //Jawz
					+ cityTitle(cityIdx) 
					+'<table class=' + UID['table'] + ' width=100%>' // Jawz - Added width=100%
					+ dispDragonJob(cityIdx)   // Jawz
					+ dispOutpostJob(cityIdx)  // Jawz
					+ dispBuildingJob(cityIdx) 
					+ dispTrainingJobs(cityIdx)
					+ dispResurrectionJobs(cityIdx)
					// + '</td></tr></table>'; // Jawz
					+'	</table>'        // Jawz
					+'</div>';
				}
			}
			
			container.innerHTML = m; 
			container.style.height = container.offsetHeight + 'px';
		}
				
		// Jawz - Display current resources
		function dispCurrRessources (cityIdx){
			var m = '<tr><td class=right width=20%>'+ translate ('Resources') +'</td>';
			var newline = '';
			for (var p=0; p<all_resource_types.length; p++){
				var production = nombreFormate(Seed.cities[cityIdx].figures.resource_rates[all_resource_types[p]].rate);
				var actualStock = nombreFormate(parseInt(Seed.cities[cityIdx].resources[all_resource_types[p]]));
				m += newline + '<td width =15%>'+ translate(all_resource_types[p]) + '</td><td width=1%>:</td><td align=right width=14%>'+ actualStock +'</td><td width=5%> &nbsp </td>'
					+'<td width=10% align=right>('+ production +' /'+ translate('h')+ ')</td><td width=30%> &nbsp </td></tr>';
				newline = '<tr><td> &nbsp </td>'
			}
			var popCur = isEmpty(Seed.cities[cityIdx].figures.population['current'],0);
			var popLab = isEmpty(Seed.cities[cityIdx].figures.population['laborers'],0);
			var popFor = isEmpty(Seed.cities[cityIdx].figures.population['armed_forces'],0);
			var num = popCur - popLab - popFor;
			num = (num < 0) ? 0 : num;
			m += '<tr><td> &nbsp </td><td width =15%>' + translate('Idle pop') + '</td><td width=1%>:</td><td align=right width=14%>' + nombreFormate(num,' ') + '</td><td width=50% colspan=3> &nbsp </td></tr>';
			m += '</table><br><table class=' + UID['table'] + ' width=100%>';
			return m;
		}
		// Jawz - Display dragon healing jobs
		function dispDragonJob (cityIdx){
			var m = '';
			var job = getDragonJob (cityIdx);
			if (job && job.run_at > serverTime()) {
				m += '<tr><td class=right width=20%>' + translate('Healing') + ':</td>'
				  +  '<td width=50%><SPAN class=' + UID['bold_red'] + '>'+ translate ('Dragon healing') + '</span></td><td width=30%><font color=' + TIMER_COLOR + '>'+ timestr(job.run_at - serverTime(), true) +'</font></td></tr>';
			}
			return m;
		}
		// Jawz - Display outpost repairing jobs
		function dispOutpostJob (cityIdx){
			var m = '';
			var job = getOutpostJob (cityIdx);
			if (job && job.run_at > serverTime()) {
				m += '<tr><td class=right width=20%>' + translate('Repairing') + ':</td>'
				  +  '<td width=50%><SPAN class=' + UID['bold_red'] + '>'+ translate ('Outpost damages') + '</span></td><td width=30%><font color=' + TIMER_COLOR + '>'+ timestr(job.run_at - serverTime(), true) +'</font></td></tr>';
			}
			return m;
		}
		// End Jawz

		// Display build queue
		function dispBuildingJob (cityIdx){
			// var m = '<tr><td class=right><b>'+ translate('Building') +':</b> </td>';        // Jawz
			var m = '<tr><td width=20% class=right>'+ translate('Building') +': </td>'; // Jawz
			var job = getBuildingJob (cityIdx);
			
			// TODO: very rare occurance: Error: job.building is null
			if (job && job.job.run_at > serverTime())
			{
				// Don't show negative values - not pleasant user interface. To be truly nice, if the time is less than zero, we should reset 
				// the build timer. For now, that is done by the Build tab's notification process
				// m += '<td align=right>'+ translate(job.building.type) +' ('+ job.job.level +') &nbsp;</td>'                      // Jawz
				//  + '<td>&nbsp;<font color=' + TIMER_COLOR + '>' + timestr(job.job.run_at - serverTime(), true) + '</font></td>'  // Jawz
				m += '<td width=50% align=left>'+ translate(job.building.type) +' ('+ job.job.level +') &nbsp;</td>'                // Jawz
				  + '<td width=30%><font color=' + TIMER_COLOR + '>' + timestr(job.job.run_at - serverTime(), true) + '</font></td>' // Jawz
				  + '</tr>';
			} else {
				// m += '<td align=right colspan=2><span class=' + UID['bold_red'] + '>' + translate('None').toUpperCase() + '</span></td></tr>';        // Jawz
				m += '<td align=left width=80% colspan=2><span class=' + UID['bold_red'] + '>' + translate('None').toUpperCase() + '</span></td></tr>';  // Jawz
			}
			return m;
		}
		
		// Display research queue
		function dispResearchJob (cityIdx){
			var m = '<tr>'
				// + '		<td class=right><b>'+ translate('Researching') +': </b></td>';       // Jawz
				+ '		<td class=right width=20%>'+ translate('Researching') +': </td>'; // Jawz
				
			var job = getResearchJob (cityIdx);
			if (job && job.run_at > serverTime())
			{
				// m += '<td align=right>'+ translate(job.research_type) +' ('+ job.level +') &nbsp;</td>'                      // Jawz
				//  + '<td>&nbsp;<font color=' + TIMER_COLOR + '>' + timestr(job.run_at - serverTime(), true) + '</font></td>'  // Jawz
				m += '<td width=50% align=left>'+ translate(job.research_type) +' ('+ job.level +') &nbsp;</td>'                // Jawz
				  + '<td width=30%><font color=' + TIMER_COLOR + '>' + timestr(job.run_at - serverTime(), true) + '</font></td>' // Jawz
				  +'</tr>';
			} else {
				// m += '<td align=right  colspan=2><span class=' + UID['bold_red'] + '>' + translate('None').toUpperCase() + '</span></td></tr>';       // Jawz
				m += '<td align=left width=80% colspan=2><span class=' + UID['bold_red'] + '>' + translate('None').toUpperCase() + '</span></td></tr>';  // Jawz
			}
			return m;
		}
		
		// Display training queues
		function dispTrainingJobs (cityIdx){
			var m = '', last = serverTime(), trains = [];
			for (var i=0; i < Seed.cities[cityIdx].jobs.length; i++){
				if (Seed.cities[cityIdx].jobs[i].queue=='units' && 
					Seed.cities[cityIdx].jobs[i].unit_type && 
					Seed.cities[cityIdx].jobs[i].run_at > last
					){
						trains.push (Seed.cities[cityIdx].jobs[i]);
				}
			}
			trains.sort(function(a,b){return a.run_at-b.run_at});
			
			for (var i=0; i < trains.length; i++){
				var left='', tot='', timeRemaining = 0;
				if (i==0){
					left = translate('Training') + ':';
				}
				else if (i==trains.length-1) {
					timeRemaining = (trains[i].run_at-serverTime() > 0) ? trains[i].run_at-serverTime() : 0;
					tot = '&nbsp;<b>(' + timestrShort(timeRemaining) + ')</b>';
				}
				
				timeRemaining = (trains[i].run_at-last > 0) ? trains[i].run_at-last : 0;
                // Jawz - Modified layout
				// m += '<tr>'
				// + '		<td class=right><b>' + left + '</b>&nbsp;</td>'
				// + '		<td align=right>' + trains[i].quantity + '&nbsp;&nbsp;' + translate(trains[i].unit_type) + '&nbsp;</td>'
				// + '		<td>&nbsp;<font color=' + TIMER_COLOR + '>'
				// + timestr(timeRemaining, true) + tot + '</font></td>'
				// +'</tr>';
				m += '<tr>'
				+ '		<td class=right width=20%>' + left + '</td>'
				+ '		<td align=left width=50%>' + nombreFormate(trains[i].quantity, ' ') + '&nbsp;&nbsp;' + translate(trains[i].unit_type) + '&nbsp;</td>'
				+ '     <td width=30%><font color=' + TIMER_COLOR + '>' + timestr(timeRemaining, true) + '</font>&nbsp' + tot + '</td>'
				+ '</tr>';
				last = trains[i].run_at;
			}      
			return m;
		}
		
		function dispResurrectionJobs (cityIdx){
			var m = '', last = serverTime(), trains = [];
			for (var i=0; i < Seed.cities[cityIdx].jobs.length; i++){
				if (Seed.cities[cityIdx].jobs[i].queue=='resurrection' && 
					Seed.cities[cityIdx].jobs[i].unit_type && 
					Seed.cities[cityIdx].jobs[i].run_at > last
					){
						trains.push (Seed.cities[cityIdx].jobs[i]);
				}
			}
			trains.sort(function(a,b){return a.run_at-b.run_at});
			for (var i=0; i < trains.length; i++){
				var left='', tot='', timeRemaining = 0;
				if (i==0){
					left = translate('Resurrection') + ':';
				}
				else if (i==trains.length-1) {
					timeRemaining = (trains[i].run_at-serverTime() > 0) ? trains[i].run_at-serverTime() : 0;
					tot = '&nbsp;<b>(' + timestrShort(timeRemaining) + ')</b>';
				}
				timeRemaining = (trains[i].run_at-last > 0) ? trains[i].run_at-last : 0;
				m += '<tr>'
				+ '		<td class=right width=20%>' + left + '</td>'
				+ '		<td align=left width=50% colspan=2>' + nombreFormate(trains[i].quantity, ' ') + '&nbsp;&nbsp;' + translate(trains[i].unit_type) + '&nbsp;</td>'
				+ '     <td width=30%><font color=' + TIMER_COLOR + '>' + timestr(timeRemaining, true) + '</font>&nbsp' + tot + '</td>'
				+ '</tr>';
				last = trains[i].run_at;
			}      
			return m;
		}

		function cityTitle (cityIdx){
			var city = Seed.cities[cityIdx];
			// Outposts are always defending (until further notice)
			var wallStatus = '';
			var alliance_name = (Seed.player.alliance) ? Seed.player.alliance.name : '';
			alliance_name = (city.type == kOutpost) ? '' : alliance_name;
			
			if (cityIdx == CAPITAL_ID){
				wallStatus = (Seed.cities[cityIdx].defended!=undefined && Seed.cities[cityIdx].defended) ? '<font class='+ UID['defending'] +'>'+ translate('Defend').toUpperCase() +'</font>' : '<font class='+ UID['hiding'] +'>'+ translate('Hiding').toUpperCase() +'</font>';
			}
			else {
				// wallStatus = '<font class='+ UID['defending'] +'>'+ translate('Defend').toUpperCase() +'</font>';  // Jawz - Do not show wallstatus for outposts
				wallStatus = ' &nbsp ';  // Jawz
			}
			var title = ''
				+'<div class=' + UID['subtitle'] + '>'
				+'	<table class=' + UID['table'] + '>'
				+'	<tr>'
				+'		<td align=left width=35%>'+ ( (city.type == kOutpost) ? translate(city.name) : city.name ) +'</td>'  // Jawz - Added width=35%
				+'		<td align=center width=30%>'+ city.x +','+ city.y + '</td>'  // Jawz - Added width=30%
				+'		<td align=center width=200px>'
				+'			<font color=yellow>' + alliance_name +'</font>'
				+'		</td>'
				+'		<td width=35% align=right>'+ wallStatus +'</td>'  // Jawz - Changed 80px by 35%
				+'	</tr>'
				+'</table></div>';
			return title;
		}

		// Jawz
		function refresh (){
			logit('fetchPlayer from Tab.Jobs refresh');
			var t = Tabs.Jobs;
			Seed.fetchPlayer (t.tabJobInfo());  
		}
		// End Jawz

		// First run of jobsStatTick
		jobsStatTick();
		
		// Timers
		t.clearTimers();
		t.jobsStatTimer = setInterval (jobsStatTick, 1000);
	},

	
	//----------------------------------------------------------------------------
	//*** Jobs Tab - Train Sub-tab ***
	//----------------------------------------------------------------------------
	tabJobTrain : function (){
		var t = Tabs.Jobs;
		document.getElementById(UID[t.lastSubTab]).className ='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabJobTrain']).className ='selected';
		document.getElementById(UID['tabJobTrain']).style.zIndex=1;
		t.lastSubTab = 'tabJobTrain';
		
		t.contentType = 1;
		
		// Create status ticker
		var n = '<div class=' + UID['title'] + '>'+ translate('Train') +' '+ translate('Automatically') +'</div>'
		+'<div class=' + UID['status_ticker'] + ' style="margin-bottom: 5px !important">'
		+'	<center><input id=' + setUID('tabJobTrain_OnOff') + ' type=button /></center>'
		+'	<div id=' + setUID('tabJobTrain_Report') + ' class='+ UID['status_report'] +'></div>'
		+'	<br>'
		+'	<div id='+ setUID('tabJobTrain_Feedback') +' class='+ UID['status_feedback'] +'></div>'
		+'</div>'
		+'<ul class=tabs>'
		+'	<li class="tab first"><a id='+ setUID('tabJobTrain_tabTrain') +'>'+ translate('Train') +'</a></li>'
		+'	<li class="tab"><a id='+ setUID('tabJobTrain_tabConfig') +'>'+ translate('Config') +'</a></li>'
		+'</ul>';
		document.getElementById(UID['tabJob_Header']).style.height = "225px";
		document.getElementById(UID['tabJob_Header']).innerHTML = n;
		
		// var m = '<DIV id='+ setUID('tabJobTrain_Content')+ ' style="margin-top:5px;padding-top: 3px;" class="' + UID['content'] + ' ' + UID['scrollable'] +'">'; // Jawz
		var m = '<div id='+ setUID('tabJobTrain_Content') +' style="height:430px; ; max-height:430px; overflow-y:auto">'; // + UID['scrollable'] +'>';              // Jawz

		document.getElementById(UID['tabJob_Content']).style.height = "430px";
		document.getElementById(UID['tabJob_Content']).innerHTML = m;
		
		// Add event listener for Enabled/off button
		document.getElementById(UID['tabJobTrain_OnOff']).addEventListener ('click', function (){
			var t=Tabs.Jobs;
			t.setTrainEnable (!Data.options.training.enabled);
		}, false);
		document.getElementById(UID['tabJobTrain_tabTrain']).addEventListener ('click', t.tabJobTrainSets, false);
		document.getElementById(UID['tabJobTrain_tabConfig']).addEventListener ('click', t.tabJobTrainConfig, false);
		t.refreshTrainButton (Data.options.training.enabled);
		
		switch (t.trainContentType) {
			case 0: t.tabJobTrainSets(); break;
			case 1: t.tabJobTrainConfig(); break;
		}
		
		//First Run of trainStatTick
		t.trainStatTick();
		
		// Timers
		t.clearTimers();
		t.trainStatTimer = setInterval(t.trainStatTick, 1000);
	},

	
	//*** Jobs Tab - Train Sub-tab  - Train Sub-Sub-tab ***
	//----------------------------------------------------------------------------
	tabJobTrainSets : function(){
		var t = Tabs.Jobs;
		// Create troop table for each city
		var el = [], m = '', cl = [], tn = [], en = [];
		for (var cityIdx=0; cityIdx<Seed.cities.length; cityIdx++) {
			if (Data.options.collapsed.train[cityIdx] == undefined) {
				Data.options.collapsed.train[cityIdx] = false;
			}
		}
		for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx){
			if (Seed.cities[cityIdx] && cityIdx != SPECTRAL_OUTPOST_ID) {
				switch (cityIdx) {
					case CAPITAL_ID			: troopTypes = capital_units; break;
					case WATER_OUTPOST_ID	: troopTypes = water_outpost_units; break;
					case STONE_OUTPOST_ID	: troopTypes = stone_outpost_units; break;		
					case FIRE_OUTPOST_ID	: troopTypes = fire_outpost_units; break;	
					case WIND_OUTPOST_ID	: troopTypes = wind_outpost_units; break;				
					default: break;
				}
				var city = Seed.cities[cityIdx];
				var cityJobsId = 'tabJobTrain_cityId_' + cityIdx;
				var cityJobsListId = 'tabJobTrain_cityList_' + cityIdx;
				var cityJobsEnabled = 'tabJobTrain_Enabled_' + cityIdx;
				// Retrieve current total time of queued trainings for display in city title
				var current_total_time = 0;
				var now  = serverTime();
				if (city.jobs) {
					var jobs = city.jobs;
					var trains = [];
					for (var j=0; j < jobs.length; j++)
						if (jobs[j].queue=='units' && jobs[j].unit_type && jobs[j].run_at > now) trains.push (jobs[j]);
					if (trains.length > 0) {
						trains.sort( function(a,b){ return a.run_at - b.run_at; } );
						var current_total_time = trains[trains.length-1].run_at - now;
					}
				}
				m += '<div class=' + UID['status_ticker'] + ' style="margin-top:10px !important">'  // Jawz - added border
				+'<A><div id=' + setUID(cityJobsId) + ' class=' + UID['subtitle'] + ' ref=' + cityIdx + '>'
				+'	<table class=' + UID['table'] + ' width=100%>'
				+'	<tr>'
				+'		<td align=left width=1%><label><input type=checkbox id='+ setUID(cityJobsEnabled) +' ref="Enable_'+ cityIdx +'" '+ (Data.options.training.city[cityIdx].enabled?'checked':'') +' /></label></td>'
				+'		<td align=left width=29%>&nbsp</td>'
				+'		<td align=center width=40%>'+ ( (city.type == kOutpost) ? translate(city.name) : city.name ) + '</td>'
				+'		<td align=right width=30%>'
				+'			<font color=yellow>' + timestrShort(current_total_time) +'</font>'
				+'		</td>'
				+'	</tr>'
				+'</table></div></A>'
				+'<div id=' + setUID(cityJobsListId) + '>'
				+'<table class=' + UID['table'] + ' width=100%>'
				+'	<tr class='+UID['row_headers']+'>'
				+'		<td></td><td>'+translate('Quantity')+'</td><td>'+translate('Total')+'</td></tr>';
				cl.push(UID[cityJobsId]);
				en.push(UID[cityJobsEnabled]);
			
				var i;
				// Jawz
				for (i=0; i < troopTypes.length; i++){
					var num = Data.options.training.city[cityIdx].units[i];
					if (!num || isNaN(num)){
						num = 0;
					}
					m += '<tr>'
					+'		<td class=right width=25%>'+ translate(troopTypes[i]) +':</td>'
					+'		<td align=middle width=10%><input type=text id='+ setUID('tabTrain_Troop_'+ cityIdx +'_'+ i) +' ref='+ cityIdx +'_'+ i +' maxlength=6 size=2 value="'+ num +'" style="width:45px;text-align:right;" /></td>'
					+'		<td align=right width=15%>&nbsp;<span class=jewel>('+ nombreFormate(getTroopNumbers(Seed.cities[CAPITAL_ID], troopTypes[i]).total,' ') +')</span></td>'
					+'		<td align=left width=40% id='+ setUID('tabJobTrain_FB_'+cityIdx +'_'+ troopTypes[i]) +' class=jewel valign=top style="white-space:normal;"></td>' //width:250px;
					+'		<td align=right width=10%><input class=small id=' + setUID('tabTrain_Now_'+cityIdx +'_'+ i) + ' ref=' + cityIdx +'_'+ i + ' type=button  style="width:auto !important;" value="'+ translate('Train') +'" \></td>'
					+'	</tr>';
					el.push(UID['tabTrain_Troop_'+ cityIdx +'_'+ i]);
					tn.push(UID['tabTrain_Now_'+ cityIdx +'_'+ i]);
				}
				m += '</table></div></div>'; // Jawz
			}
		}
		m += '</div>';
		document.getElementById(UID['tabJobTrain_Content']).innerHTML = m;

		// Hilite the sub-tabs correctly
		document.getElementById(UID['tabJobTrain_tabConfig']).className = '';
		document.getElementById(UID['tabJobTrain_tabConfig']).style.zIndex=0;
		document.getElementById(UID['tabJobTrain_tabTrain']).className = 'selected';
		document.getElementById(UID['tabJobTrain_tabTrain']).style.zIndex=1;

		t.trainContentType = 0;

		for (var c=0; c<cl.length; c++) {
			document.getElementById(cl[c]).addEventListener('click', toggleHideShow, false);
			var cityIdx = document.getElementById(cl[c]).getAttribute('ref');
			var div_id = 'tabJobTrain_cityList_' + cityIdx;
			var div_el = document.getElementById(UID[div_id]);
			if (Data.options.collapsed.train[cityIdx])
				div_el.style.display = 'none';
			else
				div_el.style.display = 'block';
		}
		// Add event listeners for troop quantities 
		for (var i=0; i < el.length; i++){
			document.getElementById(el[i]).addEventListener('change', troopsChanged, false);
			document.getElementById(el[i]).addEventListener('click', troopsChanged, false);
		}

		// Add event listeners for "train now" buttons
		for (var i=0; i < tn.length; i++){
			document.getElementById(tn[i]).addEventListener('click', onTrainNow, false);
		}

		// Add event listeners for "enable" city checkbox
		for (var i=0; i < en.length; i++){
			document.getElementById(en[i]).addEventListener('change', onEnableCityNow, false);
			document.getElementById(en[i]).addEventListener('click', onEnableCityNow, false);
		}

		// Update troops on change
		function troopsChanged (event){
			var args = event.target.getAttribute('ref').split('_');
			var unitQty = parseIntZero(event.target.value);
			var cityIdx = parseInt(args[0]);
			var unitType;
			switch (cityIdx) {
				case CAPITAL_ID			 : unitType = capital_units[args[1]]; break;
				case WATER_OUTPOST_ID	 : unitType = water_outpost_units[args[1]]; break;
				case STONE_OUTPOST_ID	 : unitType = stone_outpost_units[args[1]]; break;
				case FIRE_OUTPOST_ID	 : unitType = fire_outpost_units[args[1]]; break;
				case WIND_OUTPOST_ID	 : unitType = wind_outpost_units[args[1]]; break;
			}
			var reqs = t.checkTrainReqs(unitType, unitQty, cityIdx);
			if (isNaN(unitQty) || unitQty < 0){
				event.target.style.backgroundColor = 'red';
				dispError (translate('Invalid number of troops',t.container));
			} else {
				event.target.value = unitQty;
				Data.options.training.city[args[0]].units[args[1]] = unitQty;
				event.target.style.backgroundColor = '';
			}
		}

		function onEnableCityNow (evt){
			var cityIdx = evt.target.getAttribute('ref').split('_');
			Data.options.training.city[cityIdx[1]].enabled = evt.target.checked;
		}

		function onTrainNow (event){
			var args = event.target.getAttribute('ref').split('_');
			var cityIdx = parseInt(args[0]);
			var unitType;
			switch (cityIdx) {
				case CAPITAL_ID			 : unitType = capital_units[args[1]]; break;
				case WATER_OUTPOST_ID	 : unitType = water_outpost_units[args[1]]; break;
				case STONE_OUTPOST_ID	 : unitType = stone_outpost_units[args[1]]; break;
				case FIRE_OUTPOST_ID	 : unitType = fire_outpost_units[args[1]]; break;
				case WIND_OUTPOST_ID	 : unitType = wind_outpost_units[args[1]]; break;
			}
			var unitQty = Data.options.training.city[cityIdx].units[args[1]];
			if (unitQty > 0) {
				cap = t.getTroopCap(unitType, unitQty);
				try {
					if (cap) {
						unitQty = 0;
						if (t.contentType == 1){
							t.dispFeedback(translate('Troops Capped'));
						}
						document.getElementById(UID['tabTrain_Troop_'+ cityIdx +'_'+ j]).style.backgroundColor = "red";
					}
					else if (t.contentType == 1){
						if (document.getElementById(UID['tabTrain_Troop_'+ cityIdx +'_'+ j]).style.backgroundColor == "red"){
							document.getElementById(UID['tabTrain_Troop_'+ cityIdx +'_'+ j]).style.backgroundColor = "white";
						}
					}
				} catch (e) {}
			}
			if (unitQty > 0) {
				var reqs = t.checkTrainReqs(unitType, unitQty, cityIdx);
				if (t.contentType == 1 && !reqs.msg){
					t.dispFeedback (translate('Training') + ' ' + nombreFormate(unitQty, ' ') + ' ' + translate(unitType) + ' (' + translate('UpKeep') + ' ' + (unitQty * Seed.stats.unit[unitType].upkeep.food) + ' ' + translate('Food') + ')');
				}
				if (!reqs.msg) t.doTrain(unitType, unitQty, cityIdx);
			}

		}
		
		function toggleHideShow (evt){
			// Do not collapse or uncollapse when clicking on the city enble checkbox
			if (evt.target.getAttribute('ref')) {
				var target_ref = evt.target.getAttribute('ref').split('_');
				if (target_ref[0] = 'Enable') return;
			}
			if (evt.target.tagName == 'DIV')
				element = evt.target;
			else {
				var parentElement = evt.target.parentNode;
				while (parentElement.tagName != 'DIV') {
					parentElement = parentElement.parentNode;
				}
				element = parentElement;
			}
			var cityIdx = element.getAttribute('ref');
			var div_id = 'tabJobTrain_cityList_' + cityIdx
			var div_el = document.getElementById(UID[div_id]);
			if (div_el.style.display == 'none') {
				div_el.style.display = 'block';
				Data.options.collapsed.train[cityIdx] = false;
			} else {
				div_el.style.display = 'none';
				Data.options.collapsed.train[cityIdx] = true;
			}
		}
	}, 
	
	// config sub tab
	tabJobTrainConfig : function(){
		var t = Tabs.Jobs;
		
		// Hilite the sub-tabs correctly
		document.getElementById(UID['tabJobTrain_tabTrain']).className = '';
		document.getElementById(UID['tabJobTrain_tabTrain']).style.zIndex = 0;
		document.getElementById(UID['tabJobTrain_tabConfig']).className = 'selected';
		document.getElementById(UID['tabJobTrain_tabConfig']).style.zIndex = 1;

		t.trainContentType = 1;
		
		var m = '<div class=' + UID['status_ticker'] + ' style="margin-top:6px !important">'  // Jawz - added border
			+	'<div class=' + UID['subtitle'] + '>'+ translate('Training Configuration') +'</div>'
			+	'	<div class="' + UID['scrollable'] + '">'
			+	'		<table class=' + UID['table'] + '>'
			+	'		<tr align=center class=' + UID['row_headers'] + '>'
			+	'			<td style="background:none !important;" colspan=2></td>'
			+	'		</tr>';
		
		// Add the radio buttons 
		setUID('tabTrainConfig_QRadio');		
		m += '	<tr>'
		  +	'		<td><label><input type=radio name='+ UID['tabTrainConfig_QRadio'] +' value="min_housing" />'+ translate('Only one training queue per city') +'</label></td>'
		  + '	</tr>'
		  + '	<tr>'
		  + '		<td><label><input type=radio name='+ UID['tabTrainConfig_QRadio'] +' value="min_resource" />'+ translate('Maximum training queues possible per city, according to available resources') +'</label></td>'
		  + '	</tr>'
		  + '	</table>'
		  + '</div>'
		  + '<br>';  // Jawz
		
		// Create an all troop table
		var el = [];
		var troopTypes = all_trainable_units;

		m += '<div class=' + UID['subtitle'] + ' style="background-color:#0044a0;">'+ translate('Maximum Troops') +' (0 = '+translate('no max') +')</div>'  // Jawz - Added translation for no max
		  +	'	<table class=' + UID['table'] + ' width=100%>'
		  + '		<tr valign=top>'
		  + '			<td width=33%>'  // Jawz - Set to 33% instead of 150px
		  + '			<table class=' + UID['table'] + ' width=100%>';
		
		var i;
		// Jawz
		var nbre1 = Math.ceil(troopTypes.length/2);
		//var nbre2 = Math.ceil(troopTypes.length/3) + Math.ceil((troopTypes.length - Math.ceil(troopTypes.length/3))/2);
		for (i=0; i < nbre1; i++){
			m += '<tr>'
			  +  '	<td class=right width=70%>'+ translate(troopTypes[i]) +':</td>';
			var num = Data.options.training.city[0].cap[i];
			if (!num || isNaN(num)) num = 0;
			m += '<td width=30%><input type=text id='+ setUID('tabTrainConfig_Cap_'+ 0 +'_'+ i) +' ref='+ (0 +'_'+ i) +' maxlength=8 size=2 value="'+ num +'" style="width:60px;text-align:right;" /></td>'
			  + '</tr>';
			el.push(UID['tabTrainConfig_Cap_'+ 0 +'_'+ i]);
		}
		m += '</table></td>'
		  + '	<td width=33%>'
		  + '	<table class=' + UID['table'] + ' width=100%>';
/*		for (i=nbre1; i < nbre2; i++){
			m += '<tr>'
			  +  '	<td class=right width=70%>'+ translate(troopTypes[i]) +':</td>';
			var num = Data.options.training.city[0].cap[i];
			if (!num || isNaN(num)) num = 0;
			m += '<td width=30%><input type=text id='+ setUID('tabTrainConfig_Cap_'+ 0 +'_'+ i) +' ref='+ (0 +'_'+ i) +' maxlength=6 size=2 value="'+ num +'" style="width:60px;text-align:right;" /></td>'
			  + '</tr>';
			el.push(UID['tabTrainConfig_Cap_'+ 0 +'_'+ i]);
		}
		m += '</table></td>'
		  + '	<td width=33%>'
		  + '	<table class=' + UID['table'] + ' width=100%>';
*/		// End Jawz
		for (i=nbre1; i < troopTypes.length; i++){ // Jawz - nbre2 instea of 0
			m += '<tr>'
			  +  '	<td class=right width=70%>'+ translate(troopTypes[i]) +':</td>';  // Jawz - Added width=70% & replaced class=left by right
			
			var num = Data.options.training.city[0].cap[i];
			if (!num || isNaN(num)){
				num = 0;
			}
			
			m += '<td width=30%>'   // Jawz - Added width=30%
			  + '<input type=text id='+ setUID('tabTrainConfig_Cap_'+ 0 +'_'+ i) +' ref='+ (0 +'_'+ i) +' maxlength=8 size=2 value="'+ num +'" style="width:60px;text-align:right;" /></td>'
			  + '</tr>';

			el.push(UID['tabTrainConfig_Cap_'+ 0 +'_'+ i]);
		}

		m += '			</table>'
		  + '			</td>'
		  + '		</tr>'
		  + '	</table>'
		  + '</div>' // Jawz
		  + '</div>';
		
		// Display the page
		document.getElementById(UID['tabJobTrain_Content']).innerHTML = m;

		// add event listeners for the radio buttons
		var r = document.getElementsByName(UID['tabTrainConfig_QRadio']);
		for (var i=0; i < r.length; i++)
		{
			r[i].addEventListener('change', enableChanged, false);
			// Select the radio button that was last selected
			r[i].checked = (r[i].value == Data.options.training.mode);
		}

		// Add event listeners for troop quantities 
		for (var i=0; i < el.length; i++) {
			document.getElementById(el[i]).addEventListener('change', troopsChanged, false);
		}

		// radio buttons are weird    
		function enableChanged(e){
			var t = Tabs.Jobs;
			
			if (Data.options.training.enabled) {
				t.setTrainEnable(false); // It would be very bad to leave training on when switching queue types. 
				if (t.contentType == 1){
					t.dispFeedback (translate('Safe Mode') +' '+ translate('Training') +' '+ translate('Turned Off'));
				}
			}
			
			t.selectedQ = e.target.value;
			Data.options.training.mode = e.target.value;
		}
		
		// Update troops on change
		function troopsChanged (e){
			var args = e.target.getAttribute('ref').split('_');
			var x = parseIntZero(e.target.value);
			
			// The upper limit is not important because we are looking at a maximum number of troops
			if (isNaN(x) || x < 0){
				e.target.style.backgroundColor = 'red';
				dispError (translate('Invalid number of troops',t.container));
			} 
			else {
				e.target.value = x;
				Data.options.training.city[args[0]].cap[args[1]] = x;
				e.target.style.backgroundColor = '';
			}
		}
	},


	//----------------------------------------------------------------------------
	//*** Jobs Tab - Build Sub-tab ***
	//----------------------------------------------------------------------------
	tabJobBuild : function (){
		var t = Tabs.Jobs;
		document.getElementById(UID[t.lastSubTab]).className ='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabJobBuild']).className ='selected';
		document.getElementById(UID['tabJobBuild']).style.zIndex=1;
		t.lastSubTab = 'tabJobBuild';
		
		t.contentType = 2;
		
		var n = '<div class=' + UID['title'] + '>'+ translate('Build') +' '+ translate('Automatically') +'</div>'
		+'<div class=' + UID['status_ticker'] + '>'
		+'	<center><input id='+ setUID('tabJobBuild_OnOff') +' type=button /></center>'
		+'	<div id='+ setUID('tabJobBuild_Report') +' class='+UID['status_report']+'></div>'
		+'	<br>'
		+'	<div id='+ setUID('tabJobBuild_Feedback') +' class='+ UID['status_feedback'] +'></div>'
		+'</div>';
		document.getElementById(UID['tabJob_Header']).style.height = "205px";
		document.getElementById(UID['tabJob_Header']).innerHTML = n;
		
		document.getElementById(UID['tabJob_Content']).innerHTML = '<div id='+ setUID('tabJobBuild_Content') +'>';
		document.getElementById(UID['tabJob_Content']).style.height = "455px";
		
		m = '';
		
		var el = [], listC = [], listF = [], cl = [];
		for (var cityIdx=0; cityIdx<Seed.cities.length; cityIdx++) {
			if (Data.options.collapsed.build[cityIdx] == undefined) {
				Data.options.collapsed.build[cityIdx] = false;
			}
		}
		for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx) {
			switch (cityIdx) {
				case CAPITAL_ID :
					listC = capital_buildings;
					listF = field_buildings;
					break;
				case SPECTRAL_OUTPOST_ID : // Jawz - Spectral outpost
					listC = spectral_buildings;
					listF = spectral_fields;
					break;
				default :
					listC = outpost_buildings;
					listF = field_buildings;
					break;
			}
			
			// The seed object contains a wealth of information including alliance membership, number of people in the alliance, facebook ids of each member,
			// the ol's information (in alliances and alliance_membership), the s object contains all the buildings for the cities, whether or not the city is
			// on defense, the list of generals, what and where the dragon is, a list of jobs (e.g. research, building, troops training and pending training, current marches)
			// the marches alone say where the troops are, whether or not they are returning or attacking, general assigned, etc.
			
			if (Seed.cities[cityIdx]) {
				var city = Seed.cities[cityIdx];
				var cityBuildId = 'tabJobBuild_cityId_' + cityIdx;
				var cityBuildListId = 'tabJobBuild_cityList_' + cityIdx;
				m += '<div class=' + UID['content'] + ' style="margin-bottom:5px;">'
				// + '<div class=' + UID['subtitle'] + '>'+ translate('City') + '&nbsp;' + (cityIdx + 1) +'º ('+ city.type +')</div>'
				+ '<A><div id=' + setUID(cityBuildId) + ' class=' + UID['subtitle'] + ' ref=' + cityIdx + '>'+ ( (city.type == kOutpost) ? translate(city.name) : city.name ) +'</div></A>'
				+ '<div id=' + setUID(cityBuildListId) + '>'
				+'<table class=' + UID['table'] + '>';
				cl.push(UID[cityBuildId]);
			
				for (var i=0; i < listF.length; ++i)
				{
					m += '	<tr>'
					+'			<td>'
					+'			<label><input type=checkbox id='+ setUID('tabJobBuild_CB_'+ (cityIdx +'_'+ listF[i])) +' ref='+ (cityIdx +'_'+ listF[i]) +' '+ (Data.options.building.level_enable[cityIdx][listF[i]]?'checked':'') +' /> '+ translate(listF[i]) +'</label>'
					+'			<td>'
					+'			&nbsp;<span class=jewel>'+ (Buildings.getLevel(cityIdx, listF[i])).min + '</span>'
					+'			</td>'
					+'			</td>'
					+'			<td>'+ buildDisplayCap(cityIdx,(listC.length + i),listF[i]) +'</td>'
					+'		</tr>';  
					el.push(UID['tabJobBuild_CB_'+ (cityIdx +'_'+ listF[i])]);
				}
			
				m += '<tr><td colspan=5><hr></td></tr>';
			
				for (var i=0; i < listC.length; ++i)
				{
					m += '	<tr>'
					+'			<td>'
					+'			<label><input type=checkbox id='+ setUID('tabJobBuild_CB_'+ (cityIdx +'_'+ listC[i])) +' ref='+ (cityIdx +'_'+ listC[i]) +' '+ (Data.options.building.level_enable[cityIdx][listC[i]]?'checked':'') +' /> '+ translate(listC[i]) +'</label>'
					+'			</td>'
					+'			<td>'
					+'			&nbsp;<span class=jewel>'+ (Buildings.getLevel(cityIdx, listC[i])).min + '</span>'
					+'			</td>'
					+'			<td>'+ buildDisplayCap(cityIdx,i,listC[i]) +'</td>'
					+'		</tr>';  
					el.push(UID['tabJobBuild_CB_'+ (cityIdx +'_'+ listC[i])]);
				}
			
				m +='</table></div></div>';
			}
		}
		m += '</div>';
		
		var container = document.getElementById(UID['tabJobBuild_Content']);
		
		container.style.height = container.offsetHeight + 'px';
		container.innerHTML = m;
		
		//document.getElementById(UID['tabJob_Content']).scrollTop = t.buildScrollPos; // CHECK
		
		for (var c=0; c<cl.length; c++) {
			document.getElementById(cl[c]).addEventListener('click', toggleHideShow, false);
			var cityIdx = document.getElementById(cl[c]).getAttribute('ref');
			var div_id = 'tabJobBuild_cityList_' + cityIdx;
			var div_el = document.getElementById(UID[div_id]);
			if (Data.options.collapsed.build[cityIdx])
				div_el.style.display = 'none';
			else
				div_el.style.display = 'block';
		}
		// Add the event listeners for each city's building types
		for (var i=0; i < el.length; i++) {
			document.getElementById(el[i]).addEventListener('click', checkedBuild, false);
		}
		
		// Add the event listeners for each city's building type caps
		// And restore the persistent data since it has to be done in the same loop
		for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx)
		{
			if (Seed.cities[cityIdx]) {
				var buildList;
				switch (cityIdx) {
					case CAPITAL_ID : buildList = capital_buildings.concat(field_buildings); break;
					case SPECTRAL_OUTPOST_ID : buildList = spectral_buildings.concat(spectral_fields); break;
					default : buildList = outpost_buildings.concat(field_buildings); break;
				}
				for (var i=0; i < buildList.length; ++i)
				{
					var selectMenu = document.getElementById(UID['tabJobBuild_Cap_'+ cityIdx + '_' + buildList[i]]);
					try {
						if (!Data.options.building.level_cap[cityIdx][i]) {
							// var lowestBuildingLevel = t.getCurrentLowestBuildingLevel(cityIdx, buildList[i]);
							var lowestBuildingLevel = (Buildings.getLevel( cityIdx, buildList[i])).min;
							//var lowestBuildingLevel = isEmpty(t.getCurrentLowestBuildingLevel(cityIdx, buildList[i]),9);  // Jawz - Set cap to 9 by default
							selectMenu.selectedIndex = lowestBuildingLevel;
							Data.options.building.level_cap[cityIdx][i] = lowestBuildingLevel;
						}
						else {
							selectMenu.selectedIndex = Data.options.building.level_cap[cityIdx][i];
							selectMenu.options[Data.options.building.level_cap[cityIdx][i]].selected = true;
							if (Data.options.building.level_enable[cityIdx][buildList[i]]){
								t.checkBuildReqs(cityIdx, buildList[i]);
							}
						}
					}
					catch (e) {
					}
					selectMenu.addEventListener('change', changeBuildCap, false);
				}
			}
		}
		
		// Add the event listeners for the auto-build button and scrollbar
		document.getElementById(UID['tabJobBuild_OnOff']).addEventListener ('click', function (){
			var t=Tabs.Jobs;
			t.setBuildEnable (!Data.options.building.enabled);
		}, false);
		t.refreshBuildButton (Data.options.building.enabled);
		//document.getElementById(UID['tabJob_Content']).addEventListener('scroll', onScroll, false); // CHECK
		
		function checkedBuild (evt){
			var ref = evt.target.getAttribute('ref');
			var idx = ref.split ('_');
			var cityId = Seed.cities[idx[0]].id;
			Data.options.building.level_enable[idx[0]][idx[1]] = evt.target.checked;
			
			if(Data.options.building.level_enable[idx[0]][idx[1]]){
				t.checkBuildReqs(idx[0], idx[1]);
			}
			
			if (Data.options.building.enabled && evt.target.checked){
				t.buildTick();
			}
		}

		function buildDisplayCap (cityIdx, listIdx, type){
			var minLvl = (Buildings.getLevel(cityIdx, type)).min;
			var m = '<td>'
			+'	<select id='+ setUID('tabJobBuild_Cap_' + cityIdx +'_'+ type) +' ref='+ (cityIdx +'_'+ listIdx) + '>'
			+'		<option value=0'+ ( minLvl>0 ?' style="display:none;"':'') +'>0</option>'
			+'		<option value=1'+ ( minLvl>1 ?' style="display:none;"':'') +'>1</option>'
			+'		<option value=2'+ ( minLvl>2 ?' style="display:none;"':'') +'>2</option>'
			+'		<option value=3'+ ( minLvl>3 ?' style="display:none;"':'') +'>3</option>'
			+'		<option value=4'+ ( minLvl>4 ?' style="display:none;"':'') +'>4</option>'
			+'		<option value=5'+ ( minLvl>5 ?' style="display:none;"':'') +'>5</option>'
			+'		<option value=6'+ ( minLvl>6 ?' style="display:none;"':'') +'>6</option>'
			+'		<option value=7'+ ( minLvl>7 ?' style="display:none;"':'') +'>7</option>'
			+'		<option value=8'+ ( minLvl>8 ?' style="display:none;"':'') +'>8</option>'
			+'		<option value=9'+ ( minLvl>9 ?' style="display:none;"':'') +'>9</option>'
			+'		<option value=10'+ ( minLvl>10 ?' style="display:none;"':'') +'>10</option>'
			+'		<option value=11'+ ( minLvl>11 ?' style="display:none;"':'') +'>11</option>'
			+'		<option value=12'+ ( minLvl>12 ?' style="display:none;"':'') +'>12</option>'
			+'		<option value=13'+ ( minLvl>13 ?' style="display:none;"':'') +'>13</option>'
			+'		<option value=14'+ ( minLvl>14 ?' style="display:none;"':'') +'>14</option>'
			+'	</select></td>'
			+'		<td id='+ setUID('tabJobBuild_FB_'+cityIdx +'_'+ type) +' class=jewel valign=top style="width:250px;white-space:normal;"></td>';
			return m;
		}

		// Add to persistent storage
		function changeBuildCap (evt) {
			var ref = evt.target.getAttribute('ref');
			var idx = ref.split ('_');
			Data.options.building.level_cap[idx[0]][idx[1]] = evt.target[evt.target.selectedIndex].value;
			evt.target.style.backgroundColor = ''; 
			
			if(Data.options.building.level_enable[idx[0]][idx[1]]){
				t.checkBuildReqs(idx[0], idx[1]);
			}
			
			if (Data.options.building.enabled){
				t.buildTick();
			}
		}
		
		function onScroll (e){
			if (t.contentType == 2){
				t.buildScrollPos = document.getElementById(UID['tabJob_Content']).scrollTop;
			}
		}
		
		function toggleHideShow (evt){
			var cityIdx = evt.target.getAttribute('ref');
			var div_id = 'tabJobBuild_cityList_' + cityIdx
			var div_el = document.getElementById(UID[div_id]);
			if (div_el.style.display == 'none') {
				div_el.style.display = 'block';
				Data.options.collapsed.build[cityIdx] = false;
			} else {
				div_el.style.display = 'none';
				Data.options.collapsed.build[cityIdx] = true;
			}
		}

		// First Run of buildStatTick
		t.buildStatTick();
		
		// Timers
		t.clearTimers();
		t.buildStatTimer = setInterval (t.buildStatTick, 1000); // start the build statistics timer
	},

	
	//----------------------------------------------------------------------------
	//*** Jobs Tab - Research Sub-tab ***
	//----------------------------------------------------------------------------
	tabJobResearch : function (){
		var t = Tabs.Jobs;	
		document.getElementById(UID[t.lastSubTab]).className ='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabJobResearch']).className ='selected';
		document.getElementById(UID['tabJobResearch']).style.zIndex=1;
		t.lastSubTab = 'tabJobResearch';
		
		t.contentType = 3;
		
		var n = '<div class=' + UID['title'] + '>'+ translate('Research') +' '+ translate('Automatically') +'</div>'
		+'<div class=' + UID['status_ticker'] + '>'
		+'	<center><input id='+ setUID('tabJobResearch_OnOff') +' type=button /></center>'
		+'	<div id='+ setUID('tabJobResearch_Report') +' class='+UID['status_report']+'></div>'
		+'	<br>'
		+'	<div id='+ setUID('tabJobResearch_Feedback') +' class='+ UID['status_feedback'] +'></div>'
		+'</div>';
		document.getElementById(UID['tabJob_Header']).style.height = "205px";
		document.getElementById(UID['tabJob_Header']).innerHTML = n;
		
		var m = '<div id='+ setUID('tabJobResearch_Config') +' class=' + UID['content'] + '>';
		
		var checkBoxs = [];
		var city = Seed.cities[CAPITAL_ID];
		
		// m += '<div class=' + UID['subtitle'] + '>'+ translate('City') +' 1º ('+ city.type +')</div>'
		m += '<div class=' + UID['subtitle'] + '>'+ city.name +'</div>'
		+'<table class=' + UID['table'] + '>';

		var i=0;
		for (var id in research_list){
			var curLvl = Seed.player.research[id] || 0;
			m += '	<tr>'
			+'			<td>'
			+'			<label>'
			+'			<input type=checkbox id='+ setUID('tabJobResearch_CB_'+id) +' '+ (Data.options.research.res_enable[0][id]?'checked':'') +' ref='+ i +' /> '
			+ translate(research_list[id]) 
			+'			</label>'
			+'			<td>'
			+'				<span class=jewel><b>'+ curLvl +'</b></span>'  // Jawz - Added bold
			+'			</td>'
			+'			</td>'
			+'			<td>'
			+'			<select id='+ setUID('tabJobResearch_Sel_'+id) +' ref='+ i +'>'
			+'				<option value=0'+ ( curLvl>0 ?' style="display:none;"':'') +'>0</option>'
			+'				<option value=1'+ ( curLvl>1 ?' style="display:none;"':'') +'>1</option>'
			+'				<option value=2'+ ( curLvl>2 ?' style="display:none;"':'') +'>2</option>'
			+'				<option value=3'+ ( curLvl>3 ?' style="display:none;"':'') +'>3</option>'
			+'				<option value=4'+ ( curLvl>4 ?' style="display:none;"':'') +'>4</option>'
			+'				<option value=5'+ ( curLvl>5 ?' style="display:none;"':'') +'>5</option>'
			+'				<option value=6'+ ( curLvl>6 ?' style="display:none;"':'') +'>6</option>'
			+'				<option value=7'+ ( curLvl>7 ?' style="display:none;"':'') +'>7</option>'
			+'				<option value=8'+ ( curLvl>8 ?' style="display:none;"':'') +'>8</option>'
			+'				<option value=9'+ ( curLvl>9 ?' style="display:none;"':'') +'>9</option>'
			+'				<option value=10'+ ( curLvl>10 ?' style="display:none;"':'') +'>10</option>'
			+'				<option value=11'+ ( curLvl>11 ?' style="display:none;"':'') +'>11</option>'
			+'			</select>'
			+'			</td>'
			+'			<td id='+ setUID('tabJobResearch_FB_'+id) +' class=jewel valign=top style="width:250px;white-space:normal;"></td>'
			+'		</tr>';  
			checkBoxs.push(UID['tabJobResearch_CB_'+id]);
			++i;
		}

		m += '</table></div>';
		document.getElementById(UID['tabJob_Content']).style.height = "480px";
		document.getElementById(UID['tabJob_Content']).innerHTML = m;

		// Add the event listeners for the research types
		for (var i=0; i < checkBoxs.length; ++i){
			document.getElementById(checkBoxs[i]).addEventListener('click', checkedResearch, false);
		}

		// Add the event listeners for the research caps
		// And restore the persistent data since it has to be done in the same loop
		for (var id in research_list) {
			var selectMenu = document.getElementById(UID['tabJobResearch_Sel_' + id]);
			try {
				if (!Data.options.research.res_cap[0][id]) {
					var currentResearchLevel = t.getCurrentResearchLevel(id);
					selectMenu.selectedIndex = currentResearchLevel;
					Data.options.research.res_cap[0][id] = currentResearchLevel;
				}
				else {
					selectMenu.selectedIndex = Data.options.research.res_cap[0][id];
					selectMenu.options[Data.options.research.res_cap[0][id]].selected = true;
					if(Data.options.research.res_enable[0][id]){
						t.checkResearchReqs(id);
					}
				}
			}
			catch (e) {}
			selectMenu.addEventListener('change', changeResearchCap, false);
		}

		document.getElementById(UID['tabJobResearch_OnOff']).addEventListener ('click', function (){
			var t=Tabs.Jobs;
			t.setResearchEnable (!Data.options.research.enabled);
		}, false);
		t.refreshResearchButton (Data.options.research.enabled);

		function checkedResearch (evt){
			var t = Tabs.Jobs;
			var n = parseInt(evt.target.getAttribute('ref'));
			Data.options.research.res_enable[0][research_name[n]] = evt.target.checked;
			
			if(Data.options.research.res_enable[0][research_name[n]]){
				t.checkResearchReqs(research_name[n]);
			}
			
			if (Data.options.research.enabled){
				t.researchTick();
			}
			
		}

		// Add to persistent storage
		function changeResearchCap (evt) {
			var t = Tabs.Jobs;
			var n = parseInt(evt.target.getAttribute('ref'));
			Data.options.research.res_cap[0][research_name[n]] = evt.target[evt.target.selectedIndex].value;
			evt.target.style.backgroundColor = '';  
			
			if(Data.options.research.res_enable[0][research_name[n]]){
				t.checkResearchReqs(research_name[n]);
			}
			
			if (Data.options.research.enabled){
				t.researchTick();
			}
		}

		// First Run of researchStatTick
		t.researchStatTick();

		// Timers
		t.clearTimers();
		t.researchStatTimer = setInterval (t.researchStatTick, 1000); // start the research statistics timer
	},

	//----------------------------------------------------------------------------
	//*** Jobs Tab - Resurrect Sub-tab ***
	//----------------------------------------------------------------------------
	tabJobResurrect : function (){
		var t = Tabs.Jobs;	
		document.getElementById(UID[t.lastSubTab]).className ='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabJobResurrect']).className ='selected';
		document.getElementById(UID['tabJobResurrect']).style.zIndex=1;
		t.lastSubTab = 'tabJobResurrect';
		
		t.contentType = 4;
		
		var n = '<div class=' + UID['title'] + '>'+ translate('Revive troops') +'</div>'
		+'<div class=' + UID['status_ticker'] + '>'
		+'	<center><input id='+ setUID('tabJobResurrect_OnOff') +' type=button /></center>'
		+'	<div id='+ setUID('tabJobResurrect_Report') +' class='+UID['status_report']+'></div>'
		+'	<br>'
		+'	<div id='+ setUID('tabJobResurrect_Feedback') +' class='+ UID['status_feedback'] +'></div>'
		+'</div>';
		document.getElementById(UID['tabJob_Header']).style.height = "205px";
		document.getElementById(UID['tabJob_Header']).innerHTML = n;
		
		var m = '<div id='+ setUID('tabJobResurrect_Config') +' class=' + UID['content'] + '>';
		
		var sl = [];
		var city = Seed.cities[CAPITAL_ID];
		
		m += '<div class=' + UID['subtitle'] + '>'+ translate(Seed.cities[SPECTRAL_OUTPOST_ID].name) +'</div>'
		+'<table class=' + UID['table'] + '>';
		
		m += '<tr class='+UID['row_headers']+'>'
		+'		<td></td><td>'+translate('Quantity')+'</td><td>'+translate('Total souls')+'</td><td>'+translate('Total')+'</td></tr>';
		for (var i=0; i < all_unit_types.length; i++){
			var num = Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[i]]; //city.souls[all_unit_types[i]];
			if (!num || isNaN(num)) num = 0;
            var souls = city.souls[all_unit_types[i]];
			if (!souls || isNaN(souls)) souls = 0;
			m += '<tr>'
			+'		<td width=25%>'
			+'			<label>'
			+'			<input type=checkbox id='+ setUID('tabJobResurrect_CB_'+i) +' '+ (Data.options.resurrect.res_enable[SPECTRAL_OUTPOST_ID][all_unit_types[i]]?'checked':'') + ' ref='+ i +' /> '
			+ translate(all_unit_types[i]) 
			+'			</label>'
			+'		</td>'
			+'		<td align=middle width=10%><input type=text id='+ setUID('tabJobResurrect_Troop_'+ i) +' ref='+ i +' maxlength=8 size=3 value="'+ num +'" style="width:60px; text-align:right;" /></td>'
			+'		<td align=right width=10%>&nbsp;'+ nombreFormate(souls,' ') +'</td>'
			+'		<td align=right width=10%>&nbsp;<span class=jewel>('+ nombreFormate(getTroopNumbers(Seed.cities[CAPITAL_ID], all_unit_types[i]).total,' ') +')</span></td>'
			+'		<td id='+ setUID('tabJobResurrect_FB_'+i) +' class=jewel valign=top style="width:250px;white-space:normal;"></td>'
			+'		</tr>';  
			sl.push(UID['tabJobResurrect_CB_'+ i]);
		}
		
		m += '</table></div>';
		document.getElementById(UID['tabJob_Content']).style.height = "400px";
		document.getElementById(UID['tabJob_Content']).innerHTML = m;

		// Add the event listeners for the research types
		for (var i=0; i < sl.length; ++i){
			document.getElementById(sl[i]).addEventListener('click', checkedResurrect, false);
		}

		// Add the event listeners for the research caps
		// And restore the persistent data since it has to be done in the same loop
		for (var id=0; id < all_unit_types.length; id++) {
			var maxSouls = document.getElementById(UID['tabJobResurrect_Troop_' + id]);
			try {
				var currentSouls = city.souls[all_unit_types[id]];
				if (!currentSouls || isNaN(currentSouls)) currentSouls = 0;
				if (!Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[id]]) {
					maxSouls.value = currentSouls;
					Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[id]] = currentSouls;
				}
				else {
					maxSouls.value = resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[id]];
					if (Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[id]]){
						var currentMax = Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[id]];
						var checkQty = (currentSouls > currentMax) ? currentMax : currentSouls;
						t.checkResurrectReqs(all_unit_types[id], checkQty);
					}
				}
			}
			catch (e) {
			}
			maxSouls.addEventListener('change', changeResurrectMax, false);
		}

		document.getElementById(UID['tabJobResurrect_OnOff']).addEventListener ('click', function (){
			var t=Tabs.Jobs;
			t.setResurrectEnable (!Data.options.resurrect.enabled);
		}, false);

		t.refreshResurrectButton (Data.options.resurrect.enabled);

		function checkedResurrect (evt){
			var t = Tabs.Jobs;
			var n = parseInt(evt.target.getAttribute('ref'));
			Data.options.resurrect.res_enable[SPECTRAL_OUTPOST_ID][all_unit_types[n]] = evt.target.checked;
			
			if (Data.options.resurrect.res_enable[SPECTRAL_OUTPOST_ID][all_unit_types[n]]){
				var currentSouls = Seed.cities[CAPITAL_ID].souls[all_unit_types[n]];
				if (!currentSouls || isNaN(currentSouls)) currentSouls = 0;
				var currentMax = Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[n]];
				var checkQty = (currentSouls > currentMax) ? currentMax : currentSouls;
				t.checkResurrectReqs(all_unit_types[n], checkQty);
				//t.checkResurrectReqs(all_unit_types[n], Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[n]]);
			} else {
				try{
					document.getElementById(UID['tabJobResurrect_FB_'+n]).innerHTML = '';
					document.getElementById(UID['tabJobResurrect_Troop_' + n]).style.backgroundColor = "none";
				}catch(e){}
			}
			
			if (Data.options.resurrect.enabled){
				t.resurrectTick();
			}
			
		}

		// Add to persistent storage
		function changeResurrectMax (evt) {
			var t = Tabs.Jobs;
			var n = parseInt(evt.target.getAttribute('ref'));
			Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[n]] = evt.target.value;
			evt.target.style.backgroundColor = '';

			if (Data.options.resurrect.res_enable[SPECTRAL_OUTPOST_ID][all_unit_types[n]]){
				var currentSouls = Seed.cities[CAPITAL_ID].souls[all_unit_types[n]];
				if (!currentSouls || isNaN(currentSouls)) currentSouls = 0;
				var currentMax = Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[n]];
				var checkQty = (currentSouls > currentMax) ? currentMax : currentSouls;
				t.checkResurrectReqs(all_unit_types[n], checkQty);
				//t.checkResurrectReqs(all_unit_types[n], Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[n]]);
			}
			if (Data.options.resurrect.enabled){
				t.resurrectTick();
			}
		}

		// First Run of researchStatTick
		t.resurrectStatTick();

		// Timers
		t.clearTimers();
		t.resurrectStatTimer = setInterval (t.resurrectStatTick, 1000); // start the research statistics timer
	},

	setTrainEnable : function (onOff){
		var t = Tabs.Jobs;
		t.refreshTrainButton(onOff);
		Data.options.training.enabled = onOff;
		clearTimeout (t.trainTimer);
		if (onOff){
			t.trainTimer = setTimeout(t.trainTick, 3000);
		} else {
			t.dispFeedback(""); // Erase previous feedback
		}
	},
	setBuildEnable : function (onOff){
		var t = Tabs.Jobs;
		t.refreshBuildButton(onOff);
		Data.options.building.enabled = onOff;
		clearTimeout (t.buildTimer);
		if (onOff){
			t.buildRetryTime = 20000;
			t.buildTimer = setTimeout (t.buildTick, 4000);
		} else {
			t.dispFeedback("");
		}
	},
	setResearchEnable : function (onOff){
		var t = Tabs.Jobs;
		t.refreshResearchButton(onOff);
		Data.options.research.enabled = onOff;
		clearTimeout (t.researchTimer);
		if (onOff){
			t.resRetryTime = 20000;
			t.researchTimer = setTimeout(t.researchTick, 5000);
		} else {
			t.dispFeedback("");
		}
	},
	setResurrectEnable : function (onOff){
		var t = Tabs.Jobs;
		t.refreshResurrectButton(onOff);
		Data.options.resurrect.enabled = onOff;
		clearTimeout (t.resurrectTimer);
		if (onOff){
			t.revRetryTime = 20000;
			t.resurrectTimer = setTimeout(t.resurrectTick, 5000);
		} else {
			t.dispFeedback(""); // Erase previous feedback
		}
	},

	refreshTrainButton : function (onOff) {
		var t = Tabs.Jobs;
		var but = document.getElementById(UID['tabJobTrain_OnOff']);
		if(!but) return;
		if (onOff){
			but.value = translate('Training').toUpperCase();
			but.className = UID['btn_on'];
		} else {
			but.value = translate('Disabled').toUpperCase();
			but.className = UID['btn_off'];
		}
	},
	refreshBuildButton : function (onOff) {
		var t = Tabs.Jobs;
		var but = document.getElementById(UID['tabJobBuild_OnOff']);
		if(!but) return;
		if (onOff){
			but.value = translate('Building').toUpperCase();
			but.className = UID['btn_on'];
		} else {
			but.value = translate('Disabled').toUpperCase();
			but.className = UID['btn_off'];
		}
	},
	refreshResearchButton : function (onOff) {
		var t = Tabs.Jobs;
		var but = document.getElementById(UID['tabJobResearch_OnOff']);
		if(!but) return;
		if (onOff){
			but.value = translate('Researching').toUpperCase();
			but.className = UID['btn_on'];
		} else {
			but.value = translate('Disabled').toUpperCase();
			but.className = UID['btn_off'];
		}
	},
	refreshResurrectButton : function (onOff) {
		var t = Tabs.Jobs;
		var but = document.getElementById(UID['tabJobResurrect_OnOff']);
		if(!but) return;
		if (onOff){
			but.value = translate('Reviving').toUpperCase();
			but.className = UID['btn_on'];
		} else {
			but.value = translate('Disabled').toUpperCase();
			but.className = UID['btn_off'];
		}
	},

	trainStatTick : function (){
		var t = Tabs.Jobs;
		var statElement = document.getElementById(UID['tabJobTrain_Report']);
		if (statElement != null){
			statElement.innerHTML = trainTable('train', false);
		}

		// Refresh training reqs
		for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx){
			if (Seed.cities[cityIdx] && cityIdx >= 0 && cityIdx < Seed.cities.length && cityIdx != SPECTRAL_OUTPOST_ID) {
				if (t.contentType == 1 && t.trainContentType == 0){
					switch (cityIdx) {
						case CAPITAL_ID			 : unitType = capital_units; break;
						case WATER_OUTPOST_ID	 : unitType = water_outpost_units; break;
						case STONE_OUTPOST_ID	 : unitType = stone_outpost_units; break;
						case FIRE_OUTPOST_ID	 : unitType = fire_outpost_units; break;
						case WIND_OUTPOST_ID	 : unitType = wind_outpost_units; break;
					}
					for (var uid=0; uid < unitType.length; uid++) {
						var unitQty = Data.options.training.city[cityIdx].units[uid];
						var butTrainNow = document.getElementById(UID['tabTrain_Now_'+ cityIdx +'_'+ uid]);
						if (parseIntZero(unitQty) > 0) {
							var reqs = t.checkTrainReqs(unitType[uid], unitQty, cityIdx);
							if (!reqs.msg) setButtonStyle (butTrainNow, true);
							else setButtonStyle (butTrainNow, false);
						} else {
							setButtonStyle (butTrainNow, false);
						}
					}
				}
			}
		}
		// End Refresh building reqs
		function setButtonStyle (button, enabled) {
			if (enabled) {
				button.disabled = false;
				Element.removeClassName(button, UID['bnt_disabled']);
				Element.addClassName(button, UID['bnt_green']);
			}
			else {
				button.disabled = true;
				Element.removeClassName(button, UID['bnt_green']);
				Element.addClassName(button, UID['bnt_disabled']);
			}
		}
	},
	
	resurrectStatTick : function (){
		var t = Tabs.Jobs;
		var statElement = document.getElementById(UID['tabJobResurrect_Report']);
		if (statElement != null){
			statElement.innerHTML = trainTable('resurrect', true);
		}
	},
	
	// Build statistics - timer set to fire every 1 seconds
	// Calls getBuildJob(), deleteBuildJob(), Buildings.getById(), Seed.fetchPlayer(), serverTime()
	buildStatFetch : false,
	buildStatTick : function (){
		var t = Tabs.Jobs;
		var m = '<TABLE class=' + UID['table'] + '>';
		
		for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx){
			if (Seed.cities[cityIdx]) {
				var city = Seed.cities[cityIdx];
				var job = getBuildJob (cityIdx);
				var options = {noPlayer:true,cities:[]};
				m += '<TR><TD width=20%>'+ ( (cityIdx == SPECTRAL_OUTPOST_ID) ? translate(city.name) : city.name ) + '</td><TD>'; // Jawz
			
				if (job == null){
					m += translate('idle') +'</td></tr>';
				} else {
					var b = Buildings.getById(cityIdx, job.city_building_id);
					var timeRemaining = ((job.run_at - serverTime()) > 0) ? timestr(job.run_at - serverTime()) : 0;
					if (timeRemaining == 0) {
						// If we have a job and the timeRemaining is negative or zero we delete the job
						// and fetch the Seed - although this does not always work because the server
						// is laggy and may not return the correct information
						m += translate('Awaiting task completion notification') + '...</td><td></td><td></td></tr>';
						deleteBuildJob (cityIdx, job);
						if (t.buildStatFetch == false) {
							if (cityIdx != 0) {
								options.cities.push(Seed.cities[CAPITAL_ID].id);
							}
							options.cities.push(city.id);
							Seed.fetchPlayer (options);
							t.buildStatFetch = true;
						}
					} else {
						// m += '<b>' + translate('Building') +':</b> </td><td> '+ translate(b.type) + '  ('+ job.level +') </td><td> <font color='+TIMER_COLOR+'>'+ timeRemaining  +'</font></td></tr>';
						m += '<b>' + translate('Building') +':</b> </td>'
						+' <td width=40%> '+ translate(b.type) + '  ('+ job.level +') </td>'
						+' <td width=40%> <font color='+TIMER_COLOR+'>'+ timeRemaining  +'</font></td></tr>';
						t.buildStatFetch = false;
						try{
							document.getElementById(UID['tabJobBuild_FB_'+cityIdx+'_'+b.type]).innerHTML = '<font color=#000>' + translate('Building') + ': ' + translate(b.type) + ' ' + translate('Level').toLowerCase() + ' ' + job.level + '</font>';
						}catch(e){}
					}
				}

				// Refresh building reqs
				if (t.contentType == 2){
					var buildList;
					switch (cityIdx) {
						case CAPITAL_ID : buildList = capital_buildings.concat(field_buildings); break;
						case SPECTRAL_OUTPOST_ID : buildList = spectral_buildings.concat(spectral_fields); break;
						default : buildList = outpost_buildings.concat(field_buildings); break;
					}
					for (var i=0; i < buildList.length; ++i) {
						if (Data.options.building.level_enable[cityIdx][buildList[i]])
							t.checkBuildReqs(cityIdx, buildList[i]);
					}
				}
				// End Refresh building reqs
			}
		}
		document.getElementById(UID['tabJobBuild_Report']).innerHTML = m +'</table>';
	},
		
	// Build statistics - timer set to fire every 1 seconds
	// Calls getResearchJob(), deleteResearchJob(), Seed.fetchPlayer(), resUITranslate(), serverTime()
	resStatFetch : false,
	researchStatTick : function (){
		var t = Tabs.Jobs, m = '<table class=' + UID['table'] + '>', city = Seed.cities[CAPITAL_ID];
		var job = getResearchJob (0);
		
		// m += '<tr><td>'+ translate('City') +' 1º </td><td>'; // Jawz
		m += '<tr><td width=20%>'+ city.name + '</td><td>'; // Jawz

		if (job == null){
			m += translate('idle') +'</td></tr>';
		} else {
			var timeRemaining = ((job.run_at - serverTime()) > 0) ? timestr(job.run_at - serverTime()) : 0;
			if (timeRemaining == 0) {
				m += translate('Awaiting task completion notification') + '...</td><td></td><td></td></tr>';
				deleteResearchJob(job);
				if (t.resStatFetch == false) {
					Seed.fetchPlayer( {cities:[city.id]} );
					t.resStatFetch = true;
				}
			} else {
				// Bug: If we have a job and the timeRemaining is negative or zero we should delete the job
				// m += '<b> '+ translate('Researching') +': </b> </td><td> '+ translate(t.resUITranslate(job.research_type)) +' ('+ job.level +') </td><td>  <font color='+TIMER_COLOR+'>'+ timeRemaining  +'</font></td></tr>';
				m += '<b> '+ translate('Researching') +': </b> </td>'
				  +' <td width=50%> '+ translate(t.resUITranslate(job.research_type)) +' ('+ job.level +') </td><td width=30%>  <font color='+TIMER_COLOR+'>'+ timeRemaining  +'</font></td></tr>';
				t.resStatFetch = false;
			}
		}

		document.getElementById(UID['tabJobResearch_Report']).innerHTML = m +'</table>';
		try{
			document.getElementById(UID['tabJobResearch_FB_'+job.research_type]).innerHTML = '<font color=#000>' + translate('Researching') + '&nbsp;' + translate('Level').toLowerCase() + '&nbsp;' + job.level + '</font>';
		}catch(e){}
		//t.statTimer = setTimeout (t.statTick, 5000);
	},

	// Modified to work with jobs
	dispFeedback : function (msg){
		var t = Tabs.Jobs;
		var elementId = '';   

		switch(t.contentType) {
			case 0: break;
			case 1: elementId = 'tabJobTrain_Feedback'; break;
			case 2: elementId = 'tabJobBuild_Feedback'; break;
			case 3: elementId = 'tabJobResearch_Feedback'; break;
			case 4: elementId = 'tabJobResurrect_Feedback'; break;
		} 
		
		if (elementId && document.getElementById(UID[elementId])){
			if (msg == ''){
				document.getElementById(UID[elementId]).innerHTML = msg; 
			} else {
				document.getElementById(UID[elementId]).innerHTML = new Date().toTimeString().substring (0,8) +'&nbsp;'+  msg;
			}
		}
	},

	getCurrentResearchLevel : function (researchType){
		var t = Tabs.Jobs, level = 0;
		try {
			// Jawz - For compatibility purpose
			if (researchType == 'Rapid Deployment')		researchType = 'RapidDeployment';
			if (researchType == 'Weapons Calibration')	researchType = 'Ballistics';
			if (researchType == 'Aerial Combat')		researchType = 'AerialCombat';
			// End Jawz - For compatibility purpose
			level = (Seed.player.research[researchType]) ? Seed.player.research[researchType] : 0; 
		}
		catch (e) {
		}  
		return level;
	},
	getTroopCap : function(troopType, qty){
		var t = Tabs.Jobs;
		var cap = 0;
		var completedTroops = 0;
		var marchingTroops = 0;
		var trainingTroops = 0;
		
		// Get the cap set for this troop type
		for (var i=0; i < all_trainable_units.length;i++){
			if (troopType == all_trainable_units[i]) {
				cap = Data.options.training.city[0].cap[i];
				break;
			}
		}
		
		// If there is no cap, we are done
		if (cap == 0){
			return cap;
		}
		
		// Find the number of troops still in the city  
		completedTroops += (Seed.cities[CAPITAL_ID].units[troopType] != undefined) ? Seed.cities[CAPITAL_ID].units[troopType] : 0;
		
		// Find additional troops in marches
		for (var p in Seed.marches) {
			for (var q in Seed.marches[p].units){
				if (q == troopType){
					marchingTroops += Seed.marches[p].units[q];
				}
			}
		}

		var now = serverTime();
		for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx) {
			if (Seed.cities[cityIdx] && Seed.cities[cityIdx].jobs) {
				var jobs = Seed.cities[cityIdx].jobs;
				for (var j=0; j < jobs.length; j++) {
					if (jobs[j].queue == 'units' && jobs[j].unit_type == troopType && jobs[j].run_at > now)
						trainingTroops += jobs[j].quantity;
				}
			}
		}
		return ((completedTroops + marchingTroops + trainingTroops + qty) > cap) ? (completedTroops + marchingTroops + trainingTroops + qty) : 0;
	},
	getBuildingCap : function (cityIdx, buildingType){
		var t = Tabs.Jobs;
		var cap = 0;

		var cityType;
		switch (cityIdx) {
			case CAPITAL_ID : cityType = capital_buildings.concat(field_buildings); break;
			case SPECTRAL_OUTPOST_ID : cityType = spectral_buildings.concat(spectral_fields); break;
			default : cityType = outpost_buildings.concat(field_buildings); break;
		}
		for (var i=0; i < cityType.length; ++i) {
			if (cityType[i] == buildingType) {
				try {
					cap = (Data.options.building.level_cap[cityIdx][i]) ? Data.options.building.level_cap[cityIdx][i] : 0; 
					break;
				}
				catch (e) {}  
			}
		}

		return cap;
	},
	getResearchCap : function (researchType){
		var t = Tabs.Jobs;
		var cap = 0;
		
		for (var id in research_list) {
			if (researchType == id) {
				try {
					cap = (Data.options.research.res_cap[0][id]) ? Data.options.research.res_cap[0][id] : 0; 
					break;
				}
				catch (e) {
				}  
			}
		}
		return cap;
	},
	resUITranslate : function (researchType){
		var t = Tabs.Jobs;
		for (var id in research_list){
			if (id == researchType){
				return research_list[id];
			}
		}
		return researchType;
	},
	getBuildingLevel : function(cityIdx, buildingType, buildingLevel){
		var buildings = Seed.cities[cityIdx].buildings;
		var ret = 0;
		for (var p=0; p < buildings.length;p++) {
			if (buildings[p].type == buildingType && buildings[p].level >= buildingLevel){
				ret = buildings[p].level;
				break;
			}
		}
		return ret;
	},
	getRemainingQueue : function (ic, queueType, resurrect){
		var city = Seed.cities[ic];
		var jobs = city.jobs;
		var maxQueueLength = (resurrect) ? city.figures.queue_lengths.resurrection : city.figures.queue_lengths.units;
		var usedQueue = 0;
		//Check if max_queue_length is a number and not 0) 
		if (isNaN(maxQueueLength) || !maxQueueLength) {  
			return 0;
		}
		// Count the number of jobs in the queue
		for (var i=0; i<jobs.length; i++) {
			if (jobs[i].queue == queueType){
				++usedQueue;
			}
		}
		return maxQueueLength - usedQueue;
	},

	checkRequirements : function ( options ) {
		var reqs = {};

		// options.unit_type and options_training_type are the same,
		// we can use either interchangeably
		var element_type =  options.unit_type     || 
							options.training_type || 
							options.building_type || 
							options.research_type;
		var requirements = Seed.requirements[ options.reqs_type ][ element_type ];
		var stats = Seed.stats[ options.reqs_type ][ element_type ];

		// in case of level
		if (typeof (options.level) !== 'undefined' ) {
			requirements = requirements.level[options.level];
			stats = stats.level[options.level];
		}
		// if omitted options.city_idx, use the capital, city_idx = 0
		// this value is only used by requirements.buildings case
		var city_idx = options.city_idx || CAPITAL_ID;
		//always use the capital data to verify the resources and the population
		var city = Seed.cities[CAPITAL_ID];
		// If we are verifying unit requirements, initialize the variable max_units
		if ( options.unit_type || options.reqs_type == 'units' )
			reqs.max_units = 999999999;

		// Set time needed for this task
		reqs.time = stats.time;
		// when omitted options.unit_quantity, sets unit_quantity to 1 to check the requirements of the buildings and research.
		var unit_quantity = options.unit_quantity || 1;
		
		// Check Buildings requirements
		if (requirements.buildings) {
			for (var type in requirements.buildings) {
				var fixed_type = type;
				// we change the type of build Garrison to TrainingCamp in case of outpost city
				if (city_idx != CAPITAL_ID && type == 'Garrison')
					fixed_type = 'TrainingCamp';

				var fixed_city_idx = ( /Science|Metal|Officer|Rookery|Storage|Theater|Sentinel|Factory|Fortress/.test(fixed_type) ? CAPITAL_ID : city_idx);
				var level = Buildings.getLevel(fixed_city_idx, fixed_type);
				if (level.max < requirements.buildings[type]) {
					if (!reqs.buildings) reqs.buildings = {};
					reqs.buildings[fixed_type] = requirements.buildings[type];
					reqs.msg = (reqs.msg||'') + translate(fixed_type) + '(' + reqs.buildings[fixed_type] + ')' + ' + ';
				}
			}
		}
		
		// Check Items requirements
		if (requirements.items) {
			for (var type in requirements.items) {
				//if (Seed.player.items[type] < requirements.items[type]) {
				var need = requirements.items[type] * unit_quantity;
				var have = parseInt(Seed.player.items[type] || 0);
				if (have < need) {
					if (!reqs.items) reqs.items = {};
					reqs.items[type] = need - have; //requirements.items[type];
					reqs.msg = (reqs.msg||'') + translate(type) + '(' + nombreFormate(reqs.items[type],' ') + ')' + ' + ';
				}
				// If we are verifying unit requirements, calculate the maximum units
				if (reqs.max_units) {
					var current_max = parseInt( have / requirements.items[type] );
					if (reqs.max_units > current_max) {
						reqs.max_units = current_max;
					}
				}
			}
		}

		// Check Population requirements
		if (requirements.population && requirements.population.idle) {
			var need = requirements.population.idle * unit_quantity;
			var have = city.figures.population.current - city.figures.population.laborers - city.figures.population.armed_forces;
			have = (have > 0) ? have : 0;
			if (have < need) {
				reqs.population =  need - have;
				reqs.msg = (reqs.msg||'') + translate('Population') + ':' + nombreFormate(reqs.population,' ') + ' + ';
			}
			// If we are verifying unit requirements, calculate the maximum units
			if (reqs.max_units) {
				var current_max = parseInt( (have+1) / requirements.population.idle );
				if (reqs.max_units > current_max) {
					reqs.max_units = current_max;
				}
			}
		}

		// Check Research requirements
		if (requirements.research) {
			for (var type in requirements.research) {
				if (Seed.player.research[type] < requirements.research[type]) {
					if (!reqs.research) reqs.research = {};
					reqs.research[type] = requirements.research[type];
					reqs.msg = (reqs.msg||'') + translate(type) + '(' + reqs.research[type] + ')' + ' + ';
				}
			}
		}

		// Check Resources requirements
		if (requirements.resources) {
			for (var type in requirements.resources) {
				if (requirements.resources[type] == 0)
					continue;

				var need = requirements.resources[type] * unit_quantity;
				var have = parseInt(city.resources[type] || 0);
				if (have < need) {
					if (!reqs.resources) reqs.resources = {};
					reqs.resources[type] = need - have;
					reqs.msg = (reqs.msg||'') + translate(type) + ':' + nombreFormate(reqs.resources[type],' ') + ' + ';
				}
				// If we are verifying unit requirements, calculate the maximum units
				if (reqs.max_units) {
					var current_max = parseInt( (have+1) / requirements.resources[type] );
					if (reqs.max_units > current_max) {
						reqs.max_units = current_max;
					}
				}
			}
		}

		// Set time needed for this units task based in quantity
		if (reqs.max_units)
			reqs.time = (options.unit_quantity || 0) * stats.time;
		if (reqs.msg)
			reqs.msg = reqs.msg.substring(0,reqs.msg.length-3);
		return reqs;
	},
	checkTrainReqs : function (troopType, troopQty, cityIdx) {
		var t = Tabs.Jobs;
		
		var reqs = t.checkRequirements ({
			reqs_type     : 'unit', 
			city_idx      : cityIdx, 
			unit_type     : troopType, 
			unit_quantity : troopQty
		});
		// Check Remaining Queue
		if ( t.getRemainingQueue(cityIdx, 'units', false) == 0 )
			reqs.queue = true;
		// Check Units Cap
		var capped = t.getTroopCap(troopType, troopQty);
		if (capped) {
			reqs.capped = capped;
			//reqs.msg = (reqs.msg||'') + translate('Production limit reached') + ' + ';
			reqs.msg = translate('Production limit reached') + ' + ';
		}
		if (t.contentType == 1){
			if (reqs.msg) {
				try{
					document.getElementById(UID['tabJobTrain_FB_' + cityIdx +'_'+ troopType]).innerHTML ='<font color="#C33">'+ reqs.msg.replace(/:\+/,':').replace(/\+\s*$/,'') +'</font>';
					document.getElementById(UID['tabJobTrain_FB_' + cityIdx +'_'+ troopType]).title = translate(troopType) + ' ' + reqs.msg.replace(/\+/g,' \n');
					document.getElementById(UID['tabJobBuild_Cap_' + cityIdx +'_'+ troopType]).style.color = "#C33";
				}catch(e){}
			} else {
				try{
					var fb_text = translate('Max') + ' : ' + nombreFormate(reqs.max_units,' ') + ' (' + timestrShort(reqs.time) + ')';
					document.getElementById(UID['tabJobTrain_FB_' + cityIdx +'_'+ troopType]).innerHTML = fb_text;
					document.getElementById(UID['tabJobTrain_FB_' + cityIdx +'_'+ troopType]).title = translate(troopType) + ' \n' + fb_text;
				}catch(e){}
			}
		}
		return reqs;
	},
	checkBuildReqs : function(cityIdx, buildingType){
		var t = Tabs.Jobs;
		var level = ( Buildings.getLevel(cityIdx, buildingType) ).min + 1;
		var cap = t.getBuildingCap (cityIdx, buildingType);
		if (level <= cap) {
			var reqs = t.checkRequirements ({
				reqs_type     : 'building', 
				city_idx      : cityIdx, 
				building_type : buildingType,
				level         : level
			});
			
			if (reqs.msg) {
				if (t.contentType == 2){
					try{
						document.getElementById(UID['tabJobBuild_FB_' + cityIdx +'_'+ buildingType]).innerHTML ='<font color="#C33">'+ reqs.msg.replace(/:\+/,':').replace(/\+\s*$/,'') +'</font>';
						document.getElementById(UID['tabJobBuild_FB_' + cityIdx +'_'+ buildingType]).title = translate(buildingType) + ' ' + reqs.msg.replace(/\+/g,' \n');
						document.getElementById(UID['tabJobBuild_Cap_' + cityIdx +'_'+ buildingType]).style.color = "#C33";
					}catch(e){}
				}
			} else {
				if (t.contentType == 2){
					try{
						var fb_text = translate('Next level') + ' ' + translate('OK');
						document.getElementById(UID['tabJobBuild_FB_' + cityIdx +'_'+ buildingType]).innerHTML = fb_text;
						document.getElementById(UID['tabJobBuild_FB_' + cityIdx +'_'+ buildingType]).title = translate(buildingType) + ' \n' + fb_text;
					}catch(e){}
				}
			}
			return reqs;
		} else {
			if (t.contentType == 2){
				try{
					var fb_text = translate('Task Completed');
					document.getElementById(UID['tabJobBuild_FB_'+ cityIdx +'_'+ buildingType]).innerHTML = '<font color=#0B0>'+ fb_text +'</font>';
					document.getElementById(UID['tabJobBuild_FB_' + cityIdx +'_'+ buildingType]).title = translate(buildingType) + ' \n' + fb_text;
					document.getElementById(UID['tabJobBuild_Cap_' + cityIdx +'_'+ buildingType]).style.color = "#5B5";
				}catch(e){}
			}
		}
		return ({ capped:true, msg:translate('Maximum level reached')});
	},
	checkResearchReqs : function (researchType){
		var t = Tabs.Jobs;
		var level =  t.getCurrentResearchLevel (researchType)+1;
		var cap = t.getResearchCap (researchType);
		if (level <= cap) {
			var reqs = t.checkRequirements ({
				reqs_type     : 'research', 
				research_type : researchType,
				level         : level
			});

			if (reqs.msg) {
				if (t.contentType == 3){
					try {
						document.getElementById(UID['tabJobResearch_FB_'+researchType]).innerHTML = '<font color=#C33>' + reqs.msg.replace(/:\+/,':').replace(/\+\s*$/,'') + '</font>';
						document.getElementById(UID['tabJobResearch_FB_'+researchType]).title = translate(researchType) + ' ' + reqs.msg.replace(/\+/g,' \n');
						document.getElementById(UID['tabJobResearch_Sel_' + researchType]).style.color = "#C33";
					} catch(e){}
				}
			} else {
				if (t.contentType == 3){
					try {
						var fb_text = translate('Next level') + ' ' + translate('OK');
						document.getElementById(UID['tabJobResearch_FB_'+researchType]).innerHTML = fb_text;
						document.getElementById(UID['tabJobResearch_FB_'+researchType]).title = translate(researchType) + ' \n' + fb_text;
					} catch(e){}
				}
			}
			return reqs;
		} else {
			if (t.contentType == 3){
				try {
					var fb_text = translate('Task Completed');
					document.getElementById(UID['tabJobResearch_FB_'+researchType]).innerHTML = '<font color=#0B0>'+ fb_text +'</font>';
					document.getElementById(UID['tabJobResearch_FB_'+researchType]) = translate(researchType) + ' \n' + fb_text;
					document.getElementById(UID['tabJobResearch_Sel_' + researchType]).style.color = "#5B5";
				} catch(e){}
			}
		}
		return ({capped:true, msg:translate('Maximum level reached')});
	},
	checkResurrectReqs : function(troopType, troopQty) {
		var t = Tabs.Jobs;
		if (t.contentType == 3){
			try {
				document.getElementById(UID['tabJobResurrect_FB_'+id_found]).innerHTML = '';
				document.getElementById(UID['tabJobResurrect_Troop_' + id_found]).style.backgroundColor = "none";
			} catch(e){}
		}

		switch (troopType) {
			case kPorter		: per_unit=5; darkPortal=1; break;
			case kConscript		: per_unit=5; darkPortal=1; break;
			case kSpy			: per_unit=5; darkPortal=2; break;
			case kHalberdsman	: per_unit=5; darkPortal=2; break;
			case kMinotaur		: per_unit=7; darkPortal=3; break;
			case kLongbowman	: per_unit=7; darkPortal=4; break;
			case kSwiftStrikeDragon	: per_unit=7; darkPortal=5; break;
			case kArmoredTransport	: per_unit=7; darkPortal=6; break;
			case kBattleDragon	: per_unit=10; darkPortal=7; break;
			case kGiant			: per_unit=10; darkPortal=8; break;
			case kFireMirror	: per_unit=10; darkPortal=9; break;
			case kAquaTroop		: per_unit=15; darkPortal=10; break;
			case kStoneTroop	: per_unit=15; darkPortal=10; break;
			case kFireTroop		: per_unit=15; darkPortal=10; break;
			case kWindTroop		: per_unit=15; darkPortal=10; break;
			case kPackDragon	: per_unit=15; darkPortal=6; break;
		}
		var blue_energy = troopQty * per_unit;
		var darkPortalLevel = darkPortal;
		
		var city = Seed.cities[CAPITAL_ID];
		try {
			var seedReqs = Seed.requirements.resurrect[troopType];
			blue_energy = troopQty * seedReqs.resources['blue_energy'];
			darkPortalLevel = seedReqs.buildings[kDarkPortal];
		} catch (e) {
			actionLog('<B>' + translate('Training') + '</B>: ' + e.msg + ' ' + translate('Manifest not available, using defaults'));
		}

		var m = '';
		var n = ' : ';
		var ret = {trainable:false, msg:[]};

		// Returns zero or the building level
		if (city.resources.blue_energy < blue_energy) m += translate('Blue energy') +': '+ (blue_energy - city.resources.blue_energy) +' + ';
		var availableSouls = city.souls[troopType];
		availableSouls = (availableSouls > 0) ? availableSouls : 0;
		if (availableSouls == 0) m += translate('Souls') +' + ';   // availableSouls < troopQty
		if (t.getBuildingLevel(SPECTRAL_OUTPOST_ID, kDarkPortal, darkPortalLevel) == 0) m += translate(kDarkPortal) +': '+ darkPortalLevel +' + ';
		if (t.getRemainingQueue(SPECTRAL_OUTPOST_ID, 'resurrection', true) == 0) m+= translate('Resurrection queue') + ' ';
		if (m.length == 0) {
			ret.trainable = true;
			ret.msg = troopQty +' '+ translate(troopType);
		} else {
			ret.trainable = false;
			ret.msg = n + m;
		}

		var id_found = undefined;
		for (var i=0; i < all_unit_types.length && id_found == undefined; i++){
			if (all_unit_types[i] == troopType) {
				id_found = i;
			}
		}
		if (ret.trainable == false) {
			if (t.contentType == 4){
				try{
					document.getElementById(UID['tabJobResurrect_FB_'+id_found]).innerHTML = '<font color=#C33>' + ret.msg.replace(/:\+/,':').replace(/\+\s*$/,'') + '</font>';
					document.getElementById(UID['tabJobResurrect_FB_'+id_found]).title = translate(all_unit_types[id_found]) + ' ' + ret.msg.replace(/\+/g,' \n');
					document.getElementById(UID['tabJobResurrect_Troop_' + id_found]).style.backgroundColor = "#C33";
				}catch(e){}
			}
		} else {
			if (t.contentType == 4){
				try{
					var fb_text = translate('Revival') + ' allowed : ' + translate('OK');
					document.getElementById(UID['tabJobResurrect_FB_'+id_found]).innerHTML = fb_text;
					document.getElementById(UID['tabJobResurrect_FB_'+id_found]).title = translate(all_unit_types[id_found]) + ' \n' + fb_text;
				}catch(e){}
			}
		}
		return ret;
	},
	

	// The training heartbeat
	trainTick : function (){
		var t = Tabs.Jobs;

		if (!Data.options.training.enabled){
			return;
		}
		clearTimeout (t.trainTimer);
		// If a refresh of the capital city data is enqueued or running, then skip everything.
		// troops will be queued for training after the refresh completed
		if (Seed.refresh_cities[CAPITAL_ID])
			var doRecheck = false;
		else
			var doRecheck = true;

		var options = {noPlayer:true};
		var cityList = getTotTrainTable ();
		// For all cities, sorted by training queues total time, in ascending order (we deal with the city that will complete its queues first)
		for (var x = 0; x < cityList.length && doRecheck; x++) {
			var trainQueued = false;
			var cityIdx = cityList[x].cityIdx;
			if (cityIdx != undefined && !isNaN( cityIdx ) && cityIdx >= 0 && cityIdx < Seed.cities.length && cityIdx != SPECTRAL_OUTPOST_ID &&
				Data.options.training.city[cityIdx].enabled) {
				// The length here is the number of troop types it is possible to train
				switch (cityIdx) {
					case CAPITAL_ID			 : troopsLength = capital_units.length; break;
					case WATER_OUTPOST_ID	 : troopsLength = water_outpost_units.length; break;
					case STONE_OUTPOST_ID	 : troopsLength = stone_outpost_units.length; break;
					case FIRE_OUTPOST_ID	 : troopsLength = fire_outpost_units.length; break;
					case WIND_OUTPOST_ID	 : troopsLength = wind_outpost_units.length; break;
				}
		
				// Only check the job queue if we are in short queue mode
				if (t.selectedQ == 'min_housing'){
					if (!getTrainJob (cityIdx) || getTrainJob (cityIdx) == null) {
						trainQueued = t.attemptTrainQ(cityIdx, 0, troopsLength, true);
					}
				} else {
					trainQueued = t.attemptTrainQ(cityIdx, 0, troopsLength, false);
				}
				if (trainQueued) {
					doRecheck = false; // Troops have been queued. 
				} else {
					if (!options.cities) {
						options.cities = [];
					}
					options.cities.push(Seed.cities[cityIdx].id);
				}
			}
		}
//		if (doRecheck) {
//			verboseLog('Tabs.Job.Train doRecheck');
//			Seed.fetchPlayer(options);
//			//due to error wait 20seconds then check the city again.
//			clearTimeout (t.trainTimer);
//			t.trainTimer = setTimeout ( t.trainTick, t.trainRetryTime);
//		} else {
			t.trainTimer = setTimeout ( t.trainTick, Math.randRange(5000, 10000));
//		}
	},

	// Build heartbeat
	buildTick : function (){
		var t = Tabs.Jobs;

		if (!Data.options.building.enabled){
			return;
		}
		clearTimeout (t.buildTimer);

		var recheck_build = false;
		var options = {noPlayer:true, cities:[]};
		// Iterate over the cities for buildings in each
		for (var cityIdx=0; cityIdx < Seed.cities.length; ++cityIdx ){
			if (Seed.cities[cityIdx]){
				var bJob = getBuildJob (cityIdx);
				var city = Seed.cities[cityIdx];
				var cityId = city.id;

				if (bJob == null){     // city not currently building

					// Yes, is there a job in persistent data in in this city?
					for (var i=0; i < Data.options.tJobs.length; i++) {
						if (Data.options.tJobs[i].city_id == cityId) {
							// We check three different modes of completion:
							// 1. the done flag
							// 2. the duration
							// 3. the run_at + duration compared to serverTime()
							if ( Data.options.tJobs[i].done ||
								(Data.options.tJobs[i].duration && Data.options.tJobs[i].run_at &&
								 Data.options.tJobs[i].run_at + Data.options.tJobs[i].duration < serverTime() ) ){
									Data.options.tJobs.splice(i,1);
								//	if (!options.cities)
								//		options.cities = [];
									// if job not at capital city check capital city as well as outpost.
								//	if (cityIdx !== CAPITAL_ID)
								//		options.cities.push(Seed.cities[CAPITAL_ID].id);
								//	options.cities.push(city.id);
								//	Seed.fetchPlayer ( options );
								//	t.buildTimer = setTimeout (t.buildTick, 4000);
								//	return;
								
							}
						}
					}  

					// TBD: sort the array by building type and building level
					var buildOrder = []; // Concatenated array of buildings
					var buildList = [];
					for (var name in Data.options.building.level_enable[cityIdx]){
						// Is this building type enabled for autobuild?
						if (Data.options.building.level_enable[cityIdx][name]){
							buildList = Buildings.getList (cityIdx, name);
							buildList.sort (function(a,b){return a.level-b.level});
							buildOrder = buildOrder.concat (buildList);
						}
					}
					buildOrder.sort (function(a,b){return a.level-b.level});

					// Change: we want to iterate over each buildings comparing the level to the cap. If the cap has not
					// been reached, call doBuild
					var bBuilt = false;
					var bBuildable = false;
					var totalCapped = 0;
				
					for (var i=0; i < buildOrder.length && !bBuilt; i++) {
						var reqs = t.checkBuildReqs(cityIdx, buildOrder[i].type);
						if (reqs) {
							bBuildable = true;
							if (t.contentType == 2){
								t.dispFeedback (reqs.msg);
							}
							if (!reqs.msg) {
								t.doBuild (buildOrder[i], city);
								bBuilt = true;
								Data.options.tJobs.push(buildOrder[i]);
								return;
								//break;
							} else {
								if (t.contentType == 2){
									t.dispFeedback (buildOrder[i].type +' '+ reqs.msg);
								}
								if (reqs.capped) ++totalCapped;
							}
						}
					}
					if (!bBuilt && bBuildable && (buildOrder.length - totalCapped > 0))
						recheck_build = true;
						//if (!options.cities)
						//	options.cities=[];
						//options.cities.push(cityId);
				} else {
					// We have a job running
					// Look at the job record
					if (bJob) {
						var jFound = false;
						// Look for the job in our persistent data
						for (var i=0; i < Data.options.tJobs.length && !jFound; i++) {
							if (bJob.city_building_id == Data.options.tJobs[i].city_building_id) {
								jFound = true;
							}   
						}
						// If the job is not in persistent data, put it there
						if (!jFound) {
							Data.options.tJobs.push(bJob);
							consoleLog(translate('Putting build job in persistent data'));
						} else {
							// Keep a consistent display                
							// var cityType = (city.type == "Capital") ? 'Capital' : city.type;
							var bType = getBuildingById (cityIdx, bJob.city_building_id);
							var msg = translate('Building') + ': ' + translate(bType) + ' ' + translate('Level').toLowerCase() + ' ' + bJob.level +' '+ translate('at') + ' ' + translate(city.type);
							if (t.contentType == 2){
								t.dispFeedback (msg);
							}
						}
					}
				}
			}
		}
		if (recheck_build) {
			//Seed.fetchPlayer(options);
			t.buildRetryTime *= 1.5;
			if (t.contentType == 2){
				t.dispFeedback (translate('Completion errors') +': '+ translate('Retry in')+ ' '+ timestr(t.buildRetryTime/1000) +' '+ translate('seconds')); 
			}
			t.buildTimer = setTimeout (t.buildTick, t.buildRetryTime);
			return;              
		}      
		t.buildTimer = setTimeout (t.buildTick, 5000);
	},

	// Research heartbeat
	researchTick : function (){

		var t = Tabs.Jobs;
		
		if (!Data.options.research.enabled){
			return;
		}
		clearTimeout (t.researchTimer);
		
		var recheck_research = false;
		var rJob = getResearchJob(0);
		var city = Seed.cities[CAPITAL_ID];
		var cityId = city.id;
		
		if (rJob == null){     // no research being done yet
			
			// Is there a research job in persistent data?
			for (var i=0; i < Data.options.rJobs.length; i++) {
				if (Data.options.rJobs[i]) {
					if ( Data.options.rJobs[i].done ||
						(Data.options.rJobs[i].duration && Data.options.rJobs[i].run_at &&
						Data.options.rJobs[i].run_at + Data.options.rJobs[i].duration > serverTime() ) ){
							// Yes, has the job completed?
							Data.options.rJobs.splice(i,1);
							//Seed.fetchPlayer({cities:[cityId]});
							//t.researchTimer = setTimeout (t.researchTick, 5000);
							//return;
					}
				}
			}
			
			var toResearch = 0;
			for (var researchType in research_list) {
				if(Data.options.research.res_enable[0][researchType]==undefined){
					continue;
				}
					
				//consoleLog(researchType+" = "+Data.options.research.res_enable[0][researchType]);
				if (Data.options.research.res_enable[0][researchType] == true){
					
					var level = t.getCurrentResearchLevel (researchType) + 1;
					var reqs = t.checkResearchReqs (researchType);
					
					var rBuilt = false;
					
					if (reqs) {
						if (!reqs.msg) {
							t.doResearch(researchType, level);
							rBuilt = true;
							Data.options.rJobs.push(rJob);
							break;
						} else {
							if (t.contentType == 3){
								t.dispFeedback (researchType +' '+ reqs.msg);
							}
							++toResearch;
						}
					}
				}
			}
			if ( rBuilt === false && toResearch )
				recheck_research = true;
		}
		else {
			// We have a job running
			// Look at the record
			if (rJob) {
				var jFound = false;
				// Look for the job in persistent data
				for (var i=0; i < Data.options.rJobs.length; ++i) {
					// Check the rJob structure for a field called city_research_id or some such (like the building)
					// Otherwise, double-check that the ids match
					if (Data.options.rJobs[i] != undefined && Data.options.rJobs[i].id == rJob.id) {
						jFound = true;
					}
				}
				// If the job is not in persistent data, put it there
				if (!jFound) {
					Data.options.rJobs.push(rJob);
					consoleLog(translate('Putting research job in persistent data'));
				}
			}
		}
		if (recheck_research) {
			Seed.fetchPlayer({cities:[cityId]});
			t.researchTimer = setTimeout (t.researchTick, t.resRetryTime);
			if (t.contentType == 3){
				t.dispFeedback (translate('Completion errors')+ ': '+ translate('Retry in') +' '+ timestr(t.resRetryTime/1000) +' '+ translate('seconds'));
			}
			t.resRetryTime *= 1.5;
			return;
		}
		t.researchTimer = setTimeout (t.researchTick, 5000);
	},

	resurrectTick : function (){
		var t = Tabs.Jobs;
	
		if (!Data.options.resurrect.enabled){
			return;
		}
		
		var recheck_reseurrect = false;
		var sJob = getResurrectionJob(0);
		var city = Seed.cities[SPECTRAL_OUTPOST_ID];
		var cityId = city.id;
		
		if (sJob == null){     // no resurrection being done yet
			
			// Is there a resurrection job in persistent data?
			for (var i=0; i < Data.options.sJobs.length; i++) {
				if (Data.options.sJobs[i]) {
					if (Data.options.sJobs[i].done ||
						!Data.options.sJobs[i].duration ||
						Data.options.sJobs[i].run_at + Data.options.sJobs[i].duration > serverTime()
						){
							// Yes, has the job completed?
							Data.options.sJobs.splice(i,1);
							Seed.fetchPlayer({cities:[cityId]});
							clearTimeout (t.resurrectTimer);
							t.resurrectTimer = setTimeout (t.resurrectTick, 10000);
							return;
					}
				}
			}

			var toResurrect = 0;
			for (var unit=0; unit < all_unit_types.length; unit++) {
				if (Data.options.resurrect.res_enable[SPECTRAL_OUTPOST_ID][all_unit_types[unit]]==undefined){
					continue;
				}
				if (Data.options.resurrect.res_enable[SPECTRAL_OUTPOST_ID][all_unit_types[unit]] == true){

					var currentSouls = Seed.cities[CAPITAL_ID].souls[all_unit_types[unit]];
					if (!currentSouls || isNaN(currentSouls)) currentSouls = 0;
					var currentMax = Data.options.resurrect.res_max[SPECTRAL_OUTPOST_ID][all_unit_types[unit]];
					var checkQty = (currentSouls > currentMax) ? currentMax : currentSouls;
					var reqs = t.checkResurrectReqs(all_unit_types[unit], checkQty);
					
					var rRevive = false;
					
					if (reqs) {
						if (reqs.trainable) {
							t.doResurrect(all_unit_types[unit], checkQty);
							rRevive = true;
							Data.options.sJobs.push(sJob);
							break;
						} else {
							if (t.contentType == 4){
								t.dispFeedback (all_unit_types[unit] +' '+ reqs.msg);
							}
							++toResurrect;
						}
					}
				} else {
					try{
						document.getElementById(UID['tabJobResurrect_FB_'+unit]).innerHTML = '';
						document.getElementById(UID['tabJobResurrect_Troop_' + unit]).style.backgroundColor = "none";
					}catch(e){}
				}
			}
			if ( rRevive === false && toResurrect )
				recheck_reseurrect = true;
		}
		else {
			// We have a job running
			// Look at the record
			if (sJob) {
				var found = false;
				// Look for the job in persistent data
				for (var i=0; i < Data.options.sJobs.length; ++i) {
					// Check the sJob structure for a field called city_research_id or some such (like the building)
					// Otherwise, double-check that the ids match
					if (Data.options.sJobs[i] != undefined && Data.options.sJobs[i].id == sJob.id) {
						found = true;
					}
				}
				// If the job is not in persistent data, put it there
				if (!found) {
					Data.options.sJobs.push(sJob);
					consoleLog(translate('Putting resurrect job in persistent data'));
				}
			}
		}
		if (recheck_reseurrect) {
			Seed.fetchPlayer({cities:[cityId]});
			clearTimeout(t.resurrectTimer);
			t.resurrectTimer = setTimeout (t.resurrectTick, t.revRetryTime);
			if (t.contentType == 4){
				t.dispFeedback (translate('Completion errors')+ ': '+ translate('Retry in') +' '+ timestr(t.revRetryTime/1000) +' '+ translate('seconds'));
			}
			t.revRetryTime *= 1.5;
		}
	},

	attemptTrainQ : function (cityIdx, count, troopsLength, shortQ){
		var t = Tabs.Jobs;
		var troopQueued = false;

		//if (Seed.cities[cityIdx])
		//logit('Attempting troop training for '+Seed.cities[cityIdx].name+' - getTrainJob = '+inspectObj(getTrainJob (cityIdx))+', shortQ = '+shortQ);

		if (Seed.cities[cityIdx] && ((!getTrainJob (cityIdx) && shortQ) || !shortQ)) {
			// Get the troop types and quantities to build
			//logit('Attempt troop training for '+cityIdx+', length units = '+Data.options.training.city[cityIdx].units.length);
			for (var j = Data.options.training.city[cityIdx].units.length - 1; j >= 0; j--){
			//for (var j in Data.options.training.city[cityIdx].units){
				var troopType = '', troopQty = 0, cap = 0;
				switch (cityIdx) {
					case SPECTRAL_OUTPOST_ID : // Spectral outpost
						troopQty = 0;
						break;
					case WATER_OUTPOST_ID : // Water outpost
						troopType = water_outpost_units[j];
						troopQty = Data.options.training.city[cityIdx].units[j];
						break;
					case STONE_OUTPOST_ID : // Stone outpost
						troopType = stone_outpost_units[j];
						troopQty = Data.options.training.city[cityIdx].units[j];
						break;
					case FIRE_OUTPOST_ID : // Fire outpost
						troopType = fire_outpost_units[j];
						troopQty = Data.options.training.city[cityIdx].units[j];
						break;
					case WIND_OUTPOST_ID : // Wind outpost
						troopType = wind_outpost_units[j];
						troopQty = Data.options.training.city[cityIdx].units[j];
						break;
					default:
						troopType = capital_units[j];
						troopQty = Data.options.training.city[cityIdx].units[j];
						break;
				}
				//logit('Troop '+troopType+', qty '+troopQty);
				if (troopQty > 0) {
					cap = t.getTroopCap(troopType, troopQty);
					//logit('==> Test capped troop ? '+troopType+', qty = '+troopQty+', cap = '+cap);
					try {
						if (cap) {
							troopQty = 0;
							if (t.contentType == 1){
								t.dispFeedback(translate('Troops Capped'));
							}
							document.getElementById(UID['tabTrain_Troop_'+ cityIdx +'_'+ j]).style.backgroundColor = "red";
						}
						else if (t.contentType == 1){
							if (document.getElementById(UID['tabTrain_Troop_'+ cityIdx +'_'+ j]).style.backgroundColor == "red"){
								document.getElementById(UID['tabTrain_Troop_'+ cityIdx +'_'+ j]).style.backgroundColor = "white";
							}
						}
					} catch (e) {}
				}
				if (troopQty > 0) {
					var reqs = t.checkTrainReqs(troopType, troopQty, cityIdx);
					//logit('==> Test troop reqs ? '+troopType+', qty = '+troopQty+', reqs = '+reqs.msg);
					if (t.contentType == 1 && !reqs.msg){
						t.dispFeedback (translate('Training') + ' ' + nombreFormate(troopQty, ' ') + ' ' + translate(troopType) + ' (' + translate('UpKeep') + ' ' + (troopQty * Seed.stats.unit[troopType].upkeep.food) + ' ' + translate('Food') + ')');
					}
					if (!reqs.msg) {
						if (shortQ) {
							//logit('==> Do Short train '+troopType+', qty = '+troopQty+' for '+Seed.cities[cityIdx].name);
							t.doTrain(troopType, troopQty, cityIdx);
							troopQueued = true;
							break;
						} else {
							if (t.getRemainingQueue(cityIdx, 'units', false)){
								//logit('==> Do Long train '+troopType+', qty = '+troopQty+' for '+Seed.cities[cityIdx].name);
								t.doTrain(troopType, troopQty, cityIdx);
								troopQueued = true;
								break;
							} else {
								//logit('==> No avalable queue for train of '+troopType+', qty = '+troopQty+' for '+Seed.cities[cityIdx].name);
								break; // Exit loop as no queue is available for this city
							}
						}
					}
				} //else logit('==> No quantity to train for '+troopType+', qty = '+troopQty+' for '+Seed.cities[cityIdx].name);
			}
		}
		return troopQueued;
	},

	doTrain : function (troopType, troopQty, cityIdx){
		var t = Tabs.Jobs;
		var city = Seed.cities[cityIdx];
		var msg = translate('Training') + ': (' + troopQty +') '+ translate(troopType) +' '+ translate('at') +' '+ city.type;
		//t.dispFeedback (msg);

		MyAjax.troopTraining (troopType, troopQty, city.id, function (rslt){
			if (rslt.ok){
				t.trainErrorCount = 0;
				actionLog (msg);
			} 
			else {
				//Seed.fetchPlayer();
				verboseLog ('Error: Training: ' + rslt.errmsg);
				actionLog ('<B>' + translate('Error')+' '+translate('Training') + '</B>: ' + rslt.errmsg);
				// The queue is frequently full, but we could be getting server errors (500) too
				// Wait a couple of minutes
				if (++t.trainErrorCount > 5){
					if (t.contentType == 1){
						t.dispFeedback (translate('Too many errors, disabling auto training'));
					}
					t.setTrainEnable (false);
					t.trainErrorCount = 0;
				}
				else {
					if (t.contentType == 1){
						t.dispFeedback (translate('Error')+' '+translate('Training') +': '+ rslt.errmsg);
					}
					t.trainRetryTime *= 1.5;
				}
			}
			// Get the troops being built so the will be displayed
			Seed.updateCity ( rslt.dat.result.city );  
			// Get capital city to show new resources  
			if (rslt.dat.result.city.id !== Seed.cities[CAPITAL_ID].id) {  
				Seed.addToRefresh(Seed.cities[CAPITAL_ID].id, false);
				//Seed.fetchCity (Seed.cities[CAPITAL_ID].id);  
			}
		});
	},

	doBuild : function (building, city){
		var t = Tabs.Jobs;
		//var cityType = (city.type == "Capital") ? 'Capital' : city.type;
		var msg = '<B>' + translate('Building')+ '</B>: ' + translate(building.type) +' '+ translate('Level').toLowerCase() + ' ' + (building.level+1) +' '+ translate('at') +' '+ translate(city.type);
		
		if (t.contentType == 2){
			t.dispFeedback (msg);
		}
		
		MyAjax.buildingUpgrade (city.id, building.id, function (rslt){
			//logit ('BUILD RESULT: '+ inspectObj (rslt, 7, 1)); 
			if (rslt.ok){
				t.buildErrorCount = 0;
				actionLog (msg);
				clearTimeout ( t.buildTimer );
				t.buildTimer = setTimeout ( t.buildTick, 4000 );
				return;
			} 
			else {
				Seed.fetchPlayer({cities:[city.id]});
				actionLog (building.type + ': ' + rslt.errmsg);
				if (++t.buildErrorCount > 3){
					if (t.contentType == 2){
						t.dispFeedback (translate('Too many errors, disabling auto-build'));
					}
					t.setBuildEnable (false);
					t.buildErrorCount = 0;
					return;
				}
				if (t.contentType == 2){
					t.dispFeedback (building.type + ': ' + rslt.errmsg);
				}
				clearTimeout ( t.buildTimer );
				t.buildTimer = setTimeout ( t.buildTick, t.buildRetryTime );
				return;
			}
		});
	},

	doResearch : function (researchType, researchLevel){
		var t = Tabs.Jobs;
		var city = Seed.cities[CAPITAL_ID];
		var msg = '<b>' + translate('Researching') +': </b> '+ translate(t.resUITranslate(researchType)) + ' ('+ researchLevel +') ';
		if (t.contentType == 3){
			t.dispFeedback (msg);
		}
		actionLog('<B>' + translate('Research Started')+'</B>: '+ translate(t.resUITranslate(researchType)) + ' ('+ researchLevel +') ');
		
		MyAjax.researchStart (city.id, researchType, function (rslt){
			//logit ('RESEARCH RESULT: '+ inspectObj (rslt, 7, 1));       
			if (rslt.ok){
				t.resErrorCount = 0;
				actionLog (msg);
				return;
			} 
			else {
				Seed.fetchPlayer({cities:[city.id]});
				actionLog ('<B>' + translate('Research Error').toUpperCase()+ '</B>: ' + rslt.errmsg);
				if (++t.resErrorCount > 5){
					if (t.contentType == 3){
						t.dispFeedback (translate('Too many errors, disabling auto-research'));
					}
					t.setResearchEnable (false);
					t.resErrorCount = 0;
					return;
				}
				if (t.contentType == 3){
					t.dispFeedback (translate('RESEARCH ERROR')+ ': ' + rslt.errmsg);
				}
				return;
			}
		});
	},

	doResurrect : function (troopType, troopQty){
		var t = Tabs.Jobs;
		var city = Seed.cities[SPECTRAL_OUTPOST_ID];
		var msg = '<B>' + translate('Reviving') + '</B>: (' + troopQty +') '+ translate(troopType) +' '+ translate('at') +' '+ city.type;
		if (t.contentType == 4){
			t.dispFeedback (msg);
		}
		actionLog(msg);

		MyAjax.troopReviving (troopType, troopQty, city.id, function (rslt){
			clearTimeout ( t.resurrectTimer );
			if (rslt.ok){
				t.revErrorCount = 0;
				actionLog (msg);
				t.resurrectTimer = setTimeout(function() {t.resurrectTick(0) }, Math.randRange(3000, 13000));
			} 
			else {
				//Seed.fetchPlayer();
				verboseLog ('Error: Reviving: ' + rslt.errmsg);
				actionLog ('<B>' + translate('Error')+' '+translate('Reviving') + '</B>: ' + rslt.errmsg);
				// The queue is frequently full, but we could be getting server errors (500) too
				// Wait a couple of minutes
				if (++t.revErrorCount > 5){
					if (t.contentType == 4){
						t.dispFeedback (translate('Too many errors, disabling auto reviving'));
					}
					t.setResurrectEnable (false);
					t.revErrorCount = 0;
				}
				else {
					if (t.contentType == 4){
						t.dispFeedback (translate('Error')+' '+translate('Reviving') +': '+ rslt.errmsg);
					}
					t.resurrectTimer = setTimeout(function() {t.resurrectTick(ic) }, t.revRetryTime);
					t.revRetryTime *= 1.5;
				}
			}
			// Get the troops being built so the will be displayed
			Seed.updateCity ( rslt.dat.result.city );  
			// Get capital city to show new resources  
			if (rslt.dat.result.city.id !== Seed.cities[CAPITAL_ID].id) {  
				Seed.addToRefresh(Seed.cities[CAPITAL_ID].id, false);
				//Seed.fetchCity (Seed.cities[CAPITAL_ID].id);  
			}
		});
	}
	
}
//*********************************** Jobs Tab *********************************************


// Jawz *********************************** Alliance features Tab ****************************************
Tabs.Alliance = {
	tabOrder       : ALLIANCE_TAB_ORDER,
	tabLabel       : 'Alliance',
	tabDisabled    : !ALLIANCE_TAB_ENABLE,
	container      : null,
	contentType    : 0, // 0 = member list, 1 = transport, 2 = reinforcement
	totalResources : 0,
	maxResources   : 0,
	totalForces    : 0,
	recallTimer    : 0,
	lastSubTab     : 'tabAllianceList',

	init : function (div){
		var t = Tabs.Alliance;

		t.container = div;
		var m = '<div class=' + UID['title'] + '>' + translate('Alliance features') + '</div>'
			+'<div id='+ setUID('tabAlliance_Status') +' style="margin-bottom:5px !important">'
			+'	<input type=button value="' + translate('Refresh list') + '" id='+ setUID('tabAlliance_RefreshList') +' />'
			+'</div>'
			+'<ul class=tabs>'
			+'	<li class="tab first"><a id='+ setUID('tabAllianceList') +'>'+ translate('Members') +'</a></li>'
			+'	<li class=tab><a id='+ setUID('tabAllianceTrans') +'>'+ translate('Transport') +'</a></li>'
			+'	<li class=tab><a id='+ setUID('tabAllianceReinforcement') +'>'+ translate('Reinforcement') +'</a></li>'
			+'</ul>'
			+'<div id='+ setUID('tabAlliance_Content') +' style="padding-top:0px; height:655px; ; max-height:655px; overflow-y:auto"></div>';

		t.container.innerHTML = m;
		document.getElementById(UID['tabAlliance_RefreshList']).addEventListener ('click', t.refreshList, false);
		document.getElementById(UID['tabAllianceList']).addEventListener ('click', t.tabAllianceList, false);	
		document.getElementById(UID['tabAllianceTrans']).addEventListener ('click', t.tabAllianceTrans, false);	
		document.getElementById(UID['tabAllianceReinforcement']).addEventListener ('click', t.tabAllianceReinforcement, false);	
		window.addEventListener('unload', t.onUnload, false);
		t.contentType = isEmpty(Data.options.alliance.current_tab,0);
		t.show();
	},

	show : function (){
		var t = Tabs.Alliance;
		if (!t.checkMembersBusy) {
			switch (isEmpty(t.contentType, 0)) {
				case 0: t.tabAllianceList(); break;
				case 1: t.tabAllianceTrans(); break;
				case 2: t.tabAllianceReinforcement(); break;
			}
		} else setTimeout(t.show, 100);
	},

	onUnload : function (){
		var t = Tabs.Alliance;
		logit ('===============  Tabs.Alliance.onUnload');
		Data.options.alliance.current_tab = t.contentType;
	},

	hide : function (){
	},

	refreshList : function (){
		var t = Tabs.Alliance;
		if (t.checkMembersBusy)
			return false;
		t.checkMembersBusy = true;
		t.getAllianceMembers(function(){logit(translate ('Alliance members list retrieved')); Tabs.Alliance.checkMembersBusy = false});
		var now = serverTime();
		Data.options.alliance.last_update = new Date(now * 1000).myString();
		t.show ();
	},

	getAllianceMembers : function (notify){
		var t = Tabs.Alliance;
		ret = [];
		if (Data.dynamic.players.memberships && Data.dynamic.players.memberships != undefined && Data.dynamic.players.memberships.length > 0)
			for (var i=0; i<Data.dynamic.players.memberships.length; i++)
				ret.push ({id:Data.dynamic.players.memberships[i].id, might:Data.dynamic.players.memberships[i].might});
		Data.dynamic.players.memberships_evolution = cloneProps(ret);
		Data.dynamic.players.memberships = {player:'', id:0, role:'', might:0, city:'', x:0, y:0, dist:0};
		var dial = new ModalDialog (t.container, 300, 165, '', false, null);
		dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
		dial.getContentDiv().innerHTML = translate ('Search for alliance members');
		MemberShips.fetchMembership (callback, false);
		function callback (dat){
			if (dat==null){
				dial.getContentDiv().innerHTML = translate ('Error while retrieving the list of members');
				dial.allowClose (true);
				if (notify)
					notify (false);
				return;
			}
			if (dat.done){
				Data.dynamic.players.memberships = cloneProps(dat.member);
				logit ('*********  List retrieved ... Total members: '+ Data.dynamic.players.memberships.length);
				function charOrdA(a, b){
					a = a.player.toLowerCase(); b = b.player.toLowerCase();
					if (a>b) return 1;
					if (a <b) return -1;
					return 0;
				}
				Data.dynamic.players.memberships.sort(charOrdA);
				Data.options.alliance.sort_list = '2';
				//t.getMemberList();
				if (notify)
					notify(true);
				dial.destroy();
			}
		}
	},

	//** ALLIANCE MEMBERS LIST SUB-TAB ***
	tabAllianceList : function (){
		var t = Tabs.Alliance;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabAllianceList']).className='selected';
		document.getElementById(UID['tabAllianceList']).style.zIndex=1;
		t.lastSubTab = 'tabAllianceList';

		t.contentType = 0;

		if (!Data.options.alliance.sort_list ||
			Data.options.alliance.sort_list == null ||
			Data.options.alliance.sort_list == undefined)
			Data.options.alliance.sort_list = '0';
		if (Data.options.alliance.last_update &&
			Data.options.alliance.last_update != null &&
			Data.options.alliance.last_update != undefined)
			kLastupdate = ' ('+Data.options.alliance.last_update+')';
		else kLastupdate = '';

		var m = '<div id=' + setUID('tabAlliance_Results') + ' style="height:640px">'
			+'	<div class=' + UID['title'] + '>' + translate('Members list ') + kLastupdate + '</div>'
			+'	<div id=' + setUID('tabAlliance_ResultList') + ' class=' + UID['status_ticker'] + ' style="height:620px; max-height:620px; overflow-y:auto ; overflow-x:auto ; margin-top:1px !important"></div>'
			+'	</div>';
		document.getElementById(UID['tabAlliance_Content']).innerHTML = m;

		var m = '<table class=' + UID['table'] + '>'
			+'	<tr class=' + UID['row_headers'] +'>'
			+'		<td id=' + setUID('tabAlliance_tal_0') + ' width="40px"><A><span>' + translate('Dist') + '</span></A></td>'
			+'		<td id=' + setUID('tabAlliance_tal_1') + ' width="55px"><A><span>' + translate('Coords') + '</span></A></td>'
			+'		<td id=' + setUID('tabAlliance_tal_2') + ' width="150px" style="overflow-x:auto"><A><span>' + translate('Player name') + '</span></A></td>'
			+'		<td id=' + setUID('tabAlliance_tal_3') + ' width="65px" style="overflow-x:auto"><A><span>' + translate('Role') + '</span></A></td>'
			+'		<td id=' + setUID('tabAlliance_tal_4') + ' width="65px" align=right><A><span>' + translate('Might') + '</span></A></td>'
			+'		<td width="60px" align=right>' + translate('Evol') + '</td>'
			+'	</tr>';
		for (var i=0; i<Data.dynamic.players.memberships.length; i++){
			m += '<tr><td>' + Data.dynamic.players.memberships[i].dist + '</td>'
			+'	<td align=center>' + Data.dynamic.players.memberships[i].x +','+ Data.dynamic.players.memberships[i].y + '</td>';
			var mightF = nombreFormate(Data.dynamic.players.memberships[i].might,' ');
			var found = false;
			var evol = 'x';
			for (var old=0; old<Data.dynamic.players.memberships_evolution.length && !found; old++){
				if (Data.dynamic.players.memberships_evolution[old].id == Data.dynamic.players.memberships[i].id){
					evol = Data.dynamic.players.memberships[i].might - Data.dynamic.players.memberships_evolution[old].might;
					if (evol < 0) evol = '<span class=' + UID['red'] + '>' + nombreFormate(evol,' ') + '</span>';
					else if (evol > 0) evol = '<span class=' + UID['green'] + '>+' + nombreFormate(evol,' ') + '</span>';
					else evol = nombreFormate(evol,' ');
					found = true;
				}
			}
			if (Data.dynamic.players.memberships[i].role == 'vassal') var pRole = '';
			else var pRole = translate(Data.dynamic.players.memberships[i].role);
			m += '<td align=left>' + Data.dynamic.players.memberships[i].player + '</td>'
			+'	<td align=left>' + pRole + '</td>'
			+'	<td align=right>' + mightF + '</td>'
			+'	<td align=right>' + evol + '</td>'
			+'</tr>';
		}
		document.getElementById(UID['tabAlliance_ResultList']).innerHTML = m + '</table>';
		for (var h=0; h<5; h++)
			document.getElementById(UID['tabAlliance_tal_' + h]).addEventListener ('click', sortMembList, false);

		function sortMembList (e){
			var t = Tabs.Alliance;
			var arg = e.target.parentNode.parentNode.id;
			if (arg == UID['tabAlliance_tal_0']){
				if (Data.options.alliance.sort_list == '0'){
					Data.dynamic.players.memberships.sort(function(a,b){return b.dist-a.dist});
					Data.options.alliance.sort_list = '-0';
				} else {
					Data.dynamic.players.memberships.sort(function(a,b){return a.dist-b.dist});
					Data.options.alliance.sort_list = '0';
				}
			} else if (arg == UID['tabAlliance_tal_1']){
				if (Data.options.alliance.sort_list == '1'){
					Data.dynamic.players.memberships.sort(function(a,b){return b.x-a.x});
					Data.options.alliance.sort_list = '-1';
				} else {
					Data.dynamic.players.memberships.sort(function(a,b){return a.x-b.x});
					Data.options.alliance.sort_list = '1';
				}
			} else if (arg == UID['tabAlliance_tal_2']){
				if (Data.options.alliance.sort_list == '2'){
					Data.dynamic.players.memberships.sort(function(a, b){a = a.player.toLowerCase(); b = b.player.toLowerCase(); if (a>b) return -1; if (a <b) return 1; return 0;});
					Data.options.alliance.sort_list = '-2';
				} else {
					Data.dynamic.players.memberships.sort(function(a, b){a = a.player.toLowerCase(); b = b.player.toLowerCase(); if (a>b) return 1; if (a <b) return -1; return 0;});
					Data.options.alliance.sort_list = '2';
				}
			} else if (arg == UID['tabAlliance_tal_3']){
				if (Data.options.alliance.sort_list == '3'){
					Data.dynamic.players.memberships.sort(function(a, b){a = a.role.toLowerCase(); b = b.role.toLowerCase(); if (a>b) return -1; if (a <b) return 1; return 0;});
					Data.options.alliance.sort_list = '-3';
				} else {
					Data.dynamic.players.memberships.sort(function(a, b){a = a.role.toLowerCase(); b = b.role.toLowerCase(); if (a>b) return 1; if (a <b) return -1; return 0;});
					Data.options.alliance.sort_list = '3';
				}
			} else if (arg == UID['tabAlliance_tal_4']){
				if (Data.options.alliance.sort_list == '4'){
					Data.dynamic.players.memberships.sort(function(a,b){return b.might-a.might});
					Data.options.alliance.sort_list = '-4';
				} else {
					Data.dynamic.players.memberships.sort(function(a,b){return a.might-b.might});
					Data.options.alliance.sort_list = '4';
				}
			}
			t.tabAllianceList();
		}
	},

	//** ALLIANCE TRANSPORT SUB-TAB ***
	tabAllianceTrans : function (){
		var t = Tabs.Alliance;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabAllianceTrans']).className='selected';
		document.getElementById(UID['tabAllianceTrans']).style.zIndex=1;
		t.lastSubTab = 'tabAllianceTrans';
		t.contentType = 1;

		var m = '<div id=' + setUID('tabAlliance_Results') + ' style="height:590px">'
			+'	<div class=' + UID['title'] + '>' + translate('Send resources') + '</div>'
			+'	<div id=' + setUID('tabAlliance_Status') + ' class=' + UID['status_ticker'] + ' style="margin-bottom:5px !important">'
			+'	<table class=' + UID['table'] + ' width=100%>'
			+'		<tr class=' + UID['row_headers_left'] + ' align=left>'
			+'			<td align=left colspan=2>' + translate ('Recipient') + ' : </td>'
			+'		</tr><tr>'
			+'			<td><div id=' + setUID('tabAlliance_TransPlayerList') + '></div></td>'
			+'			<td><div id=' + setUID('tabAlliance_TransTarget') + ' style="height: 17px; padding: 2px 0px;"></div></td>'
			+'		</tr>'
			+'	</table><br>'
			+'	<br>'
			+'	<table id=' + setUID('tabAlliance_TabYoyo') + ' class=' + UID['table'] + '>'
			+'		<tr align=left class=' + UID['row_headers_left'] + '>'
			+'			<td colspan=2>'+ translate('Yoyo functionality') +':&nbsp;</td>'
			+'		</tr>'
			+'		<tr align=left>'
			+'			<td>'+ translate('Automatically recall transport 1 minute before delivery') +':&nbsp;</td>'
			+'			<td><input id=' + setUID('tabAlliance_Yoyo') + ' type=checkbox '+ (Data.options.alliance.recall?'CHECKED':'') +' /></td>'
			+'		</tr>'
			+'	</table><br>'
			+'	<table id=' + setUID('tabAlliance_TTroops') + ' class=' + UID['table'] + '>'
			+'		<tr align=left class=' + UID['row_headers_left'] + '>'
			+'			<td colspan=4>'+ translate('Troops for transport') +':&nbsp;</td>'
			+'		</tr>'
			+'	</table><br>'
			+'	<table id=' + setUID('tabAlliance_Resources') + ' class=' + UID['table'] + ' width=100%>'
			+'		<tr align=left class=' + UID['row_headers_left'] + '>'
			+'			<td colspan=4>'+ translate('Resources to transport') +':&nbsp;</td>'
			+'		</tr>';

		var UIDRes = setUID('tabAlliance_Res');
		var UIDMax = setUID('tabAlliance_Max');
		for (var p=0; p<transportable_resource_types.length; p++){
			var actualStock = nombreFormate(Math.round(isEmpty(Seed.cities[CAPITAL_ID].resources[transportable_resource_types[p]],0)));
			m += '<tr><td class=right width=70px>' + translate(transportable_resource_types[p]) + ' :</td>'
			+'	<td width=90px>'
			+'		<input type=text id=' + UIDRes + '_' + p +' maxlength=10 style="width:70px" size=2 value="'+ parseIntZero(Data.options.alliance.data.resources[transportable_resource_types[p]]) +'"\></td>'
			+'	<td width=30px>'
			+'		<input class=small id=' + UIDMax + '_' + p +' ref=' + p + ' type=button style="width:auto !important;" value=" Max " \></td>'
			+'	<td align=right width=90px>'+ actualStock +'</td>'
			+'<td></td></tr>';
		}

		m += '<tr><td align=right class=right>' + translate ('Load capacity') + '&nbsp:</td>'
		+'		<td colspan=4 align=left><div id=' + setUID('tabAlliance_Total') + '></div></td>'
		+'	</tr>'
		+'</table><br><br>'
		+'<center><input id=' + setUID('tabAlliance_Launch') + ' type=button value="' + translate('Send transport') + '" /></center>'
		+'<br></div></div>';

		document.getElementById(UID['tabAlliance_Content']).innerHTML = m;

		document.getElementById(UID['tabAlliance_Yoyo']).addEventListener ('click', function(e){Data.options.alliance.recall=e.target.checked}, false);
		document.getElementById(UID['tabAlliance_Launch']).addEventListener ('click', sendTransp, false);
		troopTable (document.getElementById(UID['tabAlliance_TTroops']), 1, 'TR', eventTroopsTransport);
		for (i=0; i<transportable_resource_types.length; i++){
			document.getElementById(UIDRes + '_' + i).addEventListener('change', resourceChanged, false);
			butMax = document.getElementById(UIDMax + '_' + i);
			butMax.addEventListener('click', setResourceMax, false);
			setButtonStyle (butMax, true);
		}
		getMemberList();
		t.displayTotal();

		function troopTable (tab, rownum, prefix, listener){
			var t = Tabs.Alliance;
			var row =[];
			row.push(tab.insertRow(rownum));
			row.push(tab.insertRow(rownum+1));
			row.push(tab.insertRow(rownum+2));

			var val, c=0;
			for (var i=0; i < transport_unit_types.length; ++i)
			{
				row[0].insertCell(c).innerHTML = translate (transport_unit_types[i]);
				
				var inp = document.createElement ('input');
				inp.type = 'text';
				inp.size = '2';
				inp.style.width = '65px';
				inp.title = translate(transport_unit_types[i]);
				inp.style.border = '1px solid grey';
				inp.maxlength = '6'; // Allow 100,000 troops to be sent
				if (prefix=='TR'){
					if (Data.options.alliance.data.transports[Names.troops.byAbbr[transport_unit_types[i]][1]] == undefined){
						Data.options.alliance.data.transports[Names.troops.byAbbr[transport_unit_types[i]][1]] = 0;
					}
					val = Data.options.alliance.data.transports[Names.troops.byAbbr[transport_unit_types[i]][1]];
				}
				if (!val){
					val = 0;
				}
				inp.value = val;
				inp.name = prefix +'_'+ i;
				inp.addEventListener ('change', listener, false);
				row[1].insertCell(c).appendChild (inp);
				var trp_cell = row[2].insertCell(c);
				var stk = nombreFormate(parseIntZero(Seed.cities[CAPITAL_ID].units[Names.troops.byAbbr[transport_unit_types[i]][1]]),' ');
				trp_cell.className = 'jewel';
				trp_cell.innerHTML = '(&nbsp;'+ stk +'&nbsp;)';
				c = c + 1;
			}
			return tab;
		}
		function eventTroopsTransport (e){
			var t = Tabs.Alliance;
			var args = e.target.name.split('_');
			var x = parseIntZero(e.target.value);
			if (args[0] == 'TR'){
				if (isNaN(x) || x<0 || x>getMusterPointMaxTroops (0)){
					e.target.style.backgroundColor = 'red';
				} else {
					Data.options.alliance.data.transports[Names.troops.byAbbr[transport_unit_types[args[1]]][1]] = x;
					var tr = Data.options.alliance.data.transports;
					var tt = Names.troops.byAbbr[transport_unit_types[args[1]]][1];
					tr[tt] = e.target.value;
					e.target.style.backgroundColor = '';
				}
			}
			t.displayTotal();
		}
		function resourceChanged (e){
			var args = e.target.id.split('_');
			var x = parseIntZero(e.target.value);
			t.totalResources = 0;
			for (var r=0; r<transportable_resource_types.length; r++)
				if (r != args[1]) t.totalResources = parseIntZero(t.totalResources) + parseIntZero(Data.options.alliance.data.resources[transportable_resource_types[r]]);
			for (i=0; i<transportable_resource_types.length; i++)
				document.getElementById(UID['tabAlliance_Res'] + '_' + i).style.backgroundColor = '';
			if (isNaN(x) || x<0 || (x + parseIntZero(t.totalResources))>parseIntZero(t.maxResources)){
				e.target.style.backgroundColor = 'red';
			}else {
				e.target.style.backgroundColor = '';
			}
			e.target.value = parseIntZero(x);
			Data.options.alliance.data.resources[transportable_resource_types[args[1]]] = parseIntZero(x);
			t.displayTotal();
		}
		function setResourceMax (e){
			var args = e.target.id.split('_');
			var max = 0;
			var cur = parseIntZero(Seed.cities[CAPITAL_ID].resources[transportable_resource_types[args[1]]]);
			t.totalResources = 0;
			for (var r=0; r<transportable_resource_types.length; r++)
				if (r != args[1]) t.totalResources = parseIntZero(t.totalResources) + parseIntZero(Data.options.alliance.data.resources[transportable_resource_types[r]]);
			max = parseIntZero(t.maxResources) - parseIntZero(t.totalResources);
			if (max > cur) max = cur;
			Data.options.alliance.data.resources[transportable_resource_types[args[1]]] = parseIntZero(max);
			t.tabAllianceTrans();
		}
		function setButtonStyle (theButton, enabled) {
			if (enabled) {
				theButton.disabled = false;
				Element.removeClassName(theButton, UID['bnt_disabled']);
				Element.addClassName(theButton, UID['bnt_green']);
			} else {
				theButton.disabled = true;
				Element.removeClassName(theButton, UID['bnt_green']);
				Element.addClassName(theButton, UID['bnt_disabled']);
			}
		}
		function sendTransp (){
			var dial = new ModalDialog (t.container, 300, 150, '', false);
			dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
			dial.getContentDiv().innerHTML = translate('Sending transport');
			checkTransport (notify);
			function notify (rslt){
				if (rslt!='OK'){
					dial.getContentDiv().innerHTML = '<B>'+ rslt +'</b>';
					dial.allowClose (true);
				} else {
					dial.getContentDiv().innerHTML = '<B> OK </b>';
					setTimeout (function(){dial.destroy()}, 1000);
					t.show(); // Refresh of current data
				}
			}
		}
		function checkTransport (notify){
			var t = Tabs.Alliance;
			var cityId = Seed.cities[CAPITAL_ID].id;
			var cityIdx = CAPITAL_ID;
			// check resources
			var ress = Data.options.alliance.data.resources;
			var totRess = 0;
			for (var p in ress)
				if (ress[p] > 0)
					totRess += ress[p];
			if (totRess <= 0){
				notify (translate('No resources to transport defined'));
				return;
			}
			// check troops
			var units = Data.options.alliance.data.transports;
			var totTroops = 0;
			for (var p in units){
				if (units[p] > 0){
					totTroops += units[p];
					if (Seed.cities[cityIdx].units[p] < units[p]){
						notify (translate('Not enough') + ' ' + translate(p));
						return;
					}
				}
			}
			if (totTroops <= 0){
				notify (translate('No Troops Defined'));
				return;
			}
			var authMaxTroops = getMusterPointMaxTroops (cityIdx);
			for (var p in units) {
				if (units[p] > 0) {
					if (units[p] > authMaxTroops ) {
						notify (translate('Too many troops for muster point level'));
						return;
					}
				}
			}
			if (totTroops > authMaxTroops) {
				notify (translate('Too many troops for muster point level'));
				return;
			}
			if (getMusterPointSlots (cityIdx) <= 0){
				notify (translate('Muster Point Full'));
				return;
			}
			var found = false;
			for (var cid=1; cid < Seed.cities.length && !found; cid++) {
				if (Seed.cities[cid] && Data.options.alliance.transport_id == Seed.cities[cid].id) {
					found = true;
					var targetName = translate(Seed.cities[cid].name);
					var targetX = Seed.cities[cid].x;
					var targetY = Seed.cities[cid].y;
					var targMsg = '<B>' + translate('Transport sent to') + '</B> : ' + targetName  + ' ' + translate ('at') + ' ' + targetX +','+ targetY;
				}
			}
			if (!found) {
				for (var i=0; i<Data.dynamic.players.memberships.length && !found; i++){
					if (Data.dynamic.players.memberships[i].id == Data.options.alliance.transport_id){
						found = true;
						var targetName = Data.dynamic.players.memberships[i].player;
						var targetCity = Data.dynamic.players.memberships[i].city;
						var targetX = Data.dynamic.players.memberships[i].x;
						var targetY = Data.dynamic.players.memberships[i].y;
					}
				}
				var targMsg = '<B>' + translate('Transport sent to') + '</B> : ' + targetName  + ', ' + targetCity + ' ' + translate ('at') + ' ' + targetX +','+ targetY;
			}
			verboseLog(targMsg +' '+ translate('Attempted'));
			new MyAjax.TransportMarch (cityId, targetX, targetY, units, ress, 'transport', function (rslt){
				if (rslt.ok && rslt.dat.result.success){
					Marches.add(rslt.dat.result.job.march_id, 'attacks');
					verboseLog(targMsg +' '+ translate('Successfully'));
					actionLog(targMsg);
					if (Data.options.alliance.recall) {
						var m = {cityId:cityId, marchId:rslt.dat.result.job.march_id, run_at:rslt.dat.result.job.run_at};
						Data.dynamic.recall_marches.push (m);
					}
					notify ('OK');
				} else {
					verboseLog(targMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg);
					if (notify){
						notify(translate('Error') + ': ' + rslt.errmsg);
					}
				}
			});
		}
		function getMemberList (){
			var t = Tabs.Alliance;
			var m = '<select id=' + setUID('tabAlliance_TransPlayer') + '>';
			var selected = '';
			for (var cityIdx=1; cityIdx < Seed.cities.length; cityIdx++) {
				if (Seed.cities[cityIdx]) {
					selected = '';
					if (Data.options.alliance.transport_id == Seed.cities[cityIdx].id) selected = ' selected';
					m += '<option value="' + Seed.cities[cityIdx].id + '" '+selected+'>' + translate(Seed.cities[cityIdx].name) + '</option>';
				}
			}
			if (Seed.cities.length < 2 && (!Data.dynamic.players.memberships || Data.dynamic.players.memberships.length == 0))
				m += '<option value="">' + translate('To be refreshed') + '</option>';
			else {
				for (var i=0; i<Data.dynamic.players.memberships.length; i++){
					selected = '';
					if (Data.dynamic.players.memberships[i].id == Data.options.alliance.transport_id) selected = ' selected';
					m += '<option value="' + Data.dynamic.players.memberships[i].id + '" '+selected+'>' + Data.dynamic.players.memberships[i].player + '</option>';
				}
			}
			m += '</select>';
			document.getElementById(UID['tabAlliance_TransPlayerList']).innerHTML = m;
			document.getElementById(UID['tabAlliance_TransPlayer']).addEventListener('change', playerSelChanged, false);
			playerCityDesc();
		}
		function playerSelChanged (e){
			var t = Tabs.Alliance;
			var id = document.getElementById(UID['tabAlliance_TransPlayer']);
			var sel = isEmpty(id.value,'none');
			id.value = sel;
			Data.options.alliance.transport_id = sel;
			playerCityDesc();
		}
		function playerCityDesc (){
			var t = Tabs.Alliance;
			var found = false;
			for (var cityIdx=1; cityIdx < Seed.cities.length && !found; cityIdx++) {
				if (Seed.cities[cityIdx] && Data.options.alliance.transport_id == Seed.cities[cityIdx].id) {
					found = true;
					document.getElementById(UID['tabAlliance_TransTarget']).innerHTML = '<B>' + translate(Seed.cities[cityIdx].name) + '</b>' +
						' &nbsp; ('+Seed.cities[cityIdx].x + ', '+Seed.cities[cityIdx].y +
						') &nbsp; <B>' + translate('Distance') + ': </b>' + 
						getDistance(Seed.cities[CAPITAL_ID].x, Seed.cities[CAPITAL_ID].y, Seed.cities[cityIdx].x, Seed.cities[cityIdx].y);
				}
			}
			if (!found) {
				for (var i=0; i<Data.dynamic.players.memberships.length && !found; i++){
					if (Data.dynamic.players.memberships[i].id == Data.options.alliance.transport_id){
						found = true;
						document.getElementById(UID['tabAlliance_TransTarget']).innerHTML = translate('City') + ' &nbsp; <B>' + Data.dynamic.players.memberships[i].city + '</b>' +
							' &nbsp; ('+Data.dynamic.players.memberships[i].x + ', '+Data.dynamic.players.memberships[i].y +
							') &nbsp; <B>' + translate('Distance') + ': </b>' + Data.dynamic.players.memberships[i].dist;
					}
				}
			}
		}
	},

  //** ALLIANCE REINFORCEMENT SUB-TAB ***
	tabAllianceReinforcement : function (){
		var t = Tabs.Alliance;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabAllianceReinforcement']).className='selected';
		document.getElementById(UID['tabAllianceReinforcement']).style.zIndex=1;
		t.lastSubTab = 'tabAllianceReinforcement';
		t.contentType = 2;

		var m = '<div id=' + setUID('tabAlliance_Results') + ' style="height:590px">'
			+'	<div class=' + UID['title'] + '>' + translate('Reinforcement') + '</div>'
			+'	<div id=' + setUID('tabAlliance_Status') + ' class=' + UID['status_ticker'] + ' style="margin-bottom:5px !important">'
			+'	<table class=' + UID['table'] + ' width=100%>'
			+'		<tr class=' + UID['row_headers_left'] + ' align=left>'
			+'			<td align=left colspan=2>' + translate ('Recipient') + ' : </td>'
			+'		</tr><tr>'
			+'			<td><div id=' + setUID('tabAlliance_ReinfPlayerList') + '></div></td>'
			+'			<td><div id=' + setUID('tabAlliance_ReinfTarget') + ' style="height: 17px; padding: 2px 0px;"></div></td>'
			+'		</tr>'
			+'	</table><br>'
			+'	<br>'
			+'	<table id=' + setUID('tabAlliance_RTroops') + ' class=' + UID['table'] + '>'
			+'		<tr align=left class=' + UID['row_headers_left'] + '>'
			+'			<td colspan=4>'+ translate('Troops for reinforcement') +':&nbsp;</td>'
			+'		</tr>';

		var UIDTrp = setUID('tabAlliance_Trp');
		var UIDMax = setUID('tabAlliance_MaxT');
		for (i=0; i<all_unit_types.length; i++){
			var num = parseIntZero(Data.options.alliance.data.units[all_unit_types[i]]);
			var stk = nombreFormate(parseIntZero(Seed.cities[CAPITAL_ID].units[all_unit_types[i]]),' ');
			m += '<tr><td class=right width="100px">'+ translate(Names.troops.byName[all_unit_types[i]][1]) +':</td>'
			+'	<td width="75px">'
			+'		<input type=text id=' + UIDTrp + '_' + i +' maxlength=6 style="width:55px" size=2 value="'+ num +'"\></td>'
			+'	<td width="30px">'
			+'		<input class=small id=' + UIDMax + '_' + i +' ref=' + i + ' type=button  style="width:auto !important;" value=" Max " \></td>'
			+'	<td align=right width="70px">'+ stk +'</td>'
			+'</tr>';
		}

		m += '</table><br><br>'
		+'<center><input id=' + setUID('tabAlliance_LaunchR') + ' type=button value="' + translate('Send reinforcement') + '" /></center>'
		+'<br></div></div>';
		document.getElementById(UID['tabAlliance_Content']).innerHTML = m;

		document.getElementById(UID['tabAlliance_LaunchR']).addEventListener ('click', SendReinforcement, false);
		for (i=0; i<all_unit_types.length; i++){
			document.getElementById(UIDTrp + '_' + i).addEventListener('change', eventTroopsReinforcemment, false);
			butMax = document.getElementById(UIDMax + '_' + i);
			butMax.addEventListener('click', setTroupsMax, false);
			setButtonStyle (butMax, true);

		}
		getMemberList();

		function eventTroopsReinforcemment (e){
			var args = e.target.id.split('_');
			var x = parseIntZero(e.target.value);
			t.totalForces = 0;
			for (var r=0; r<all_unit_types.length; r++)
				if (r != args[1]) t.totalForces = parseIntZero(t.totalForces) + parseIntZero(Data.options.alliance.data.units[all_unit_types[r]]);
			for (i=0; i<all_unit_types.length; i++)
				document.getElementById(UID['tabAlliance_Trp'] + '_' + i).style.backgroundColor = '';
			if (isNaN(x) || x<0 || (x + parseIntZero(t.totalForces))>getMusterPointMaxTroops (0)){
				e.target.style.backgroundColor = 'red';
			}else {
				e.target.style.backgroundColor = '';
			}
			e.target.value = x;
			Data.options.alliance.data.units[all_unit_types[args[1]]] = x;
		}
		function setTroupsMax (e){
			var args = e.target.id.split('_');
			var max = 0;
			var cur = parseIntZero(Seed.cities[CAPITAL_ID].units[all_unit_types[args[1]]]);
			t.totalForces = 0;
			for (var r=0; r<all_unit_types.length; r++)
				if (r != args[1]) t.totalForces = parseIntZero(t.totalForces) + parseIntZero(Data.options.alliance.data.units[all_unit_types[r]]);
			max = getMusterPointMaxTroops (0) - parseIntZero(t.totalForces);
			if (max > cur) max = cur;
				Data.options.alliance.data.units[all_unit_types[args[1]]] = parseIntZero(max);
			t.tabAllianceReinforcement();
		}
		function setButtonStyle (theButton, enabled) {
			if (enabled) {
				theButton.disabled = false;
				Element.removeClassName(theButton, UID['bnt_disabled']);
				Element.addClassName(theButton, UID['bnt_green']);
			} else {
				theButton.disabled = true;
				Element.removeClassName(theButton, UID['bnt_green']);
				Element.addClassName(theButton, UID['bnt_disabled']);
			}
		}
		function SendReinforcement (){
			var dial = new ModalDialog (t.container, 300, 150, '', false);
			dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
			dial.getContentDiv().innerHTML = translate('Sending reinforcement');
			checkReinforcement (notify);
			function notify (rslt){
				if (rslt!='OK'){
					dial.getContentDiv().innerHTML = '<B>'+ rslt +'</b>';
					dial.allowClose (true);
				} else {
					dial.getContentDiv().innerHTML = '<B> OK </b>';
					setTimeout (function(){dial.destroy()}, 1000);
					t.show(); // Refresh of current data
				}
			}
		}
		function checkReinforcement (notify){
			var t = Tabs.Alliance;
			var cityId = Seed.cities[CAPITAL_ID].id;
			var cityIdx = CAPITAL_ID;
			var availableGeneral = null;
			// check troops
			var units = Data.options.alliance.data.units;
			var totTroops = 0;
			for (var p in units){
				if (units[p] > 0){
					totTroops += units[p];
					if (Seed.cities[cityIdx].units[p] < units[p]){
						notify (translate('Not enough') + ' ' + translate(p));
						return;
					}
				}
			}
			if (totTroops <= 0){
				notify (translate('No Troops Defined'));
				return;
			}
			var authMaxTroops = getMusterPointMaxTroops (cityIdx);
			for (var p in units) {
				if (units[p] > 0) {
					if (units[p] > authMaxTroops) {
						notify (translate('Too many troops for muster point level'));
						return;
					}
				}
			}
			if (totTroops > authMaxTroops) {
				notify (translate('Too many troops for muster point level'));
				return;
			}
			if (getMusterPointSlots (cityIdx) <= 0){
				notify (translate('Muster Point Full'));
				return;
			}
			availableGeneral = getAvailableGeneral ();
			if (availableGeneral == null){
				notify (translate('No generals available'));
				return;
			}
			var found = false;
			for (var cid=1; cid < Seed.cities.length && !found; cid++) {
				if (Seed.cities[cid] && Data.options.alliance.reinforce_id == Seed.cities[cid].id) {
					found = true;
					var targetName = translate(Seed.cities[cid].name);
					var targetX = Seed.cities[cid].x;
					var targetY = Seed.cities[cid].y;
					var targMsg = '<B>' + translate('Reinforcement sent to') + '</B> : ' + targetName  + ' ' + translate ('at') + ' ' + targetX +','+ targetY;
				}
			}
			if (!found) {
				for (var i=0; i<Data.dynamic.players.memberships.length && !found; i++){
					if (Data.dynamic.players.memberships[i].id == Data.options.alliance.reinforce_id){
						found = true;
						var targetName = Data.dynamic.players.memberships[i].player;
						var targetCity = Data.dynamic.players.memberships[i].city;
						var targetX = Data.dynamic.players.memberships[i].x;
						var targetY = Data.dynamic.players.memberships[i].y;
					}
				}
				var targMsg = '<B>' + translate('Reinforcement sent to') + '</B> : ' + targetName  + ', ' + targetCity + ' ' + translate ('at') + ' ' + targetX +','+ targetY;
			}
			new MyAjax.marchSend (cityId, targetX, targetY, availableGeneral.id, units, 'attacks', function (rslt){
				if (rslt.ok && rslt.dat.result.success){
					Marches.add(rslt.dat.result.job.march_id, 'attacks');
					verboseLog(targMsg +' '+ translate('Successfully'));
					actionLog(targMsg);
					notify ('OK');
				} else {
					verboseLog(targMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg);
					if (notify){
						notify(translate('Error') + ': ' + rslt.errmsg);
					}
				}
			});
		}
		function getMemberList (){
			var t = Tabs.Alliance;
			var m = '<select id=' + setUID('tabAlliance_ReinfPlayer') + '>';
			var selected = '';
			for (var cityIdx=1; cityIdx < Seed.cities.length; cityIdx++) {
				if (Seed.cities[cityIdx]) {
					selected = '';
					if (Data.options.alliance.reinforce_id == Seed.cities[cityIdx].id) selected = ' selected';
					m += '<option value="' + Seed.cities[cityIdx].id + '" '+selected+'>' + translate(Seed.cities[cityIdx].name) + '</option>';
				}
			}
			if (Seed.cities.length < 2 && (!Data.dynamic.players.memberships || Data.dynamic.players.memberships.length == 0))
				m += '<option value="">' + translate('To be refreshed') + '</option>';
			else {
				for (var i=0; i<Data.dynamic.players.memberships.length; i++){
					selected = '';
					if (Data.dynamic.players.memberships[i].id == Data.options.alliance.reinforce_id) selected = ' selected';
					m += '<option value="' + Data.dynamic.players.memberships[i].id + '" '+selected+'>' + Data.dynamic.players.memberships[i].player + '</option>';
				}
			}
			m += '</select>';
			document.getElementById(UID['tabAlliance_ReinfPlayerList']).innerHTML = m;
			document.getElementById(UID['tabAlliance_ReinfPlayer']).addEventListener('change', playerSelChanged, false);
			playerCityDesc();
		}
		function playerSelChanged (e){
			var t = Tabs.Alliance;
			var id = document.getElementById(UID['tabAlliance_ReinfPlayer']);
			var sel = isEmpty(id.value,'none');
			id.value = sel;
			Data.options.alliance.reinforce_id = sel;
			playerCityDesc();
		}
		function playerCityDesc (){
			var t = Tabs.Alliance;
			var found = false;
			for (var cityIdx=1; cityIdx < Seed.cities.length && !found; cityIdx++) {
				if (Seed.cities[cityIdx] && Data.options.alliance.reinforce_id == Seed.cities[cityIdx].id) {
					found = true;
					document.getElementById(UID['tabAlliance_ReinfTarget']).innerHTML = '<B>' + translate(Seed.cities[cityIdx].name) + '</b>' +
						' &nbsp; ('+Seed.cities[cityIdx].x + ', '+Seed.cities[cityIdx].y +
						') &nbsp; <B>' + translate('Distance') + ': </b>' + 
						getDistance(Seed.cities[CAPITAL_ID].x, Seed.cities[CAPITAL_ID].y, Seed.cities[cityIdx].x, Seed.cities[cityIdx].y);
				}
			}
			if (!found) {
				for (var i=0; i<Data.dynamic.players.memberships.length && !found; i++){
					if (Data.dynamic.players.memberships[i].id == Data.options.alliance.reinforce_id){
						found = true;
						document.getElementById(UID['tabAlliance_ReinfTarget']).innerHTML = translate('City') + ' &nbsp; <B>' + Data.dynamic.players.memberships[i].city + '</b>' +
							' &nbsp; ('+Data.dynamic.players.memberships[i].x + ', '+Data.dynamic.players.memberships[i].y +
							') &nbsp; <B>' + translate('Distance') + ': </b>' + Data.dynamic.players.memberships[i].dist;
					}
				}
			}
		}
	},

	displayTotal : function (){
		var t = Tabs.Alliance;
		t.totalResources = 0;
		t.maxResources = 0;
		for (var r=0; r<transportable_resource_types.length; r++)
			t.totalResources = parseIntZero(t.totalResources) + parseIntZero(Data.options.alliance.data.resources[transportable_resource_types[r]]);
		for (var i=0; i<transport_unit_types.length; i++){
			if (Names.troops.byAbbr[transport_unit_types[i]][1] == 'Porter') var load = 200;
			else if (Names.troops.byAbbr[transport_unit_types[i]][1] == 'ArmoredTransport') var load = 5000;
			else if (Names.troops.byAbbr[transport_unit_types[i]][1] == 'PackDragon') var load = 6000;
			else var load = 0;
			var qty  = Data.options.alliance.data.transports[Names.troops.byAbbr[transport_unit_types[i]][1]];
			try {
				var load = Seed.stats.unit[Names.troops.byAbbr[transport_unit_types[i]][1]].load;
			}
			catch(e){
				actionLog('<B>' + translate('Troops load: ') + '</B>' + e.msg + ' ' + translate('Manifest not available, using defaults'));
			}
			t.maxResources = t.maxResources + (parseIntZero(qty) * parseIntZero(load));
		}
		var avail = nombreFormate(parseIntZero(t.maxResources) - parseIntZero(t.totalResources),' ');
		document.getElementById(UID['tabAlliance_Total']).innerHTML = '<B>' + nombreFormate(parseIntZero(t.totalResources),' ') + '</B> / <B>' +
		nombreFormate(parseIntZero(t.maxResources),' ') + '</B> (<B>' + avail + '</B> disponible)';
	},
}
// Jawz *********************************** Alliance features Tab ****************************************


// Jawz *********************************** Map search Tab *********************************************
Tabs.Search = {
	tabOrder		: SEARCH_TAB_ORDER,
	tabLabel		: 'Map',
	tabDisabled		: !SEARCH_TAB_ENABLE,
	container		: null,
	checkMapBusy	: false,
	MAX_DISTANCE	: 75,
	contentType		: 0, // 0 = cities list, 1 = Wildernesses list
	lastSubTab    	: 'tabSearchC',

	init : function (div){
		var t = Tabs.Search;

		Data.setDefaultValues ('search');

		t.container = div;
		var m = '<div class=' + UID['title'] + '>'+ translate('Map Search') +'</div>'
			+'<div class=' + UID['content'] + '>'
			+'	<div>'
			+'		<b>'+ translate('Search coords') +':&nbsp;</b>&nbsp;'
			+'		X: <input id=' + setUID('tabSearch_CoordsX') + ' size=2 maxlength=3 type=text value="'+ Data.options.search.target.x +'" /> '
			+'		Y: <input id=' + setUID('tabSearch_CoordsY') + ' size=2 maxlength=3 type=text value="'+ Data.options.search.target.y +'" /> '
			+'		&nbsp <b>'+ translate('Search max radius') +':</b><input id=' + setUID('tabSearch_Dist') + ' type=text size=2 maxlength=3 style="width:25px" value="'+ Data.options.search.target.distance +'" />'
			+'		<input id=' + setUID('tabSearch_Refresh') + ' type=button value="' + translate('Refresh map data') + '" /><BR>'
			+'		<div class=' + UID['status_ticker'] + ' style="height:auto !important;margin:5px 10px !important;">'
			+'			<center><span id=' + setUID('tabSearch_Tile') + '></span></center>'
			+'		</div>'
			+'	</div>'
			+'	<br>'
			+'	<table class=' + UID['table'] + '>'
			+'		<tr><td class=left>' + translate('Alliance') + ':</td>'
			+'			<td><div id=' + setUID('tabSearch_Alliance') + '></div></td>'
			+'			<td><input id=' + setUID('tabSearch_NewList') + ' type=button value="' + translate('Refresh') + '" /></td>'
			+'		</tr>'
			+'		<tr><td class=left>' + translate('Player name') + ':</td>'
			+'			<td><div id=' + setUID('tabSearch_Players') + '></div></td>'
			+'		</tr>'
			+'	</table>'
			+'</div>'
			+'<ul class=tabs>'
			+'	<li class="tab first"><a id='+ setUID('tabSearchC') +'>'+ translate('Player cities') +'</a></li>'
			+'	<li class=tab><a id='+ setUID('tabSearchW') +'>'+ translate('Wildernesses') +'</a></li>'
			+'</ul>'
			+'<div id='+ setUID('tabSearch_Content') +' style="padding-top:none; height:575px; ; max-height:575px; overflow-x:auto; overflow-y:auto"></div>';

		t.container.innerHTML = m;
		document.getElementById(UID['tabSearch_CoordsX']).addEventListener ('change', t.eventCoords, false);
		document.getElementById(UID['tabSearch_CoordsY']).addEventListener ('change', t.eventCoords, false);
		document.getElementById(UID['tabSearch_Dist']).addEventListener ('change', t.eventDist, false);
		document.getElementById(UID['tabSearch_Refresh']).addEventListener ('click', t.refreshMapData, false);
		document.getElementById(UID['tabSearch_Alliance']).addEventListener ('change', t.eventAlliance, false);
		document.getElementById(UID['tabSearch_Players']).addEventListener ('change', t.eventPlayer, false);
		document.getElementById(UID['tabSearch_NewList']).addEventListener ('click', t.show, false);
		document.getElementById(UID['tabSearchC']).addEventListener ('click', t.tabSearchC, false);	
		document.getElementById(UID['tabSearchW']).addEventListener ('click', t.tabSearchW, false);	
		t.eventCoords();
		t.eventDist();
		t.contentType = isEmpty(Data.options.search.current_tab,0);
		t.show();
	},

	hide : function (){
	},

	show : function (){
		var t = Tabs.Search;
		if (!t.checkMapBusy) {
			t.displayAllianceList();
			t.displayPlayersList();
			switch (isEmpty(t.contentType, 0)) {
				case 0: t.tabSearchC(); break;
				case 1: t.tabSearchW(); break;
			}
		} else setTimeout(t.show, 100);
	},

	onUnload : function () {
		var t = Tabs.Search;
		Data.options.search.current_tab = t.contentType;
	},

	eventCoords : function (e){
		var ex = document.getElementById(UID['tabSearch_CoordsX']);
		var ey = document.getElementById(UID['tabSearch_CoordsY']);
		var x = parseIntZero (ex.value);
		var y = parseIntZero (ey.value);
		ex.value = x;
		ey.value = y;
		document.getElementById(UID['tabSearch_Tile']).innerHTML = '&nbsp;';
		if (x < 0 || x > 749){
			if(x < 0){
				while (x < 0){
					x = 750 + x;
				}
			} else {
				while (x > 749){
					x = x - 750;
				}
			}
			ex.style.backgroundColor = 'red';
			return;
		}
		if (y < 0 || y > 749){
			if(y < 0){
				while (y < 0){
					y = 750 + y;
				}
			} else {
				while (y > 749){
					y = y - 750;
				}
			}
			ey.style.backgroundColor = 'red';
			return;
		}
		Data.options.search.target.x = x;
		Data.options.search.target.y = y;
		ey.style.backgroundColor = '';
		ex.style.backgroundColor = '';
		Map.getTargetByCoords(x, y, function(target){
			if (target){
				var cfeedBack = ''; // Jawz
				Data.options.search.target.level = target.lvl;

				var attColor = target.isAtt ? '#000' : '#C22';

				// Jawz
				var type = target.type.substr(0,1).toUpperCase();
				if ((type == "H") || (type == "G") || (type == "L") || (type == "M") || (type == "N") || (type == "F") || (type == "S") || (type == "P")) type = 'W';
				// End Jawz

				var tile = '<font color='+attColor+'>'
					+'<b>'+ translate(target.type) +'&nbsp;'+ translate('Level') +'&nbsp;'+ target.lvl +'</b>'
					+'</font>';
				if(target.pName != undefined && type != 'W'){
					tile += '<br>'+ translate('City') + ': <b>' + target.name +'</b> - '
						+ translate('Alliance')+': <b>'+(target.pAlli != undefined ? target.pAlli : '----') + '</b>'
						+ '<br>'+ translate('Name') +': <b>'+ target.pName + '</b> - '
						+ translate('Level') + ': <b>' + target.pLvl + '</b> - '
						+ translate('Might') + ': <b>' + target.pMight + '</b>';
					cFeedBack = translate(target.type) + ' ' + target.pName + ' (' + nombreFormate(target.pMight) + ')' + (target.pAlli != undefined ? ' / '+target.pAlli : '');
				} else {  // JAwz
					cFeedBack = translate(target.type) + ' ' + translate('Level') + ' ' + target.lvl;
				}
				Data.options.search.target.type = cFeedBack;
				document.getElementById(UID['tabSearch_Tile']).innerHTML = tile;
			}
		});
	},

	eventDist : function (e){
		var ed = document.getElementById(UID['tabSearch_Dist']);
		var dist = ed.value;
		if (dist==null || dist<0 || dist>75){
			ed.style.backgroundColor = 'red';
			return;
		}
		Data.options.search.target.distance = dist;
		ed.style.backgroundColor = '';
	},

	eventAlliance : function (e){
		var t = Tabs.Search;
		var ea = document.getElementById(UID['tabSearch_SelAlliance']);
		var alli = ea.value;
		Data.options.search.target.alliance = alli;
		if (alli==null){
			ea.style.backgroundColor = 'red';
			return;
		}
		ea.style.backgroundColor = '';
		t.displayPlayersList ();
		t.show ();
	},

	eventPlayer : function (e){
		var t = Tabs.Search;
		var ea = document.getElementById(UID['tabSearch_SelPlayer']);
		var plyr = ea.value;
		Data.options.search.target.player = plyr;
		if (plyr==null){
			ea.style.backgroundColor = 'red';
			return;
		}
		ea.style.backgroundColor = '';
		t.show ();
	},

	displayAllianceList : function (){
		var t = Tabs.Search;
		var list = t.getAllianceList();
		var m = '<select id=' + setUID('tabSearch_SelAlliance') + '>'
			+'<option value="*" '+ ((Data.options.search.target.alliance == '*') ? 'selected' : '') + '>' + translate('All alliances') + '</option>';
		for (var i=0; i<list.length; i++){
			var selected = '';
			if (list[i] == Data.options.search.target.alliance) selected = 'selected'
			m += '<option value="' + list[i] + '" '+selected+'>' + list[i] + '</option>';
		}
		m += '</select>';
		document.getElementById(UID['tabSearch_Alliance']).innerHTML = m;
		t.displayPlayersList ();
	},

	displayPlayersList : function (){
		var t = Tabs.Search;
		var list = t.getPlayersList();
		var m = '<select id=' + setUID('tabSearch_SelPlayer') + '>'
			+'<option value="*" '+ ((Data.options.search.target.player == '*') ? 'selected' : '') + '>' + translate('All players') + '</option>';
		for (var i=0; i<list.length; i++){
			var selected = '';
			if (list[i] == Data.options.search.target.player) selected = 'selected'
			m += '<option value="' + list[i] + '" '+selected+'>' + list[i] + '</option>';
		}
		m += '</select>';
		document.getElementById(UID['tabSearch_Players']).innerHTML = m;
	},

	// return array of different alliances found
	getAllianceList : function (){
		var t = Tabs.Search;
		var ret = [];
		var existe = false;
		for (var i=0; i<Data.dynamic.playercities.cities.length; i++){
			existe = false;
			for (var j=0; j<ret.length; j++){
				if (Data.dynamic.playercities.cities[i].alliance == ret[j])
				existe = true;
			}
			if (!existe)
				ret.push (Data.dynamic.playercities.cities[i].alliance);
		}
		function charOrdA(a, b){
			a = a.toLowerCase(); b = b.toLowerCase();
			if (a>b) return 1;
			if (a <b) return -1;
			return 0;
		}
		ret.sort(charOrdA);
		return ret;
	},

	// return array of different alliances found
	getPlayersList : function (){
		var t = Tabs.Search;
		var ret = [];
		var existe = false;
		for (var i=0; i<Data.dynamic.playercities.cities.length; i++){
			existe = false;
			for (var j=0; j<ret.length && !existe; j++){
				if (Data.dynamic.playercities.cities[i].name == ret[j])
					existe = true;
			}
			if ((!existe)  &&
				( (	Data.options.search.target.alliance == "*") ||
				  ((Data.options.search.target.alliance != "*") &&
				  ((Data.dynamic.playercities.cities[i].alliance == Data.options.search.target.alliance) ||
				   (Data.dynamic.playercities.cities[i].alliance == " " && Data.options.search.target.alliance == null)))
				))
				ret.push (Data.dynamic.playercities.cities[i].name);
		}
		function charOrdA(a, b){
			a = a.toLowerCase(); b = b.toLowerCase();
			if (a>b) return 1;
			if (a <b) return -1;
			return 0;
		}
		ret.sort(charOrdA);
		return ret;
	},

	// return array of cities that satisfy config (max distance, alliance name)
	getCityList : function (){
		var t = Tabs.Search;
		var ret = [];
		for (var i=0; i<Data.dynamic.playercities.cities.length; i++){
			var city = Data.dynamic.playercities.cities[i];
			var type = city.type.substr(0,1).toUpperCase();
			if ((type != "A") && (type != "H") && (type != "G") && (type != "L") && (type != "M") && (type != "N") && (type != "F") && (type != "P") && (type != "S")){
				if (((city.alliance == Data.options.search.target.alliance || Data.options.search.target.alliance == "*") ||
					 (city.alliance == " " && Data.options.search.target.alliance == null)) &&
					 (city.name == Data.options.search.target.player || Data.options.search.target.player == "*"))
				ret.push (city);
			}
		}
		return ret;
	},

	// return array of cities that satisfy config (max distance, alliance name)
	getWildernessesList : function (){
		var t = Tabs.Search;
		var ret = [];
		for (var i=0; i<Data.dynamic.playercities.cities.length; i++){
			var wild = Data.dynamic.playercities.cities[i];
			var type = wild.type.substr(0,1).toUpperCase();
			if ((type == "H") || (type == "G") || (type == "L") || (type == "M") || (type == "N") || (type == "F") || (type == "S") || (type == "P")){
				if ( (	(type == "H" && Data.options.search.hill) ||
						(type == "G" && Data.options.search.grassland) ||
						(type == "L" && Data.options.search.lake) ||
						(type == "M" && Data.options.search.mountain) ||
						(type == "F" && Data.options.search.forest) ||
						(type == "N" && Data.options.search.nuage) ||
						(type == "S" && Data.options.search.swamp) ||
						(type == "P" && Data.options.search.plain)) &&
					(	(parseInt(wild.lvl) >= parseInt(Data.options.search.min_level)) &&
						(parseInt(wild.lvl) <= parseInt(Data.options.search.max_level ))) &&
					(	(wild.name == '' && Data.options.search.unowned) || (!Data.options.search.unowned)) &&
					(	(wild.alliance == Data.options.search.target.alliance || Data.options.search.target.alliance == "*") ||
						(wild.alliance == " " && Data.options.search.target.alliance == null))  &&
						(wild.name == Data.options.search.target.player || Data.options.search.target.player == "*")
					)
					ret.push (wild);
			}
		}
		return ret;
	},

	//** CITY PLAYER SUB-TAB ***
	tabSearchC : function (){
		var t = Tabs.Search;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabSearchC']).className='selected';
		document.getElementById(UID['tabSearchC']).style.zIndex=1;
		t.lastSubTab = 'tabSearchC';
		t.contentType = 0;
		if (Data.dynamic.playercities.last_update && Data.dynamic.playercities.last_update != null && Data.dynamic.playercities.last_update != undefined) kLastupdate = ' ('+Data.dynamic.playercities.last_update+')';
		else kLastupdate = '';
		var m = '<div id=' + setUID('tabSearch_Results') + ' style="height:550px">'
			+'	<div class=' + UID['title'] + '>' + translate('Player cities list') + kLastupdate + '</div>'
			+'	<div id=' + setUID('tabSearch_ResultList') + ' class=' + UID['status_ticker']
			+'	 style="height:525px; max-height:525px; width:540px; max-width:540px; overflow-y:auto ; overflow-x:auto ; margin-top:1px !important"></div>'
			+'	</div>';
		document.getElementById(UID['tabSearch_Content']).innerHTML = m;

		var m = '<table class=' + UID['table'] + ' width=100%>'
			+'	<tr class=' + UID['row_headers'] +'>'
			+'		<td id=' + setUID('tabSearch_tsc_0') + ' width="20px"><A><span>' + translate('Dist') + '</span></A></td>'
			+'		<td id=' + setUID('tabSearch_tsc_1') + ' width="40px"><A><span>' + translate('Coords') + '</span></A></td>';
		if (Data.options.search.target.alliance == "*")
			m += '	<td id=' + setUID('tabSearch_tsc_2') + '><A><span>' + translate('Alliance') + '</span></A></td>';

		m += '		<td id=' + setUID('tabSearch_tsc_3') + ' width="200px" style="overflow-x:auto"><A><span>' + translate('Player name') + '</span></A></td>'
			+'		<td id=' + setUID('tabSearch_tsc_4') + ' width="40px" align=right><A><span>' + translate('Might') + '</span></A></td>'
			+'		<td width="40px" align=right>' + translate('Evol') + '</td>'
			+'		<td id=' + setUID('tabSearch_tsc_5') + '><A><span>' + translate('Type') + '</span></A></td>'
			+'		<td style="background:none"></td>'
			+'	</tr>';

		var cities = t.getCityList();
		for (var i=0; i<cities.length; i++){
			m += '<tr><td>'+ cities[i].dist +'</td><td align=center>'+ cities[i].x +','+ cities[i].y +'</td>';
			if (Data.options.search.target.alliance == "*")
				m += '<td align=left>'+ cities[i].alliance +'</td>';
			var mightF = nombreFormate(cities[i].might,' ');
			var found = false;
			var evol = 'x';
			for (var old=0; old<Data.dynamic.players.evolution.length && !found; old++){
				if (Data.dynamic.players.evolution[old].name == cities[i].name){
					evol = cities[i].might - Data.dynamic.players.evolution[old].might;
					if (evol < 0) evol = '<span class=' + UID['red'] + '>'+nombreFormate(evol,' ')+'</span>';
					else if (evol > 0) evol = '<span class=' + UID['green'] + '>+'+nombreFormate(evol,' ')+'</span>';
					else evol = nombreFormate(evol,' ');
					found = true;
				}
			}
			m += '<td align=left>'+ cities[i].name +'</td>'
				+'<td align=right>'+ mightF +'</td>'
				+'<td align=right>'+ evol +'</td>'
				+'<td align=center>'+ ((cities[i].type == 'Outpost') ? translate(cities[i].otype) : cities[i].type) +'</td>'
				+'<td><input id='+ setUID('tabSearch_Spy_'+i) +' ref='+ i +' class=Xtrasmall style="width:auto !important;" type=submit value="' + translate('Spy') + '" /></td>'
				+'</tr>';
		}
		document.getElementById(UID['tabSearch_ResultList']).innerHTML = m + '</table>';

		for (var h=0; h<6; h++)
			if ((h != 2) || (Data.options.search.target.alliance == "*" && h == 2))
				document.getElementById(UID['tabSearch_tsc_' + h]).addEventListener ('click', sortCityList, false);

		var own_alliance = (Seed.player.alliance) ? Seed.player.alliance.name : '';
		for (var i=0; i<cities.length; i++){
			var butSpy = document.getElementById(UID['tabSearch_Spy_'+ i]);
			butSpy.addEventListener ('click', butSpyNow, false);
			if ( (((cities[i].type == 'Outpost') && (cities[i].otype != 'Spectral')) || (cities[i].type != 'Outpost')) &&
				 ((cities[i].alliance == null) || (cities[i].alliance != own_alliance))){
				butSpy.disabled = false;
				Element.removeClassName(butSpy, UID['bnt_disabled']);
				Element.addClassName(butSpy, UID['bnt_green']);
			} else {
				butSpy.disabled = true;
				Element.removeClassName(butSpy, UID['bnt_green']);
				Element.addClassName(butSpy, UID['bnt_disabled']);
			}
		}
		function butSpyNow (e){
			var n = parseInt(e.target.getAttribute('ref'));
			var dial = new ModalDialog (t.container, 300, 150, '', false);
			dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
			dial.getContentDiv().innerHTML = translate('Spying');
			checkSpy (cities[n], notify);
			function notify (rslt){
				if (rslt!='OK'){
					dial.getContentDiv().innerHTML = '<b>'+ rslt +'</b>';
					dial.allowClose (true);
				} else {
					dial.getContentDiv().innerHTML = '<b>'+ translate('OK') +'</b>';
					setTimeout (function(){dial.destroy()}, 1000);
				}
			}
		}
		function checkSpy (targetObj, notify){
			var t = Tabs.Search;
			var cityId = Seed.cities[CAPITAL_ID].id;
			var cityIdx = CAPITAL_ID;

			// check troops
			var units = [];
			units['Spy'] = 1;
			var totalTroops = 0;
			for (var p in units){
				if (units[p] > 0){
					totalTroops += units[p];
					if (Seed.cities[cityIdx].units[p] < units[p]){
						notify (translate('Not enough') +' '+ translate(p));
						return;
					}
				}
			}

			if (totalTroops <= 0){
				notify (translate('No Troops Defined'));
				return;
			}

			// TODO: 'too many troops for muster point level'
			var authMaxTroops = getMusterPointMaxTroops (cityIdx);
			for (var p in units) {
				if (units[p] > 0) {
					if (units[p] > authMaxTroops) {
						notify (translate('Too many troops for muster point level'));
						return;
					}
				}
			}

			if (totalTroops > authMaxTroops) {
				notify (translate('Too many troops for muster point level'));
				return;
			}
		
			if (getMusterPointSlots (cityIdx) <= 0){
				notify (translate('Muster Point Full'));
				return;
			}

			var targMsg =  '<B>' + translate('Manual spy sent to') + '</B>: ' + targetObj.name + ' ' +  translate('at') + ' ' + targetObj.x +'/'+ targetObj.y;

			verboseLog(targMsg +' '+ translate('Attempted'));

			new MyAjax.marchSpy (cityId, targetObj.x, targetObj.y, units, 'attacks', function (rslt){
				if (rslt.ok && rslt.dat.result.success){
					Marches.add(rslt.dat.result.job.march_id, 'attacks');
					verboseLog(targMsg +' '+ translate('Successfully'));
					actionLog(targMsg);
					notify ('OK');
				} else {
					verboseLog(targMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg);
					t.dispFeedback (translate('Error') + ': ' + rslt.errmsg);
					if (notify){
						notify(false);
					}
				}
			});
		}
		function sortCityList (e){
			var t = Tabs.Search;
			var arg = e.target.parentNode.parentNode.id;
			if (arg == UID['tabSearch_tsc_0']){
				if (Data.options.search.sort_list == '0'){
					Data.dynamic.playercities.cities.sort(function(a,b){return b.dist-a.dist});
					Data.options.search.sort_list = '-0';
				} else {
					Data.dynamic.playercities.cities.sort(function(a,b){return a.dist-b.dist});
					Data.options.search.sort_list = '0';
				}
			} else if (arg == UID['tabSearch_tsc_1']){
				if (Data.options.search.sort_list == '1'){
					Data.dynamic.playercities.cities.sort(function(a,b){return b.x-a.x});
					Data.options.search.sort_list = '-1';
				} else {
					Data.dynamic.playercities.cities.sort(function(a,b){return a.x-b.x});
					Data.options.search.sort_list = '1';
				}
			} else if (arg == UID['tabSearch_tsc_2']){
				if (Data.options.search.sort_list == '2'){
					Data.dynamic.playercities.cities.sort(function(a, b){a = a.alliance.toLowerCase(); b = b.alliance.toLowerCase(); if (a>b) return -1; if (a <b) return 1; return 0;});
					Data.options.search.sort_list = '-2';
				} else {
					Data.dynamic.playercities.cities.sort(function(a, b){a = a.alliance.toLowerCase(); b = b.alliance.toLowerCase(); if (a>b) return 1; if (a <b) return -1; return 0;});
					Data.options.search.sort_list = '2';
				}
			} else if (arg == UID['tabSearch_tsc_3']){
				if (Data.options.search.sort_list == '3'){
					Data.dynamic.playercities.cities.sort(function(a, b){a = a.name.toLowerCase(); b = b.name.toLowerCase(); if (a>b) return -1; if (a <b) return 1; return 0;});
					Data.options.search.sort_list = '-3';
				} else {
					Data.dynamic.playercities.cities.sort(function(a, b){a = a.name.toLowerCase(); b = b.name.toLowerCase(); if (a>b) return 1; if (a <b) return -1; return 0;});
					Data.options.search.sort_list = '3';
				}
			} else if (arg == UID['tabSearch_tsc_4']){
				if (Data.options.search.sort_list == '4'){
					Data.dynamic.playercities.cities.sort(function(a,b){return b.might-a.might});
					Data.options.search.sort_list = '-4';
				} else {
					Data.dynamic.playercities.cities.sort(function(a,b){return a.might-b.might});
					Data.options.search.sort_list = '4';
				}
			} else if (arg == UID['tabSearch_tsc_5']){
				if (Data.options.search.sort_list == '5'){
					Data.dynamic.playercities.cities.sort(function(a, b){a = a.type.toLowerCase(); b = b.type.toLowerCase(); if (a>b) return -1; if (a <b) return 1; return 0;});
					Data.options.search.sort_list = '-5';
				} else {
					Data.dynamic.playercities.cities.sort(function(a, b){a = a.type.toLowerCase(); b = b.type.toLowerCase(); if (a>b) return 1; if (a <b) return -1; return 0;});
					Data.options.search.sort_list = '5';
				}
			}
			t.tabSearchC();
		}
	},

	//** WILDERNESSES SUB-TAB ***
	tabSearchW : function (){
		var t = Tabs.Search;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabSearchW']).className='selected';
		document.getElementById(UID['tabSearchW']).style.zIndex=1;
		t.lastSubTab = 'tabSearchW';
		t.contentType = 1;

		var m = '<div class=' + UID['content'] + '>'
			+'<table class=' + UID['table'] + ' width=100%>'
			+'	<tr>'
			+'		<td width=3%><input id=' + setUID('tabSearch_WildG') + ' type=checkbox '+ (Data.options.search.grassland?'CHECKED':'') +' /></td>'
			+'		<td width=30%> '+ translate(kGrassland) +'</td>'
			+'		<td width=3%><input id=' + setUID('tabSearch_WildL') + ' type=checkbox '+ (Data.options.search.lake?'CHECKED':'') +' /></td>'
			+'		<td width=30%> '+ translate(kLake) +'</td>'
			+'		<td width=3%><input id=' + setUID('tabSearch_WildP') + ' type=checkbox '+ (Data.options.search.plain?'CHECKED':'') +' /></td>'
			+'		<td width=30%> '+ translate(kPlain) +'</td>'
			+'	</tr><tr>'
			+'		<td><input id=' + setUID('tabSearch_WildH') + ' type=checkbox '+ (Data.options.search.hill?'CHECKED':'') +' /></td>'
			+'		<td> '+ translate(kHill) +'</td>'
			+'		<td><input id=' + setUID('tabSearch_WildM') + ' type=checkbox '+ (Data.options.search.mountain?'CHECKED':'') +' /></td>'
			+'		<td> '+ translate(kMountain) +'</td>'
			+'		<td><input id=' + setUID('tabSearch_WildF') + ' type=checkbox '+ (Data.options.search.forest?'CHECKED':'') +' /></td>'
			+'		<td> '+ translate(kForest) +'</td>'
			+'	</tr><tr>'
			+'		<td><input id=' + setUID('tabSearch_WildN') + ' type=checkbox '+ (Data.options.search.nuage?'CHECKED':'') +' /></td>'
			+'		<td> '+ translate(kFog) +'</td>'
			+'		<td><input id=' + setUID('tabSearch_WildS') + ' type=checkbox '+ (Data.options.search.swamp?'CHECKED':'') +' /></td>'
			+'		<td> '+ translate(kSwamp) +'</td>'
			+'	</tr>'
			+'</table>'
			+'<table class=' + UID['table'] + ' width=100%>'
			+'	<tr>'
			+'		<td width=33%>' + translate('Min level') + ': ' + levelSelect('Min', isEmpty(Data.options.search.min_level,'1') ) + '</td>'
			+'		<td width=33%>' + translate('Max level') + ': ' + levelSelect('Max', isEmpty(Data.options.search.max_level,'10') ) + '</td>'
			+'		<td width=3%><input id=' + setUID('tabSearch_Unowned') + ' type=checkbox '+ (Data.options.search.unowned?'CHECKED':'') +' /></td>'
			+'		<td width=30%> '+ translate('Unowned only') +'</td>'
			+'	</tr>'
			+'</table>'
			+'</div>'
			+'<div id=' + setUID('tabSearch_Wilds') + ' style="height:470px">'
			+'	<div class=' + UID['title'] + '>' + translate('Wildernesses list') + '</div>'
			+'	<div id=' + setUID('tabSearch_WildList') + ' class=' + UID['status_ticker']
			+'	 style="height:450px; max-height:450px; width:540px; max-height:540px; overflow-y:auto ; overflow-x:auto ; margin-top:1px !important"></div>'
 			+'	</div>';
		document.getElementById(UID['tabSearch_Content']).innerHTML = m;
		document.getElementById(UID['tabSearch_WildG']).addEventListener ('click', eventWildFlag, false);
		document.getElementById(UID['tabSearch_WildL']).addEventListener ('click', eventWildFlag, false);
		document.getElementById(UID['tabSearch_WildP']).addEventListener ('click', eventWildFlag, false);
		document.getElementById(UID['tabSearch_WildH']).addEventListener ('click', eventWildFlag, false);
		document.getElementById(UID['tabSearch_WildM']).addEventListener ('click', eventWildFlag, false);
		document.getElementById(UID['tabSearch_WildF']).addEventListener ('click', eventWildFlag, false);
		document.getElementById(UID['tabSearch_WildN']).addEventListener ('click', eventWildFlag, false);
		document.getElementById(UID['tabSearch_WildS']).addEventListener ('click', eventWildFlag, false);
		document.getElementById(UID['tabSearch_LvMin']).addEventListener ('change', levelChanged, false);
		document.getElementById(UID['tabSearch_LvMax']).addEventListener ('change', levelChanged, false);
		document.getElementById(UID['tabSearch_Unowned']).addEventListener ('click', eventWildFlag, false);
		displayWildResults();

		function levelChanged (evt){
			var t = Tabs.Search;
			var id = evt.target.id;
			var x = parseIntZero(evt.target.value);
			if (isNaN(x) || x<1 || x>10){
				evt.target.style.backgroundColor = 'red';
			} else {
				if (id == UID['tabSearch_LvMin']) Data.options.search.min_level = x;
				else Data.options.search.max_level = x;
				evt.target.value = x;
				var min = Data.options.search.min_level;
				var max = Data.options.search.max_level;
				if (min>max)
					evt.target.style.backgroundColor = 'red';
				else {
					evt.target.style.backgroundColor = '';
					displayWildResults();
				}
			}
		}

		function levelSelect (MinMax, curVal){
			var newUID = setUID('tabSearch_Lv' + MinMax);
			var m = '<select id="' + newUID + '">';
			for (var k=1; k<=10; k++)
				m += '<option value="' + k + '" ' + (curVal==k?'selected':'') + '>' + k + '</option>';
			m += '</select>';
			return m;
		}

		function eventWildFlag (){
			var t = Tabs.Search;
			var cG = document.getElementById(UID['tabSearch_WildG']);
			var cL = document.getElementById(UID['tabSearch_WildL']);
			var cP = document.getElementById(UID['tabSearch_WildP']);
			var cH = document.getElementById(UID['tabSearch_WildH']);
			var cM = document.getElementById(UID['tabSearch_WildM']);
			var cF = document.getElementById(UID['tabSearch_WildF']);
			var cN = document.getElementById(UID['tabSearch_WildN']);
			var cS = document.getElementById(UID['tabSearch_WildS']);
			var cU = document.getElementById(UID['tabSearch_Unowned']);
			Data.options.search.grassland = cG.checked;
			Data.options.search.lake = cL.checked;
			Data.options.search.plain = cP.checked;
			Data.options.search.hill = cH.checked;
			Data.options.search.mountain = cM.checked;
			Data.options.search.forest = cF.checked;
			Data.options.search.nuage = cN.checked;
			Data.options.search.swamp = cS.checked;
			Data.options.search.unowned = cU.checked;
			displayWildResults();
		}

		function displayWildResults (){
			var t = Tabs.Search;
			var m = '<table class=' + UID['table'] + ' id=' + setUID('tabSearch_WildTab') + ' width=100%>'
			+'	<tr class=' + UID['row_headers'] +'>'
			+'		<td id=' + setUID('tabSearch_tsw_0') + ' width="20px"><A><span>' + translate('Dist') + '</span></A></td>'
			+'		<td id=' + setUID('tabSearch_tsw_1') + ' width="40px"><A><span>' + translate('Coords') + '</span></A></td>'
			+'		<td id=' + setUID('tabSearch_tsw_5') + ' width="60px"><A><span>' + translate('Type') + '</span></A></td>'
			+'		<td id=' + setUID('tabSearch_tsw_6') + ' width="20px"><A><span>' + translate('Level') + '</span></A></td>'
			+'		<td id=' + setUID('tabSearch_tsw_3') + ' width="200px" style="overflow-x:auto"><A><span>' + translate('Owner') + '</span></A></td>'
			+'		<td id=' + setUID('tabSearch_tsw_4') + ' width="40px" align=right><A><span>' + translate('Might') + '</span></A></td>'
			+'		<td id=' + setUID('tabSearch_tsw_2') + '><A><span>' + translate('Alliance') + '</span></A></td>'
			+'		<td style="background:none"></td>'
			+'	</tr>';
			var wilds = t.getWildernessesList();
			for (var i=0; i<wilds.length; i++){
				var mightF = null;
				if (wilds[i].might != null)
					mightF = nombreFormate(wilds[i].might,' ');
				m += '<tr><td>'+ wilds[i].dist +'</td>'
					+'	<td align=center>'+ wilds[i].x +','+ wilds[i].y +'</td>'
					+'	<td align=left>'+ translate(wilds[i].type) +'</td>'
					+'	<td align=right>'+ wilds[i].lvl +'</td>'
					+'	<td align=left>'+ wilds[i].name +'</td>'
					+'	<td align=right>'+ mightF +'</td>'
					+'	<td align=left>'+ wilds[i].alliance +'</td>'
					+'	<td><input id='+ setUID('tabSearch_Att_'+i) +' ref='+ i +' class=Xtrasmall style="width:auto !important;" type=submit value="' + translate('Attack') + '" /></td>'
					+'</tr>';
			}
			document.getElementById(UID['tabSearch_WildList']).innerHTML = m + '</table>';
			for (var h=0; h<7; h++)
				document.getElementById(UID['tabSearch_tsw_' + h]).addEventListener ('click', sortWildList, false);

			var own_alliance = (Seed.player.alliance) ? Seed.player.alliance.name : '';
			for (var i=0; i<wilds.length; i++){
				var butAttack = document.getElementById(UID['tabSearch_Att_'+ i]);
				butAttack.addEventListener ('click', butAttackNow, false);
				if ((wilds[i].alliance == null) || (wilds[i].alliance != own_alliance)) {
					butAttack.disabled = false;
					Element.removeClassName(butAttack, UID['bnt_disabled']);
					Element.addClassName(butAttack, UID['bnt_green']);    
				} else {
					butAttack.disabled = true;
					Element.removeClassName(butAttack, UID['bnt_green']);
					Element.addClassName(butAttack, UID['bnt_disabled']);
				}
			}

			function butAttackNow (e){
				var n = parseInt(e.target.getAttribute('ref'));
				var dial = new ModalDialog (t.container, 300, 150, '', false);
				dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
				dial.getContentDiv().innerHTML = translate('Attacking');
				checkAttack (wilds[n], notify);
				function notify (rslt){
					if (rslt!='OK'){
						dial.getContentDiv().innerHTML = '<b>'+ rslt +'</b>';
						dial.allowClose (true);
					} else {
						dial.getContentDiv().innerHTML = '<B>' + translate('OK') + '</b>';
						setTimeout (function(){dial.destroy()}, 1000);
					}
				}
			}

			function checkAttack (targetObj, notify){
				var t = Tabs.Search;
				var cityId = Seed.cities[CAPITAL_ID].id;
				var cityIdx = CAPITAL_ID;
				var availableGeneral = null;

				// check troops
				var units = [];
				units['Spy'] = 1;
				var totalTroops = 0;
				for (var p in units){
					if (units[p] > 0){
						totalTroops += units[p];
						if (Seed.cities[cityIdx].units[p] < units[p]){
							notify (translate('Not enough') +' '+ translate(p));
							return;
						}
					}
				}

				if (totalTroops <= 0){
					notify (translate('No Troops Defined'));
					return;
				}

				var authMaxTroops = getMusterPointMaxTroops (cityIdx);
				for (var p in units) {
					if (units[p] > 0) {
						if (units[p] > authMaxTroops) {
							notify (translate('Too many troops for muster point level'));
							return;
						}
					}
				}

				if (totalTroops > authMaxTroops) {
					notify (translate('Too many troops for muster point level'));
					return;
				}

				if (getMusterPointSlots (cityIdx) <= 0){
					notify (translate('Muster Point Full'));
					return;
				}

				availableGeneral = getAvailableGeneral ();
				if (availableGeneral == null){
					notify (translate('No generals available'));
					return;
				}

				var targMsg =  '<B>' + translate('Manual attack sent to') + '</B>: ' + targetObj.name + ' ' +  translate('at') + ' ' + targetObj.x +'/'+ targetObj.y;

				verboseLog(targMsg +' '+ translate('Attempted'));

				new MyAjax.marchSend (cityId, targetObj.x, targetObj.y, availableGeneral.id, units, 'attacks', function (rslt){
					if (rslt.ok && rslt.dat.result.success){
						Marches.add(rslt.dat.result.job.march_id, 'attacks');
						verboseLog(targMsg +' '+ translate('Successfully'));
						actionLog(targMsg);
						notify ('OK');
					} else {
						verboseLog(targMsg + ' ' + translate('failed and returned error') + ': ' + rslt.errmsg);
						t.dispFeedback (translate('Error') + ': ' + rslt.errmsg);
						if (notify){
							notify(false);
						}
					}
				});
			}

			function sortWildList (e){
				var t = Tabs.Search;
				var arg = e.target.parentNode.parentNode.id;
				if (arg == UID['tabSearch_tsw_0']){
					if (Data.options.search.sort_list == '0'){
						Data.dynamic.playercities.cities.sort(function(a,b){return b.dist-a.dist});
						Data.options.search.sort_list = '-0';
					} else {
						Data.dynamic.playercities.cities.sort(function(a,b){return a.dist-b.dist});
						Data.options.search.sort_list = '0';
					}
				} else if (arg == UID['tabSearch_tsw_1']){
					if (Data.options.search.sort_list == '1'){
						Data.dynamic.playercities.cities.sort(function(a,b){return b.x-a.x});
						Data.options.search.sort_list = '-1';
					} else {
						Data.dynamic.playercities.cities.sort(function(a,b){return a.x-b.x});
						Data.options.search.sort_list = '1';
					}
				} else if (arg == UID['tabSearch_tsw_2']){
					if (Data.options.search.sort_list == '2'){
						Data.dynamic.playercities.cities.sort(function(a, b){a = a.alliance.toLowerCase(); b = b.alliance.toLowerCase(); if (a>b) return -1; if (a <b) return 1; return 0;});
						Data.options.search.sort_list = '-2';
					} else {
						Data.dynamic.playercities.cities.sort(function(a, b){a = a.alliance.toLowerCase(); b = b.alliance.toLowerCase(); if (a>b) return 1; if (a <b) return -1; return 0;});
						Data.options.search.sort_list = '2';
					}
				} else if (arg == UID['tabSearch_tsw_3']){
					if (Data.options.search.sort_list == '3'){
						Data.dynamic.playercities.cities.sort(function(a, b){a = a.name.toLowerCase(); b = b.name.toLowerCase(); if (a>b) return -1; if (a <b) return 1; return 0;});
						Data.options.search.sort_list = '-3';
					} else {
						Data.dynamic.playercities.cities.sort(function(a, b){a = a.name.toLowerCase(); b = b.name.toLowerCase(); if (a>b) return 1; if (a <b) return -1; return 0;});
						Data.options.search.sort_list = '3';
					}
				} else if (arg == UID['tabSearch_tsw_4']){
					if (Data.options.search.sort_list == '4'){
						Data.dynamic.playercities.cities.sort(function(a,b){return b.might-a.might});
						Data.options.search.sort_list = '-4';
					} else {
						Data.dynamic.playercities.cities.sort(function(a,b){return a.might-b.might});
						Data.options.search.sort_list = '4';
					}
				} else if (arg == UID['tabSearch_tsw_5']){
					if (Data.options.search.sort_list == '5'){
						Data.dynamic.playercities.cities.sort(function(a, b){a = a.type.toLowerCase(); b = b.type.toLowerCase(); if (a>b) return -1; if (a <b) return 1; return 0;});
						Data.options.search.sort_list = '-5';
					} else {
						Data.dynamic.playercities.cities.sort(function(a, b){a = a.type.toLowerCase(); b = b.type.toLowerCase(); if (a>b) return 1; if (a <b) return -1; return 0;});
						Data.options.search.sort_list = '5';
					}
				} else if (arg == UID['tabSearch_tsw_6']){
					if (Data.options.search.sort_list == '6'){
						Data.dynamic.playercities.cities.sort(function(a,b){return b.lvl-a.lvl});
						Data.options.search.sort_list = '-6';
					} else {
						Data.dynamic.playercities.cities.sort(function(a,b){return a.lvl-b.lvl});
						Data.options.search.sort_list = '6';
					}
				}
				displayWildResults();
			}
		}
	},

	refreshMapData : function (){
		var t = Tabs.Search;
		t.checkMapBusy = false;
		t.checkMapData ();
		t.show();
	},

	checkMapData : function (){
		var t = Tabs.Search;
		if (t.checkMapBusy)
			return false;
		t.checkMapBusy = true;
		Data.options.search.target.alliance = '*';
		Data.options.search.target.player = '*';
		t.scanMap(Data.options.search.target.distance, function(){logit('****** Setting checkMapBusy to FALSE'); Tabs.Search.checkMapBusy = false});
		return true;
	},

	scanMap : function (radius, notify){
		var t = Tabs.Search;
		ret = [];
		if (Data.dynamic.playercities.cities){
			for (var i=0; i<Data.dynamic.playercities.cities.length; i++){
				var city = Data.dynamic.playercities.cities[i];
				var type = city.type.substr(0,1).toUpperCase();
				if ((type != "A") && (type != "H") && (type != "G") && (type != "L") && (type != "M") && (type != "N") && (type != "F") && (type != "P") && (type != "S")){
					ret.push ({name:Data.dynamic.playercities.cities[i].name, might:Data.dynamic.playercities.cities[i].might});
				}
			}
		}
		Data.dynamic.players.evolution = cloneProps(ret);
		Data.dynamic.playercities = {radius:0, last_update:'', center:{x:Data.options.search.target.x, y:Data.options.search.target.y}, cities:[]};
		var ix=0; iy=0;
		var x = Data.options.search.target.x;
		var y = Data.options.search.target.y;
		if (radius == null)
			radius = Data.options.search.target.distance;

		var steps = parseInt(Math.pow (parseInt(((radius*2)+14)/15),2));
		progressBar.init (800+Math.randRange(1,50), 100, 300, 150, translate('Message'), 200, true, t.container);
		progressBar.start({ steps:steps, delay:1, byCount:true, title:translate('Scanning map for cities/wildernesses')+'...', stepText:translate('Please wait...') });

		logit('======> scanMapCities (' + x +','+y+', '+radius+', callback, false)');
		t.scanMapCities (x,y, radius, callback, false);
		function callback (dat){
			if (dat==null){
				progressBarPop.getContentDiv().innerHTML = '<B>' + translate('Bummer, there was an error while scanning the map') + '.</B>';
				progressBarPop.allowClose (true);
				if (notify)
					notify (false);
				return;
			}
			for (var i=0; i<dat.tiles.length; i++){
				var tile = dat.tiles[i];
				Data.dynamic.playercities.cities.push ({x:tile.x, y:tile.y, dist:tile.dist, type:tile.type, otype:tile.otype, lvl:tile.lvl, name:tile.name, might:tile.might, alliance:tile.alliance, fromCity:0});
			}
			if (dat.done){
				logit ('*********  Done Scanning Map ... Total targets: '+ Data.dynamic.playercities.cities.length);      
				Data.dynamic.playercities.cities.sort(function(a,b){return a.dist-b.dist});
				Data.dynamic.playercities.radius = radius;
				var now = serverTime();
				Data.dynamic.playercities.last_update = new Date(now * 1000).myString();
				if (notify)
					notify(true);
				progressBarPop.destroy();
			}
		}
	},

	scanMapCities : function (x, y, radius, callback, doDetail){
		var t = Tabs.Search;
		t.centerX	= x;
		t.centerY	= y;
		t.firstX	= Map.normalize (x-radius+7);
		t.firstY	=  Map.normalize (y-radius+7);
		t.curIX		= t.curIY = 0;
		t.widthI	= parseInt(((radius*2)+14)/15); 
		t.radius	= radius;
		t.doDetail	= doDetail;
		t.callback	= callback; 
		t.circ 		= true;

		t.count		= t.count || 0;

		var p = {};
		p['user_id']	= C.attrs.userId;
		p['x'] 			= t.firstX;
		p['y']			= t.firstY;
		p['timestamp']	= parseInt(serverTime());
		p['_session_id'] = C.attrs.sessionId;
		p['dragon_heart'] = C.attrs.dragonHeart;
		p['version']	= map_api_version;  
		new MyAjaxRequest ('map.json', p, t.gotCities, true); // Jawz - Set to true
	},  

	gotCities : function (rslt){
		var t = Tabs.Search;
		var x = rslt.dat.x;
		var ret = {tiles:[]}
		if (!rslt.ok){
			t.callback (null);
			return;
		}
		// Store ES position, type, distance, level, and owner
		for (var i=0; i<rslt.dat.terrain.length; i++){
			for (var ii=0; ii<rslt.dat.terrain[i].length; ii++){
				var tile = rslt.dat.terrain[i][ii];

				var tDist = getDistance (t.centerX, t.centerY, tile[2], tile[3]);
				if (tDist <= t.radius){
					var fullType = tile[0];
					if (fullType == 'Fog' || fullType == "Fog") // F = Forest or Fog
						fullType = 'Nuage';
					if (fullType == 'Bog' || fullType == "Bog") // B = Bog... I prefer Swamp :))
						fullType = 'Swamp';
					var tType = fullType.substr(0,1).toUpperCase();
					if ((tType=='H') || (tType=='G') || (tType=='L') || (tType=='M') || (tType=='N') || (tType=='F') || (tType=='S') || (tType=='P')) {
						var wFound = false;
						for (var w=0; w<rslt.dat.city_wildernesses.length; w++){
							var wx = rslt.dat.city_wildernesses[w].x;
							var wy = rslt.dat.city_wildernesses[w].y;
							if ((wx == tile[2]) && (wy == tile[3])){
								wFound = true;
								var wPlyr = rslt.dat.city_wildernesses[w].player.name;
								var wMight = rslt.dat.city_wildernesses[w].player.might;
								var wAlliance = " ";
								if (rslt.dat.city_wildernesses[w].player.alliance != null)
									wAlliance = rslt.dat.city_wildernesses[w].player.alliance.name;
								var wil = {x:tile[2], y:tile[3], dist:tDist, type:fullType, otype:'', lvl:tile[1], name:wPlyr, might:wMight, alliance:wAlliance};
								ret.tiles.push (wil);
							}
						}
						if (!wFound){
							var terr = {x:tile[2], y:tile[3], dist:tDist, type:fullType, otype:'', lvl:tile[1], name:'', might:'', alliance:' '};
							ret.tiles.push (terr);
						}
					}
					if (tType=='A' && t.doDetail) {
						var tcamp = {x:tile[2], y:tile[3], dist:tDist, type:fullType, otype:'', lvl:tile[1], name:'', might:'', alliance:' '};
						ret.tiles.push (tcamp);
					}
				}
			}
		}

		// Store city details
		for (var j=0; j<rslt.dat.map_cities.length; j++){
			var x = rslt.dat.map_cities[j].x;
			var y = rslt.dat.map_cities[j].y;
			var dist = getDistance (t.centerX, t.centerY, x, y);
			var type = rslt.dat.map_cities[j].type;
			var otype;
			if (type == "Capital")
				type = " ";
			else if (type == "Outpost"){
				var full_otype = rslt.dat.map_cities[j].outpost_type;
				otype = full_otype.substring(0,full_otype.indexOf('DragonOutpost'));
			}
			var levl = rslt.dat.map_cities[j].level;
			var plyr = rslt.dat.map_cities[j].player.name;
			var might = rslt.dat.map_cities[j].player.might;
			var alliance = " ";
			if (rslt.dat.map_cities[j].player.alliance != null)
				alliance = rslt.dat.map_cities[j].player.alliance.name;
			var d = {x:x, y:y, dist:dist, type:type, otype:otype, lvl:levl, name:plyr, might:might, alliance:alliance};
			ret.tiles.push (d);
		}

		progressBar.update ({ step:t.count++ });

		if (++t.curIX >= t.widthI){
			t.curIX = 0;
			if (++t.curIY >= t.widthI){
				ret.done = true;
				t.callback (ret); 
				return;
			}
		}
		ret.done = false;
		t.callback (ret);
		setTimeout (function(){
			var p = {};
			p['user_id']	= C.attrs.userId;
			p['x']			= Map.normalize(t.firstX+(t.curIX*15));
			p['y']			= Map.normalize(t.firstY+(t.curIY*15));
			p['timestamp']	= parseInt(serverTime());
			p['_session_id'] = C.attrs.sessionId;
			p['dragon_heart'] = C.attrs.dragonHeart;
			p['version']	= map_api_version;
			new MyAjaxRequest ('map.json', p, t.gotCities, true); // Jawz - Set to true
		}, MAP_DELAY * Math.floor(Math.random() * (-1) + 2));
	},
};
// Jawz *********************************** Map search Tab *********************************************


// Jawz *********************************** Battle Simulation Tab *********************************************
Tabs.Battle = {
	tabOrder		: BATTLE_TAB_ORDER,
	tabLabel		: 'Battle',
	tabDisabled		: !BATTLE_TAB_ENABLE,
	container		: null,
	lastSubTab 		: 'tabBattleConfig',
	logLine			: '',
	terrainLength	: 500,
	battleStop		: false,
	battleWinner	: 0, // 0 = Attacker, 1 = Defender
	dragList		: ['GreatDragon', 'WaterDragon', 'StoneDragon', 'FireDragon', 'WindDragon'],
	troopList		: [	'Porter', 'Conscript', 'Spy', 'Halberdsman', 'Minotaur', 'Longbowman', 'SwiftStrikeDragon', 'BattleDragon', 'PackDragon', 'ArmoredTransport',
						'Giant', 'FireMirror', 'AquaTroop', 'StoneTroop', 'FireTroop', 'WindTroop', 'GreatDragon', 'WaterDragon', 'StoneDragon', 'FireDragon', 'WindDragon'],
	meleeListByPrior: [	'StoneTroop', 'AquaTroop', 'WindTroop', 'Giant', 'FireMirror', 'GreatDragon', 'WaterDragon', 'StoneDragon', 'FireDragon', 'WindDragon', 'BattleDragon',
						'FireTroop', 'PackDragon', 'ArmoredTransport', 'SwiftStrikeDragon', 'Minotaur', 'Halberdsman', 'Longbowman', 'Conscript', 'Porter', 'Spy'],
	rangeListByPrior: [	'StoneTroop', 'FireTroop', 'AquaTroop', 'WindTroop', 'FireMirror', 'Longbowman', 'GreatDragon', 'WaterDragon', 'StoneDragon', 'FireDragon', 'WindDragon', 
						'Giant', 'BattleDragon', 'PackDragon', 'ArmoredTransport', 'SwiftStrikeDragon', 'Minotaur', 'Halberdsman', 'Conscript', 'Porter', 'Spy'],
	troopDefault	: { Porter            :{meleeDamage:1,     rangeDamage:0,    defense:10,    life:45,     speed:100,  range:0,    x:0, qty:0},
						Conscript         :{meleeDamage:10,    rangeDamage:0,    defense:10,    life:75,     speed:200,  range:0,    x:0, qty:0},
						Spy               :{meleeDamage:5,     rangeDamage:0,    defense:5,     life:10,     speed:3000, range:0,    x:0, qty:0},
						Halberdsman       :{meleeDamage:40,    rangeDamage:0,    defense:40,    life:150,    speed:300,  range:0,    x:0, qty:0},
						Minotaur          :{meleeDamage:70,    rangeDamage:0,    defense:45,    life:225,    speed:275,  range:0,    x:0, qty:0},
						Longbowman        :{meleeDamage:5,     rangeDamage:80,   defense:30,    life:75,     speed:250,  range:1200, x:0, qty:0},
						SwiftStrikeDragon :{meleeDamage:150,   rangeDamage:0,    defense:60,    life:300,    speed:1000, range:0,    x:0, qty:0},
						BattleDragon      :{meleeDamage:300,   rangeDamage:0,    defense:300,   life:1500,   speed:750,  range:0,    x:0, qty:0},
						ArmoredTransport  :{meleeDamage:5,     rangeDamage:0,    defense:200,   life:750,    speed:150,  range:0,    x:0, qty:0},
						Giant             :{meleeDamage:1000,  rangeDamage:0,    defense:400,   life:4000,   speed:120,  range:0,    x:0, qty:0},
						FireMirror        :{meleeDamage:20,    rangeDamage:1200, defense:30,    life:1500,   speed:50,   range:1500, x:0, qty:0},
						PackDragon        :{meleeDamage:150,   rangeDamage:0,    defense:400,   life:850,    speed:1000, range:0,    x:0, qty:0},
						AquaTroop         :{meleeDamage:1600,  rangeDamage:800,  defense:300,   life:3000,   speed:500,  range:600,  x:0, qty:0},
						StoneTroop        :{meleeDamage:650,   rangeDamage:0,    defense:900,   life:15000,  speed:350,  range:0,    x:0, qty:0},
						FireTroop         :{meleeDamage:500,   rangeDamage:2000, defense:150,   life:1000,   speed:400,  range:1600, x:0, qty:0},
						WindTroop         :{meleeDamage:700,   rangeDamage:0,    defense:200,   life:2850,   speed:1350, range:0,    x:0, qty:0},
						GreatDragon       :{meleeDamage:2425,  rangeDamage:2425, defense:2425,  life:242514, speed:750,  range:1500, x:0, qty:0},
						WaterDragon       :{meleeDamage:2728,  rangeDamage:2425, defense:2122,  life:242514, speed:800,  range:1500, x:0, qty:0},
						StoneDragon       :{meleeDamage:9700,  rangeDamage:7276, defense:14550, life:970056, speed:650,  range:1700, x:0, qty:0},
						FireDragon        :{meleeDamage:6398,  rangeDamage:9564, defense:4132,  life:413216, speed:850,  range:1800, x:0, qty:0},
						WindDragon        :{meleeDamage:10306, rangeDamage:7275, defense:6063,  life:606285, speed:1300, range:1000, x:0, qty:0}},
	contentType		: 0, // 0 = config, 1 = result, 2 = log, 3 = rules
	attackLosts		: { Porter            :{qty:0, defense:0, life:0},
						Conscript         :{qty:0, defense:0, life:0},
						Spy               :{qty:0, defense:0, life:0},
						Halberdsman       :{qty:0, defense:0, life:0},
						Minotaur          :{qty:0, defense:0, life:0},
						Longbowman        :{qty:0, defense:0, life:0},
						SwiftStrikeDragon :{qty:0, defense:0, life:0},
						BattleDragon      :{qty:0, defense:0, life:0},
						ArmoredTransport  :{qty:0, defense:0, life:0},
						Giant             :{qty:0, defense:0, life:0},
						FireMirror        :{qty:0, defense:0, life:0},
						PackDragon        :{qty:0, defense:0, life:0},
						AquaTroop         :{qty:0, defense:0, life:0},
						StoneTroop        :{qty:0, defense:0, life:0},
						FireTroop         :{qty:0, defense:0, life:0},
						WindTroop         :{qty:0, defense:0, life:0},
						GreatDragon       :{qty:0, defense:0, life:0},
						WaterDragon       :{qty:0, defense:0, life:0},
						StoneDragon       :{qty:0, defense:0, life:0},
						FireDragon        :{qty:0, defense:0, life:0},
						WindDragon        :{qty:0, defense:0, life:0}},
	defenseLosts	: { Porter            :{qty:0, defense:0, life:0},
						Conscript         :{qty:0, defense:0, life:0},
						Spy               :{qty:0, defense:0, life:0},
						Halberdsman       :{qty:0, defense:0, life:0},
						Minotaur          :{qty:0, defense:0, life:0},
						Longbowman        :{qty:0, defense:0, life:0},
						SwiftStrikeDragon :{qty:0, defense:0, life:0},
						BattleDragon      :{qty:0, defense:0, life:0},
						ArmoredTransport  :{qty:0, defense:0, life:0},
						Giant             :{qty:0, defense:0, life:0},
						FireMirror        :{qty:0, defense:0, life:0},
						PackDragon        :{qty:0, defense:0, life:0},
						AquaTroop         :{qty:0, defense:0, life:0},
						StoneTroop        :{qty:0, defense:0, life:0},
						FireTroop         :{qty:0, defense:0, life:0},
						WindTroop         :{qty:0, defense:0, life:0},
						GreatDragon       :{qty:0, defense:0, life:0},
						WaterDragon       :{qty:0, defense:0, life:0},
						StoneDragon       :{qty:0, defense:0, life:0},
						FireDragon        :{qty:0, defense:0, life:0},
						WindDragon        :{qty:0, defense:0, life:0}},
	attackAlives	: { Porter            :{qty:0, defense:0, life:0},
						Conscript         :{qty:0, defense:0, life:0},
						Spy               :{qty:0, defense:0, life:0},
						Halberdsman       :{qty:0, defense:0, life:0},
						Minotaur          :{qty:0, defense:0, life:0},
						Longbowman        :{qty:0, defense:0, life:0},
						SwiftStrikeDragon :{qty:0, defense:0, life:0},
						BattleDragon      :{qty:0, defense:0, life:0},
						ArmoredTransport  :{qty:0, defense:0, life:0},
						Giant             :{qty:0, defense:0, life:0},
						FireMirror        :{qty:0, defense:0, life:0},
						PackDragon        :{qty:0, defense:0, life:0},
						AquaTroop         :{qty:0, defense:0, life:0},
						StoneTroop        :{qty:0, defense:0, life:0},
						FireTroop         :{qty:0, defense:0, life:0},
						WindTroop         :{qty:0, defense:0, life:0},
						GreatDragon       :{qty:0, defense:0, life:0},
						WaterDragon       :{qty:0, defense:0, life:0},
						StoneDragon       :{qty:0, defense:0, life:0},
						FireDragon        :{qty:0, defense:0, life:0},
						WindDragon        :{qty:0, defense:0, life:0}},
	defenseAlives	: { Porter            :{qty:0, defense:0, life:0},
						Conscript         :{qty:0, defense:0, life:0},
						Spy               :{qty:0, defense:0, life:0},
						Halberdsman       :{qty:0, defense:0, life:0},
						Minotaur          :{qty:0, defense:0, life:0},
						Longbowman        :{qty:0, defense:0, life:0},
						SwiftStrikeDragon :{qty:0, defense:0, life:0},
						BattleDragon      :{qty:0, defense:0, life:0},
						ArmoredTransport  :{qty:0, defense:0, life:0},
						Giant             :{qty:0, defense:0, life:0},
						FireMirror        :{qty:0, defense:0, life:0},
						PackDragon        :{qty:0, defense:0, life:0},
						AquaTroop         :{qty:0, defense:0, life:0},
						StoneTroop        :{qty:0, defense:0, life:0},
						FireTroop         :{qty:0, defense:0, life:0},
						WindTroop         :{qty:0, defense:0, life:0},
						GreatDragon       :{qty:0, defense:0, life:0},
						WaterDragon       :{qty:0, defense:0, life:0},
						StoneDragon       :{qty:0, defense:0, life:0},
						FireDragon        :{qty:0, defense:0, life:0},
						WindDragon        :{qty:0, defense:0, life:0}},
	itemList		: [	'DragonHearts', 'GlowingShields', 'PurpleBones', 'CrimsonBull'],
	researchList	: [	'RapidDeployment', 'Ballistics', 'Metallurgy', 'Medicine', 'Dragonry', 'AerialCombat'],
	researchDefault	: {	RapidDeployment:0, Ballistics:0, Metallurgy:0, Medicine:0, Dragonry:0, AerialCombat:0},

	init : function (div){
		var t = Tabs.Battle;

		t.container = div;

		if (Data.options.calculator == null || Data.options.calculator.attDragLevel == undefined || !Data.options.calculator.attDragLevel) {
			Data.options.calculator = {data:{ennemyResearch:{}, attackItems:[], defenseItems:[], attackUnits:{}, defenseUnits:{}, battleLog:[]}, ownStatus:1, attDragLevel:0, defDragLevel:0, battleTurn:0, attGeneral:5, defGeneral:5, defWall:1 };
			Data.options.calculator.data.attackUnits = cloneProps(t.troopDefault);
			Data.options.calculator.data.defenseUnits = cloneProps(t.troopDefault);
			Data.options.calculator.data.ennemyResearch = cloneProps(t.researchDefault);
		}
		if (!Data.options.calculator.data.attackUnits ||
			Data.options.calculator.data.attackUnits == null ||
			Data.options.calculator.data.attackUnits == undefined ||
			Data.options.calculator.data.attackUnits.length == 0)
			Data.options.calculator.data.attackUnits = cloneProps(t.troopDefault);
		if (!Data.options.calculator.data.defenseUnits ||
			Data.options.calculator.data.defenseUnits == null ||
			Data.options.calculator.data.defenseUnits == undefined ||
			Data.options.calculator.data.defenseUnits.length == 0)
			Data.options.calculator.data.defenseUnits = cloneProps(t.troopDefault);
		if (!Data.options.calculator.data.ennemyResearch ||
			Data.options.calculator.data.ennemyResearch == null ||
			Data.options.calculator.data.ennemyResearch == undefined ||
			Data.options.calculator.data.ennemyResearch.length == 0)
			Data.options.calculator.data.ennemyResearch = cloneProps(t.researchDefault);

		//for (i=0; i<t.troopList.length; i++)
		//  logit ('TroopDefault['+t.troopList[i]+'] : '+inspectObj(t.troopDefault[t.troopList[i]]));
		//  logit ('attackUnits['+t.troopList[i]+'] : '+inspectObj(Data.options.calculator.data.attackUnits[t.troopList[i]]));
		//  logit ('defenseUnits['+t.troopList[i]+'] : '+inspectObj(Data.options.calculator.data.defenseUnits[t.troopList[i]]));

		setUID('tabBattle_OwnStatus');
		var m = '<div class=' + UID['title'] + '>' + translate('Battle calculator') + '</div>'
			+'<div class=' + UID['status_ticker'] + ' id='+ setUID('tabBattle_Status') +' style="margin-bottom:5px !important">'
			+'	<table width=100%><tr>'
			+'		<td><center><input type=button value="' + translate('Clear all data') + '" id='+ setUID('tabBattle_ClearAll') +' /></center></td>'
			+'		<td><center><input type=button value="' + translate('Clear log') + '" id='+ setUID('tabBattle_ClearLog') +' /></center></td>'
			+'	</tr></table><br>'
			+'	<table width=100%><tr>'
			+'		<td width=15%><label>' + translate('You are') + '</label></td>'
			+'		<td width=5%><input type=radio name='+ UID['tabBattle_OwnStatus'] +' value="0" /></td><td align=left colspan=2><label>'+ translate('Attacker') +'</label></td>'
			+'	</tr><tr>'
			+'		<td width=15%></td>'
			+'		<td width=5%><input type=radio name='+ UID['tabBattle_OwnStatus'] +' value="1" /></td><td align=left width=15%><label>'+ translate('Defender') +'</label></td>'
			+'		<td width=75%><center><input type=button value="' + translate('Available troops') + '" id='+ setUID('tabBattle_GetTroops') +' /></center></td>'
			+'	</tr></table>'
			+'</div>'
			+'<ul class=tabs>'
			+'	<li class="tab first"><a id='+ setUID('tabBattleConfig') +'>'+ translate('Config') +'</a></li>'
			+'	<li class=tab><a id='+ setUID('tabBattleResult') +'>'+ translate('Battle notes') +'</a></li>'
			+'	<li class=tab><a id='+ setUID('tabBattleLog') +'>'+ translate('Battle log') +'</a></li>'
			+'	<li class=tab><a id='+ setUID('tabBattleRules') +'>'+ translate('Rules') +'</a></li>'
			+'</ul>'
			+'<div id='+ setUID('tabBattle_Content') +' style="padding-top:0px; height:620px; ; max-height:620px; overflow-y:auto"></div>';

		t.container.innerHTML = m;
		document.getElementById(UID['tabBattle_ClearAll']).addEventListener ('click', t.clearAllData, false);
		document.getElementById(UID['tabBattle_ClearLog']).addEventListener ('click', t.clearLog, false);
		document.getElementById(UID['tabBattle_GetTroops']).addEventListener ('click', t.getOwnTroops, false);
		document.getElementById(UID['tabBattleConfig']).addEventListener ('click', t.tabBattleConfig, false);
		document.getElementById(UID['tabBattleResult']).addEventListener ('click', t.tabBattleResult, false);	
		document.getElementById(UID['tabBattleLog']).addEventListener ('click', t.tabBattleLog, false);	
		document.getElementById(UID['tabBattleRules']).addEventListener ('click', t.tabBattleRules, false);	
		window.addEventListener('unload', t.onUnload, false);
		var r = document.getElementsByName(UID['tabBattle_OwnStatus']);
		for (i=0;i<r.length;i++) {
			r[i].addEventListener('change', enableChanged, false);
			r[i].checked = (r[i].value == Data.options.calculator.ownStatus);
		}

		function enableChanged(e){
			var t = Tabs.Battle;
			Data.options.calculator.ownStatus = e.target.value;
		}
		// Restore the views
		t.contentType = Data.options.calculator.current_tab;
		t.show();
	},

	show : function (){
		var t = Tabs.Battle;
		switch (isEmpty(t.contentType, 0)) {
			case 0: t.tabBattleConfig(); break;
			case 1: t.tabBattleResult(); break;
			case 2: t.tabBattleLog(); break;
			case 3: t.tabBattleRules(); break;
		}
	},

	onUnload : function (){
		var t = Tabs.Battle;
		logit ('===============  Tabs.Battle.onUnload');
		Data.options.calculator.current_tab = t.contentType;
	},

	hide : function (){
	},

	clearAllData : function (){
		var t = Tabs.Battle;
		Data.options.calculator = {data:{ennemyResearch:{}, attackItems:[], defenseItems:[], attackUnits:{}, defenseUnits:{}, battleLog:[]}, ownStatus:1, attDragLevel:0, defDragLevel:0, battleTurn:0, attGeneral:5, defGeneral:5, defWall:1 };
		Data.options.calculator.data.attackUnits = cloneProps(t.troopDefault);
		Data.options.calculator.data.defenseUnits = cloneProps(t.troopDefault);
		Data.options.calculator.data.ennemyResearch = cloneProps(t.researchDefault);
		t.show();
	},

	clearLog : function (){
		var t = Tabs.Battle;
		Data.options.calculator.data.battleLog = [];
		if (isEmpty(t.contentType, 0) == 2) t.tabBattleLog();
	},

	getOwnTroops : function (){
// A utiliser uniquement si on est sur l'onglet config.... Rajouter un contrôle ou bloquer l'utilisation du bouton
		var t = Tabs.Battle;
		var city = Seed.cities[CAPITAL_ID];
		for (i=0; i<t.troopList.length; i++){
			var num = city.units[t.troopList[i]];
			if (!num) num = 0;
			if ((t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') &&
				(t.troopList[i] != 'StoneDragon') && (t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon')) {
				Data.options.calculator.data.defenseUnits[t.troopList[i]].qty = num;
				document.getElementById(UID['tabBattle_Trp_D_'+ i]).value = num;
			}
		}
	},

	/** BATTLE CONFIG SUB-TAB ***/
	tabBattleConfig : function (){
		var t = Tabs.Battle;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabBattleConfig']).className='selected';
		document.getElementById(UID['tabBattleConfig']).style.zIndex=1;
		t.lastSubTab = 'tabBattleConfig';

		t.contentType = 0;
		Data.options.calculator.current_tab = t.contentType;
		var m = '<div id=' + setUID('tabBattle_Config') + '>'
			+'	<div class=' + UID['title'] + '>' + translate('Battle forces') + '</div>'
			+'	<div id=' + setUID('tabBattle_Troops') + ' class=' + UID['status_ticker'] + ' style="height:575px; max-height:575px; overflow-y:auto ; overflow-x:auto ; margin-top:1px !important">'
			+'		<table class=' + UID['table'] + ' width=100%>'
			+'			<tr class=' + UID['row_headers'] +'>'
			+'				<td valign=middle width=30%><b>'+ translate('Troops') +'</b></td>'
			+'				<td valign=middle width=30%><b>'+ translate('Attacker') +'</b></td>'
			+'				<td valign=middle width=30%><b>'+ translate('Defender') +'</b></td>'
			+'				<td valign=middle width=10% style="background:none"></td>'
			+'			</tr>';

		for (var i=0; i<t.troopList.length; i++){
			if ((t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') &&
				(t.troopList[i] != 'StoneDragon') && (t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon')) {
				m += '<tr><td class=left>'+ translate(Names.troops.byName[t.troopList[i]][1]) +'</td>';
				var num = 0;
				if (Data.options.calculator.data.attackUnits[t.troopList[i]].qty) num = isEmpty(Data.options.calculator.data.attackUnits[t.troopList[i]].qty,0);
				m += '<td align=center><input type=text id=' + setUID('tabBattle_Trp_A_'+ i) +' ref='+ ('A_'+ i) +' maxlength=6 style="width:60px" size=2 value="'+ num +'"\></td>';
				if (Data.options.calculator.data.defenseUnits[t.troopList[i]].qty) num = isEmpty(Data.options.calculator.data.defenseUnits[t.troopList[i]].qty,0);
				else num = 0;
				m += '<td align=center><input type=text id=' + setUID('tabBattle_Trp_D_'+ i) +' ref='+ ('D_'+ i) +' maxlength=8 style="width:70px" size=2 value="'+ num +'"\></td><td></td>';
				m += '</tr>';
			}
		}
		m += '<tr><td class=left>'+ translate('Great dragons') +'</td>'
			+'	<td align=center>'+ dragonSelect('Att', Data.options.calculator.data.attackUnits) +'&nbsp'+ dragLvlSelect('A',Data.options.calculator.attDragLevel) +'</td>'
			+'	<td align=center>'+ dragonSelect('Def', Data.options.calculator.data.defenseUnits) +'&nbsp'+ dragLvlSelect('D',Data.options.calculator.defDragLevel) +'</td><td></td></tr>'
			+'<tr><td class=left>'+ translate('Generals') +'</td>'
			+'	<td align=center>'+ generalSelect('Att', isEmpty(Data.options.calculator.attGeneral,'5')) +'</td>'
			+'	<td align=center>'+ generalSelect('Def', isEmpty(Data.options.calculator.defGeneral,'5')) +'</td><td></td></tr>'
			+'<tr><td class=left>'+ translate('Wall') +'</td><td>&nbsp</td>'
			+'	<td align=center>'+ defWallSelect(isEmpty(Data.options.calculator.defWall,'1')) +'</td><td></td></tr>';
		m += '<tr><td colspan=4 style="font-size:2px">&nbsp</td></tr>'
			+'<tr><td width=100% colspan=4 align=center><table cellpadding=1 cellspacing=1 width=90%>'
			+'	<tr><td width=40%><hr></td><td>  '+ translate('Upgrading items') +'  </td><td width=40%><hr></td></tr>'
			+'</table></td></tr>';
		var el = [];
		for (var i=0; i<t.itemList.length; i++){
			m += '<tr><td class=left>'+ translate(t.itemList[i]) +'</td>';
			var num = 0;
			m += '<td align=center><input type=checkbox id="' + setUID('tabBattle_cb_A_'+ i) +'" '+ (Data.options.calculator.data.attackItems[i]?'CHECKED':'') +' ref="'+ ('A_'+ i) +'" /></td>';
			m += '<td align=center><input type=checkbox id="' + setUID('tabBattle_cb_D_'+ i) +'" '+ (Data.options.calculator.data.defenseItems[i]?'CHECKED':'') +' ref="'+ ('D_'+ i) +'" /></td>';
			el.push(UID['tabBattle_cb_A_'+ i]);
			el.push(UID['tabBattle_cb_D_'+ i]);
			m += '</tr>';
		}
		m += '<tr><td colspan=4 style="font-size:2px">&nbsp</td></tr>'
			+'<tr><td width=100% colspan=4 align=center><table cellpadding=1 cellspacing=1 width=90%>'
			+'	<tr><td width=40%><hr></td><td>  '+ translate('Ennemy research levels') +'  </td><td width=40%><hr></td></tr>'
			+'</table></td></tr>';
			+'</table>';
			+'<table class=' + UID['table'] + ' width=100%>'
		var rl = [];
		var col = 0;
		for (var i=0; i<t.researchList.length; i++){
			if (col == 0) m += '<tr>';
			m += '<td class=left>'+ translate(t.researchList[i]) +'</td>';
			var num = 0;
			m += '<td>'+ researchSelect(i, isEmpty(Data.options.calculator.data.ennemyResearch[t.researchList[i]],'0') ) +'</td>';
			rl.push(UID['tabBattle_rs_A_'+ i]);
			if (col == 1) {
				col = 0;
				m += '</tr>';
			} else col++;
		}
		m += '<tr><td colspan=4><center><input id=' + setUID('tabBattle_StartBattle') + ' type=button value="' + translate('Calculate') + '" /></center></td></tr>'
			+'</table></div></div>';
		document.getElementById(UID['tabBattle_Content']).innerHTML = m; 

		// add event listeners ...
		for (var i=0; i<t.troopList.length; i++) {
			if ((t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') &&
				(t.troopList[i] != 'StoneDragon') && (t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon')) {
				document.getElementById(UID['tabBattle_Trp_A_'+ i]).addEventListener('change', attackTroopsChanged, false);
				document.getElementById(UID['tabBattle_Trp_D_'+ i]).addEventListener('change', defenseTroopsChanged, false);
			}
		}
		document.getElementById(UID['tabBattle_DragSelAtt']).addEventListener('change', attackDragonChanged, false);
		document.getElementById(UID['tabBattle_DragLvlA']).addEventListener('change', attDragLvlChanged, false);
		document.getElementById(UID['tabBattle_DragSelDef']).addEventListener('change', defenseDragonChanged, false);
		document.getElementById(UID['tabBattle_DragLvlD']).addEventListener('change', defDragLvlChanged, false);
		document.getElementById(UID['tabBattle_GeneralAtt']).addEventListener('change', attGeneralChanged, false);
		document.getElementById(UID['tabBattle_GeneralDef']).addEventListener('change', defGeneralChanged, false);
		document.getElementById(UID['tabBattle_Wall']).addEventListener('change', defWallChanged, false);
		document.getElementById(UID['tabBattle_StartBattle']).addEventListener ('click', t.startBattle, false);

		for (var i=0; i<el.length; i++)
			document.getElementById(el[i]).addEventListener('click', checked, false);

		for (var i=0; i<rl.length; i++)
			document.getElementById(rl[i]).addEventListener('change', ennemyResearchChanged, false);

		function checked (evt){
			var id = evt.target.getAttribute('ref').split ('_');
			if (id[0] == 'A')
				Data.options.calculator.data.attackItems[id[1]] = evt.target.checked;
			else
				Data.options.calculator.data.defenseItems[id[1]] = evt.target.checked;
		}
		function attackTroopsChanged (e){
			var t = Tabs.Battle;
			var args = e.target.getAttribute('ref').split('_');
			var x = parseIntZero(e.target.value);
			var max = 999999;
			if (isNaN(x) || x<0 || x>max) {
				e.target.style.backgroundColor = 'red';
			} else {
				e.target.value = x;
				Data.options.calculator.data.attackUnits[t.troopList[args[1]]].qty = x;
				e.target.style.backgroundColor = '';
			}
		}
		function attackDragonChanged (e){
			var id = document.getElementById(UID['tabBattle_DragSelAtt']);
			var sel = isEmpty(id.value,'none');
			id.value = sel;
			for (var d=0; d<t.dragList.length; d++)
				Data.options.calculator.data.attackUnits[t.dragList[d]].qty = 0;
			if (sel != 'none') Data.options.calculator.data.attackUnits[sel].qty = 1;
			id.style.backgroundColor = '';
		}
		function attDragLvlChanged (e){
			var id = document.getElementById(UID['tabBattle_DragLvlA']);
			var x = parseIntZero(id.value);
			if (isNaN(x) || x<0 || x>10){
				id.style.backgroundColor = 'red';
			} else {
				id.value = x;
				Data.options.calculator.attDragLevel = x;
				id.style.backgroundColor = '';
			}
		}
		function attGeneralChanged (e){
			var id = document.getElementById(UID['tabBattle_GeneralAtt']);
			var x = parseIntZero(id.value);
			if (isNaN(x) || x<0 || x>5){
				id.style.backgroundColor = 'red';
			}else {
				id.value = x;
				Data.options.calculator.attGeneral = x;
				id.style.backgroundColor = '';
			}
		}

		function defenseTroopsChanged (e){
			var t = Tabs.Battle;
			var args = e.target.getAttribute('ref').split('_');
			var x = parseIntZero(e.target.value);
			var max = 999999999;
			if (isNaN(x) || x<0 || x>max) {
				e.target.style.backgroundColor = 'red';
			} else {
				e.target.value = x;
				Data.options.calculator.data.defenseUnits[t.troopList[args[1]]].qty = x;
				e.target.style.backgroundColor = '';
			}
		}
		function defenseDragonChanged (e){
			var id = document.getElementById(UID['tabBattle_DragSelDef']);
			var sel = isEmpty(id.value,'none');
			id.value = sel;
			for (var d=0; d<t.dragList.length; d++)
				Data.options.calculator.data.defenseUnits[t.dragList[d]].qty = 0;
			if (sel != 'none') Data.options.calculator.data.defenseUnits[sel].qty = 1;
			id.style.backgroundColor = '';
		}
		function defDragLvlChanged (e){
			var id = document.getElementById(UID['tabBattle_DragLvlD']);
			var x = parseIntZero(id.value);
			if (isNaN(x) || x<0 || x>10){
				id.style.backgroundColor = 'red';
			} else {
				id.value = x;
				Data.options.calculator.defDragLevel = x;
				id.style.backgroundColor = '';
			}
		}
		function defGeneralChanged (e){
			var id = document.getElementById(UID['tabBattle_GeneralDef']);
			var x = parseIntZero(id.value);
			if (isNaN(x) || x<0 || x>5){
				id.style.backgroundColor = 'red';
			}else {
				id.value = x;
				Data.options.calculator.defGeneral = x;
				id.style.backgroundColor = '';
			}
		}
		function defWallChanged (e){
			var id = document.getElementById(UID['tabBattle_Wall']);
			var x = parseIntZero(id.value);
			if (isNaN(x) || x<0 || x>10){
				id.style.backgroundColor = 'red';
			}else {
				id.value = x;
				Data.options.calculator.defWall = x;
				id.style.backgroundColor = '';
			}
		}

		function dragonSelect (suffid, trpList){
			var t = Tabs.Battle;
			var found = false;
			var m = '<select id="' + setUID('tabBattle_DragSel' + suffid) + '">';
			for (var d=0; d<t.dragList.length; d++){
				var selected = '';
				if (trpList[t.dragList[d]].qty > 0) {
					selected = 'selected';
					found = true;
				}
				m += '<option value="' + t.dragList[d] + '" ' + selected + '>' + translate(Names.troops.byName[t.dragList[d]][1]) + '</option>';
			}
			if (!found) selected = 'selected'
			else selected = '';
			m += '<option value="none" ' + selected + '>' + translate('None') + '</option>';
			m += '</select>';
			return m;
		}
		function dragLvlSelect (suffid, curVal){
			var m = '<select id="' + setUID('tabBattle_DragLvl' + suffid) + '">';
			for (var k=1; k<=10; k++)
				m += '<option value="' + k + '" ' + (curVal==k?'selected':'') + '>' + k + '</option>';
			m += '</select>';
			return m;
		}
		function generalSelect (suffid, curVal){
			var m = '<select id="' + setUID('tabBattle_General' + suffid) + '">';
			for (var k=1; k<=5; k++)
				m += '<option value="' + k + '" ' + (curVal==k?'SELECTED':'') + '>' + k + ' ' + translate('Stars') + '</option>';
			m += '</select>';
			return m;
		}
		function defWallSelect (curVal){
			var m = '<select id="' + setUID('tabBattle_Wall') + '">';
			for (var k=1; k<=10; k++)
				m += '<option value="' + k + '" ' + (curVal==k?'SELECTED':'') + '>' + k + '</option>';
			m += '</select>';
			return m;
		}
		function ennemyResearchChanged (evt){
			var id = evt.target.getAttribute('ref').split ('_');
			var x = parseIntZero(evt.target.value);
			if (isNaN(x) || x<0 || x>10){
				evt.target.style.backgroundColor = 'red';
			} else {
				evt.target.value = x;
				Data.options.calculator.data.ennemyResearch[t.researchList[id[1]]] = x;
				evt.target.style.backgroundColor = '';
			}
		}
		function researchSelect (listIdx, curVal){
			var m = '<select id="' + setUID('tabBattle_rs_A_' + listIdx) + '" ref='+ ('A_'+ listIdx) +'>';
			for (var k=1; k<=10; k++)
				m += '<option value="' + k + '" ' + (curVal==k?'selected':'') + '>' + k + '</option>';
			m += '</select>';
			return m;
		}
	},


	/** BATTLE RESULT SUB-TAB ***/
	tabBattleResult : function (){
		var t = Tabs.Battle;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabBattleResult']).className='selected';
		document.getElementById(UID['tabBattleResult']).style.zIndex=1;
		t.lastSubTab = 'tabBattleResult';

		t.contentType = 1;
		Data.options.calculator.current_tab = t.contentType;
		var m = '<div id=' + setUID('tabBattle_Result') + '>'
			+'	<div class=' + UID['title'] + '>' + translate('Battle notes') + '</div>'
			+'	<div id=' + setUID('tabBattle_Report') + ' class=' + UID['status_ticker'] + ' style="height:575px; max-height:575px; overflow-y:auto ; overflow-x:auto ; margin-top:1px !important">'
			+'		<table class=' + UID['table'] + ' width=100%>'
			+'			<tr class=' + UID['row_headers'] +'>'
			+'				<td valign=middle width=30%><b>'+ translate('Troops') +'</b></td>'
			+'				<td valign=middle width=35% colspan=2><b>'+ translate('Attacker') +'</b></td>'
			+'				<td valign=middle width=35% colspan=2><b>'+ translate('Defender') +'</b></td>'
			+'			</tr>'
			+'			<tr class=' + UID['row_headers'] +'>'
			+'				<td valign=middle width=30%>&nbsp</td>'
			+'				<td valign=middle width=18%><b>'+ translate('Alives') +'</b></td>'
			+'				<td valign=middle width=17%><b>'+ translate('Killed') +'</b></td>'
			+'				<td valign=middle width=18%><b>'+ translate('Alives') +'</b></td>'
			+'				<td valign=middle width=17%><b>'+ translate('Killed') +'</b></td>'
			+'			</tr>';

		for (var i=0; i<t.troopList.length; i++){
			if ((t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') &&
				(t.troopList[i] != 'StoneDragon') && (t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon')) {
				m += '<tr><td class=left>'+ translate(Names.troops.byName[t.troopList[i]][1]) +'</td>';
				var num = 0;
				num = nombreFormate(isEmpty(t.attackAlives[t.troopList[i]].qty,0), ' ');
				m += '<td align=right>'+ num +'</td>';
				var num = 0;
				num = isEmpty(t.attackLosts[t.troopList[i]].qty,0);
				num = (num > 0) ? '<span class=' + UID['red'] + '>'+ nombreFormate(num,' ') +'</span>' : nombreFormate(num,' ');
				m += '<td align=right>'+ num +'</td>';
				var num = 0;
				num = nombreFormate(isEmpty(t.defenseAlives[t.troopList[i]].qty,0), ' ');
				m += '<td align=right>'+ num +'</td>';
				num = isEmpty(t.defenseLosts[t.troopList[i]].qty,0);
				num = (num > 0) ? '<span class=' + UID['red'] + '>'+ nombreFormate(num,' ') +'</span>' : nombreFormate(num,' ');
				m += '<td align=right>'+ num +'</td>';
				m += '</tr>';
			}
		}
		// Great dragons display (specific as we show damage received)
		for (var d=0; d<t.dragList.length; d++){
			if ((Data.options.calculator.data.attackUnits[t.dragList[d]].qty > 0) ||
				(Data.options.calculator.data.defenseUnits[t.dragList[d]].qty > 0)){
				if (Data.options.calculator.data.attackUnits[t.dragList[d]].qty > 0) {
					var attAlive = nombreFormate(isEmpty(t.attackAlives[t.dragList[d]].qty,0),' ');
					var attLost = isEmpty(t.attackLosts[t.dragList[d]].qty,0);
					attLost = (attLost > 0) ? '<span class=' + UID['red'] + '>'+ nombreFormate(attLost,' ') +'</span>' : nombreFormate(attLost,' ');
					var dmg = nombreFormate(isEmpty(t.attackLosts[t.dragList[d]].defense,0),' ');
					var life = ((isEmpty(t.attackLosts[t.dragList[d]].life,0) / Data.options.calculator.data.attackUnits[t.dragList[d]].life) * 100);
					life = life.toFixed(2);
					var attState = dmg + translate(' damages taken') + '<BR>' + life + '% ' + translate('life lost'); // + '(reste '+t.attackAlives[t.dragList[d]].life+')';
				} else {
					var attAlive = '';
					var attLost  = '';
					var attState = '';
				}
				if (Data.options.calculator.data.defenseUnits[t.dragList[d]].qty > 0) {
					var defAlive = nombreFormate(isEmpty(t.defenseAlives[t.dragList[d]].qty,0),' ');
					var defLost = isEmpty(t.defenseLosts[t.dragList[d]].qty,0);
					defLost = (defLost > 0) ? '<span class=' + UID['red'] + '>'+ nombreFormate(defLost,' ') +'</span>' : nombreFormate(defLost,' ');
					var dmg = nombreFormate(isEmpty(t.defenseLosts[t.dragList[d]].defense,0),' ');
					var life = ((isEmpty(t.defenseLosts[t.dragList[d]].life,0) / Data.options.calculator.data.defenseUnits[t.dragList[d]].life) * 100);
					life = life.toFixed(2);
					var defState = dmg + translate(' damages taken') + '<BR>' + life + '% ' + translate('life lost'); // + '(reste '+t.defenseAlives[t.dragList[d]].life+')';
				} else {
					var defAlive = '';
					var defLost  = '';
					var defState = '';
				}
				m += '<tr><td class=left>'+ translate(Names.troops.byName[t.dragList[d]][1]) +'</td>'
					+'<td align=right>'+ attAlive +'</td>'
					+'<td align=right>'+ attLost +'</td>'
					+'<td align=right>'+ defAlive +'</td>'
					+'<td align=right>'+ defLost +'</td></tr>'
					+'<tr><td>&nbsp</td>'
					+'<td align=right colspan=2>'+ attState +'</td>'
					+'<td align=right colspan=2>'+ defState +'</td></tr>';
			}
		}
		m += '<tr><td colspan=5>&nbsp</td></tr>'
			+'<tr><td width=100% colspan=5 align=center><table cellpadding=10 cellspacing=10 width=90%>'
			+'	<tr><td width=40%><hr></td><td>  '+ translate('Upgrading items') +'  </td><td width=40%><hr></td></tr>'
			+'</table></td></tr>';

		for (var i=0; i<t.itemList.length; i++){
			m += '<tr><td class=left>'+ translate(t.itemList[i]) +'</td>'
				+'<td align=center colspan=2>'+ (Data.options.calculator.data.attackItems[i]?'<span class=' + UID['red'] + '>X</span>':'') +'</td>'
				+'<td align=center colspan=2>'+ (Data.options.calculator.data.defenseItems[i]?'<span class=' + UID['red'] + '>X</span>':'') +'</td>'
				+'</tr>';
		}
		m += '</table></div></div>';
		document.getElementById(UID['tabBattle_Content']).innerHTML = m; 
	},


	/** BATTLE LOG SUB-TAB ***/
	tabBattleLog : function (){
		var t = Tabs.Battle;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabBattleLog']).className='selected';
		document.getElementById(UID['tabBattleLog']).style.zIndex=1;
		t.lastSubTab = 'tabBattleLog';

		t.contentType = 2;
		Data.options.calculator.current_tab = t.contentType;
		var logTable = null;
		var m = '<div id=' + setUID('tabBattle_Log') + '>'
			+'	<div class=' + UID['title'] + '>' + translate('Battle log') + '</div>'
			+'	<div id=' + setUID('tabBattle_Logs') + ' class=' + UID['status_ticker'] + ' style="height:575px; max-height:575px; overflow-y:auto ; overflow-x:auto ; margin-top:1px !important">'
			+'		<table id=' + setUID('tabBattle_LogTable') + ' class=' + UID['table_console'] + ' cellspacing=1 width=100%>';
		for (var i=0; i<Data.options.calculator.data.battleLog.length; i++)
			if (!Data.options.calculator.data.battleLog[i].msg2)
				m += '<tr><td>'+ Data.options.calculator.data.battleLog[i].turn + '</td><td colspan=2>' + Data.options.calculator.data.battleLog[i].msg + '</td></tr>';
			else
				m += '<tr><td>'+ Data.options.calculator.data.battleLog[i].turn + '</td><td width=5%></td><td width=90%>' + Data.options.calculator.data.battleLog[i].msg2 + '</td></tr>';
		document.getElementById(UID['tabBattle_Content']).innerHTML = m + '</table></div></div>'; 
	},

	log : function (msg, msg2, turn){
		var t = Tabs.Battle;
		Data.options.calculator.data.battleLog.push ({turn:turn, msg:msg, msg2:msg2});
	},


	/** BATTLE CALCULATOR ***/
	startBattle : function (){
		var t = Tabs.Battle;
		var maxRange = 0;
		t.battleStop = false;

		function applyUpgrade (src, percent){
			var dest = src + Math.floor(src * (percent / 100));
			return dest;
		}

		function loadGreatDragonStats (src, unit, lev){
			// Load great dragons statistics from manifest according to level selected
			var dfltMeleeDamage = t.troopDefault[unit].meleeDamage;
			var dfltRangeDamage = t.troopDefault[unit].rangeDamage;
			var dfltDefense     = t.troopDefault[unit].defense;
			var dfltLife        = t.troopDefault[unit].life;
			var dfltRange       = t.troopDefault[unit].range;
			var dfltSpeed       = t.troopDefault[unit].speed;
			switch (unit) {
				case 'GreatDragon' : var DragStats = Seed.greatDragons.GreatDragon; break;
				case 'WaterDragon' : var DragStats = Seed.greatDragons.WaterDragon; break;
				case 'StoneDragon' : var DragStats = Seed.greatDragons.StoneDragon; break;
				case 'FireDragon'  : var DragStats = Seed.greatDragons.FireDragon; break;
				case 'WindDragon'  : var DragStats = Seed.greatDragons.WindDragon; break;
				default: var DragStats = Seed.greatDragons.GreatDragon; break;
			}
			try {
				var dfltMeleeDamage = DragStats[lev].melee;
				var dfltRangeDamage = DragStats[lev].ranged;
				var dfltDefense     = DragStats[lev].defense;
				var dfltLife        = DragStats[lev].life;
				var dfltRange       = DragStats[lev].range;
				var dfltSpeed       = DragStats[lev].speed;
			}
			catch(e){
				actionLog(translate('Troops statistics for') + ' ' + translate(Names.troops.byName[unit][1]) + ': ' + e.msg + ' ' + translate('Manifest not available, using defaults'));
			}
			src[unit].meleeDamage = dfltMeleeDamage;
			src[unit].rangeDamage = dfltRangeDamage;
			src[unit].defense     = dfltDefense;
			src[unit].life        = dfltLife;
			src[unit].range       = dfltRange;
			src[unit].speed       = dfltSpeed;
		}

		if (Data.options.calculator.ownStatus == 0) { // Player is attacking
			// Attacker's research
			var attRapidDeployment	 = isEmpty(Seed.player.research['RapidDeployment'],0);
			var attWeaponCalibration = isEmpty(Seed.player.research['Ballistics'],0);
			var attMedicine			 = isEmpty(Seed.player.research['Medicine'],0);
			var attMetallurgy		 = isEmpty(Seed.player.research['Metallurgy'],0);
			var attDragonry			 = isEmpty(Seed.player.research['Dragonry'],0);
			var attAerialCombat		 = isEmpty(Seed.player.research['AerialCombat'],0);
			// Defender's research
			var defRapidDeployment	 = Data.options.calculator.data.ennemyResearch['RapidDeployment'];
			var defWeaponCalibration = Data.options.calculator.data.ennemyResearch['Ballistics'];
			var defMedicine			 = Data.options.calculator.data.ennemyResearch['Medicine'];
			var defMetallurgy		 = Data.options.calculator.data.ennemyResearch['Metallurgy'];
			var defDragonry			 = Data.options.calculator.data.ennemyResearch['Dragonry'];
			var defAerialCombat		 = Data.options.calculator.data.ennemyResearch['AerialCombat'];
		} else {
			// Attacker's research
			var attRapidDeployment	 = Data.options.calculator.data.ennemyResearch['RapidDeployment'];
			var attWeaponCalibration = Data.options.calculator.data.ennemyResearch['Ballistics'];
			var attMedicine			 = Data.options.calculator.data.ennemyResearch['Medicine'];
			var attMetallurgy		 = Data.options.calculator.data.ennemyResearch['Metallurgy'];
			var attDragonry			 = Data.options.calculator.data.ennemyResearch['Dragonry'];
			var attAerialCombat		 = Data.options.calculator.data.ennemyResearch['AerialCombat'];
			// Defender's research
			var defRapidDeployment	 = isEmpty(Seed.player.research['RapidDeployment'],0);
			var defWeaponCalibration = isEmpty(Seed.player.research['Ballistics'],0);
			var defMedicine			 = isEmpty(Seed.player.research['Medicine'],0);
			var defMetallurgy		 = isEmpty(Seed.player.research['Metallurgy'],0);
			var defDragonry			 = isEmpty(Seed.player.research['Dragonry'],0);
			var defAerialCombat		 = isEmpty(Seed.player.research['AerialCombat'],0);
		}

		//logit ('attRapidDeployment : '+Data.options.calculator.data.ennemyResearch['RapidDeployment']);
		//logit ('attWeaponCalibration : '+Data.options.calculator.data.ennemyResearch['Ballistics']);
		//logit ('attMedicine : '+Data.options.calculator.data.ennemyResearch['Medicine']);
		//logit ('attMetallurgy : '+Data.options.calculator.data.ennemyResearch['Metallurgy']);
		//logit ('attDragonry : '+Data.options.calculator.data.ennemyResearch['Dragonry']);
		//logit ('attAerialCombat : '+Data.options.calculator.data.ennemyResearch['AerialCombat']);

		//logit ('defRapidDeployment : '+isEmpty(Seed.player.research['RapidDeployment'],0));
		//logit ('defWeaponCalibration : '+isEmpty(Seed.player.research['Ballistics'],0));
		//logit ('defMedicine : '+isEmpty(Seed.player.research['Medicine'],0));
		//logit ('defMetallurgy : '+isEmpty(Seed.player.research['Metallurgy'],0));
		//logit ('defDragonry : '+isEmpty(Seed.player.research['Dragonry'],0));
		//logit ('defAerialCombat : '+isEmpty(Seed.player.research['AerialCombat'],0));

		// Load troop statistics from manifest
		for (var i=0; i<t.troopList.length; i++){
			if ((t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') && 
				(t.troopList[i] != 'StoneDragon') && (t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon')) {
				var dfltMeleeDamage = t.troopDefault[t.troopList[i]].meleeDamage;
				var dfltRangeDamage = t.troopDefault[t.troopList[i]].rangeDamage;
				var dfltDefense     = t.troopDefault[t.troopList[i]].defense;
				var dfltLife        = t.troopDefault[t.troopList[i]].life;
				var dfltRange       = t.troopDefault[t.troopList[i]].range;
				var dfltSpeed       = t.troopDefault[t.troopList[i]].speed;
				try {
					var dfltMeleeDamage = Seed.stats.unit[Names.troops.byName[t.troopList[i]][1]].melee;
					var dfltRangeDamage = Seed.stats.unit[Names.troops.byName[t.troopList[i]][1]].ranged;
					var dfltDefense     = Seed.stats.unit[Names.troops.byName[t.troopList[i]][1]].defense;
					var dfltLife        = Seed.stats.unit[Names.troops.byName[t.troopList[i]][1]].life;
					var dfltRange       = Seed.stats.unit[Names.troops.byName[t.troopList[i]][1]].range;
					var dfltSpeed       = Seed.stats.unit[Names.troops.byName[t.troopList[i]][1]].speed;
				}
				catch(e){
					actionLog(translate('Troops statistics for') + ' ' + translate(Names.troops.byName[t.troopList[i]][1]) + ': ' + e.msg + ' ' + translate('Manifest not available, using defaults'));
				}
				t.troopDefault[t.troopList[i]].meleeDamage = dfltMeleeDamage;
				t.troopDefault[t.troopList[i]].rangeDamage = dfltRangeDamage;
				t.troopDefault[t.troopList[i]].defense     = dfltDefense;
				t.troopDefault[t.troopList[i]].life        = dfltLife;
				t.troopDefault[t.troopList[i]].range       = dfltRange;
				t.troopDefault[t.troopList[i]].speed       = dfltSpeed;
			}
		}

		// Main initialization
		for (var i=0; i<t.troopList.length; i++){
			var dfltMeleeDamage = t.troopDefault[t.troopList[i]].meleeDamage;
			var dfltRangeDamage = t.troopDefault[t.troopList[i]].rangeDamage;
			var dfltDefense     = t.troopDefault[t.troopList[i]].defense;
			var dfltLife        = t.troopDefault[t.troopList[i]].life;
			var dfltRange       = t.troopDefault[t.troopList[i]].range;
			var dfltSpeed       = t.troopDefault[t.troopList[i]].speed;
			if ((t.troopList[i] == 'GreatDragon') || (t.troopList[i] == 'WaterDragon') ||
				(t.troopList[i] == 'StoneDragon') || (t.troopList[i] == 'FireDragon') || (t.troopList[i] == 'WindDragon') )
				loadGreatDragonStats (Data.options.calculator.data.attackUnits, t.troopList[i], Data.options.calculator.attDragLevel);
			// Attack troops initialization : Set characteristics based on default characteristics + research upgrades
			switch (t.troopList[i]) {
				case 'SwiftStrikeDragon':
				case 'PackDragon' :
				case 'BattleDragon' : var speedmultiplier = attDragonry; break;
				case 'GreatDragon' :
				case 'WaterDragon' :
				case 'StoneDragon' :
				case 'FireDragon' : 
				case 'WindDragon' : var speedmultiplier = attAerialCombat; break;
				default: var speedmultiplier = attRapidDeployment; break;
			}
			Data.options.calculator.data.attackUnits[t.troopList[i]].meleeDamage = applyUpgrade (dfltMeleeDamage, (5 * attMetallurgy));
			Data.options.calculator.data.attackUnits[t.troopList[i]].rangeDamage = applyUpgrade (dfltRangeDamage, (5 * attMetallurgy));
			Data.options.calculator.data.attackUnits[t.troopList[i]].defense     = applyUpgrade (dfltDefense, (5 * attMetallurgy));
			Data.options.calculator.data.attackUnits[t.troopList[i]].life        = applyUpgrade (dfltLife, (5 * attMedicine));
			Data.options.calculator.data.attackUnits[t.troopList[i]].range       = applyUpgrade (dfltRange, (5 * attWeaponCalibration));
			Data.options.calculator.data.attackUnits[t.troopList[i]].speed       = applyUpgrade (dfltSpeed, (5 * speedmultiplier));
			// Items modifiers
			for (var itm=0; itm<t.itemList.length; itm++){
				switch (t.itemList[itm]) {
					case 'DragonHearts' :
						if ((Data.options.calculator.data.attackItems[itm]) &&
							(t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') && 
							(t.troopList[i] != 'StoneDragon') && (t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon')) {
							Data.options.calculator.data.attackUnits[t.troopList[i]].meleeDamage = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].meleeDamage, 20);
							Data.options.calculator.data.attackUnits[t.troopList[i]].rangeDamage = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].rangeDamage, 20);
						}
						break;
					case 'GlowingShields' : 
						if ((Data.options.calculator.data.attackItems[itm]) &&
							(t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') && 
							(t.troopList[i] != 'StoneDragon') && (t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon')) {
							Data.options.calculator.data.attackUnits[t.troopList[i]].defense = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].defense, 20);
						}
						break;
					case 'PurpleBones' : 
						if ((Data.options.calculator.data.attackItems[itm]) &&
							(t.troopList[i] == 'GreatDragon') || (t.troopList[i] == 'WaterDragon') ||
							(t.troopList[i] == 'StoneDragon') || (t.troopList[i] == 'FireDragon') || (t.troopList[i] == 'WindDragon')) {
							Data.options.calculator.data.attackUnits[t.troopList[i]].defense = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].defense, 20);
						}
						break;
					case 'CrimsonBull' : 
						if ((Data.options.calculator.data.attackItems[itm]) &&
							(t.troopList[i] == 'GreatDragon') || (t.troopList[i] == 'WaterDragon') ||
							(t.troopList[i] == 'StoneDragon') || (t.troopList[i] == 'FireDragon') || (t.troopList[i] == 'WindDragon')) {
							Data.options.calculator.data.attackUnits[t.troopList[i]].meleeDamage = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].meleeDamage, 20);
							Data.options.calculator.data.attackUnits[t.troopList[i]].rangeDamage = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].rangeDamage, 20);
						}
						break;
					default:break;
				}
			}
			// General upgrades
			var genPrct = Data.options.calculator.attGeneral * 4;
			Data.options.calculator.data.attackUnits[t.troopList[i]].meleeDamage = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].meleeDamage, genPrct);
			Data.options.calculator.data.attackUnits[t.troopList[i]].rangeDamage = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].rangeDamage, genPrct);
			Data.options.calculator.data.attackUnits[t.troopList[i]].defense     = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].defense, genPrct);
			Data.options.calculator.data.attackUnits[t.troopList[i]].life        = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].life, genPrct);
			Data.options.calculator.data.attackUnits[t.troopList[i]].range       = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].range, genPrct);
			Data.options.calculator.data.attackUnits[t.troopList[i]].speed       = applyUpgrade (Data.options.calculator.data.attackUnits[t.troopList[i]].speed, genPrct);

			// Search for max speed
			if ((Data.options.calculator.data.attackUnits[t.troopList[i]].range > maxRange) && (Data.options.calculator.data.attackUnits[t.troopList[i]].qty > 0) &&
				(t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') && (t.troopList[i] != 'StoneDragon') &&
				(t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon'))
				maxRange = Data.options.calculator.data.attackUnits[t.troopList[i]].range;
			t.attackAlives[t.troopList[i]].qty     = Data.options.calculator.data.attackUnits[t.troopList[i]].qty;
			t.attackAlives[t.troopList[i]].defense = Data.options.calculator.data.attackUnits[t.troopList[i]].qty * Data.options.calculator.data.attackUnits[t.troopList[i]].defense;
			t.attackAlives[t.troopList[i]].life    = Data.options.calculator.data.attackUnits[t.troopList[i]].qty * Data.options.calculator.data.attackUnits[t.troopList[i]].life;
			t.attackLosts[t.troopList[i]].qty      = 0;
			t.attackLosts[t.troopList[i]].defense  = 0;
			t.attackLosts[t.troopList[i]].life     = 0;

			// Defense troops initialization : Set characteristics based on default characteristics + research upgrades
			if ((t.troopList[i] == 'GreatDragon') || (t.troopList[i] == 'WaterDragon') ||
				(t.troopList[i] == 'StoneDragon') || (t.troopList[i] == 'FireDragon') || (t.troopList[i] == 'WindDragon') )
				loadGreatDragonStats (Data.options.calculator.data.defenseUnits, t.troopList[i], Data.options.calculator.defDragLevel);
			//if (t.troopList[i] == 'FireDragon') logit ('FireDragon : '+inspectObj(Data.options.calculator.data.defenseUnits[t.troopList[i]]));
			switch (t.troopList[i]) {
				case 'SwiftStrikeDragon':
				case 'PackDragon' :
				case 'BattleDragon' : var speedmultiplier = defDragonry; break;
				case 'GreatDragon' :
				case 'WaterDragon' :
				case 'StoneDragon' :
				case 'FireDragon' : 
				case 'WindDragon' : var speedmultiplier = defAerialCombat; break;
				default: var speedmultiplier = defRapidDeployment; break;
			}
			Data.options.calculator.data.defenseUnits[t.troopList[i]].meleeDamage = applyUpgrade (dfltMeleeDamage, (5 * defMetallurgy));
			Data.options.calculator.data.defenseUnits[t.troopList[i]].rangeDamage = applyUpgrade (dfltRangeDamage, (5 * defMetallurgy));
			Data.options.calculator.data.defenseUnits[t.troopList[i]].defense     = applyUpgrade (dfltDefense, (5 * defMetallurgy));
			Data.options.calculator.data.defenseUnits[t.troopList[i]].life        = applyUpgrade (dfltLife, (5 * defMedicine));
			Data.options.calculator.data.defenseUnits[t.troopList[i]].range       = applyUpgrade (dfltRange, (5 * defWeaponCalibration));
			Data.options.calculator.data.defenseUnits[t.troopList[i]].speed       = applyUpgrade (dfltSpeed, (5 * speedmultiplier));
			// Items modifiers
			for (var itm=0; itm<t.itemList.length; itm++){
				switch (t.itemList[itm]) {
					case 'DragonHearts' :
						if ((Data.options.calculator.data.defenseItems[itm]) &&
							(t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') && 
							(t.troopList[i] != 'StoneDragon') && (t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon')) {
							Data.options.calculator.data.defenseUnits[t.troopList[i]].meleeDamage = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].meleeDamage, 20);
							Data.options.calculator.data.defenseUnits[t.troopList[i]].rangeDamage = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].rangeDamage, 20);
						}
						break;
					case 'GlowingShields' : 
						if ((Data.options.calculator.data.defenseItems[itm]) &&
							(t.troopList[i] != 'GreatDragon') && (t.troopList[i] != 'WaterDragon') &&
							(t.troopList[i] != 'StoneDragon') && (t.troopList[i] != 'FireDragon') && (t.troopList[i] != 'WindDragon')) {
							Data.options.calculator.data.defenseUnits[t.troopList[i]].defense     = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].defense, 20);
						}
						break;
					case 'PurpleBones' : 
						if ((Data.options.calculator.data.defenseItems[itm]) &&
							(t.troopList[i] == 'GreatDragon') || (t.troopList[i] == 'WaterDragon') ||
							(t.troopList[i] == 'StoneDragon') || (t.troopList[i] == 'FireDragon') || (t.troopList[i] == 'WindDragon')) {
							Data.options.calculator.data.defenseUnits[t.troopList[i]].defense     = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].defense, 20);
						}
						break;
					case 'CrimsonBull' : 
						if ((Data.options.calculator.data.defenseItems[itm]) &&
							(t.troopList[i] == 'GreatDragon') || (t.troopList[i] == 'WaterDragon') ||
							(t.troopList[i] == 'StoneDragon') || (t.troopList[i] == 'FireDragon') || (t.troopList[i] == 'WindDragon')) {
							Data.options.calculator.data.defenseUnits[t.troopList[i]].meleeDamage = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].meleeDamage, 20);
							Data.options.calculator.data.defenseUnits[t.troopList[i]].rangeDamage = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].rangeDamage, 20);
						}
						break;
					default:break;
				}
			}
			// General upgrades
			var genPrct = Data.options.calculator.defGeneral * 4;
			Data.options.calculator.data.defenseUnits[t.troopList[i]].meleeDamage = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].meleeDamage, genPrct);
			Data.options.calculator.data.defenseUnits[t.troopList[i]].rangeDamage = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].rangeDamage, genPrct);
			Data.options.calculator.data.defenseUnits[t.troopList[i]].defense     = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].defense, genPrct);
			Data.options.calculator.data.defenseUnits[t.troopList[i]].life        = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].life, genPrct);
			Data.options.calculator.data.defenseUnits[t.troopList[i]].range       = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].range, genPrct);
			Data.options.calculator.data.defenseUnits[t.troopList[i]].speed       = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].speed, genPrct);
			// Wall upgrades
			var wallPrct = Data.options.calculator.defWall * (105 / 100);
			Data.options.calculator.data.defenseUnits[t.troopList[i]].defense     = applyUpgrade (Data.options.calculator.data.defenseUnits[t.troopList[i]].defense, wallPrct);
			t.defenseAlives[t.troopList[i]].qty     = Data.options.calculator.data.defenseUnits[t.troopList[i]].qty;
			t.defenseAlives[t.troopList[i]].defense = Data.options.calculator.data.defenseUnits[t.troopList[i]].qty * Data.options.calculator.data.defenseUnits[t.troopList[i]].defense;
			t.defenseAlives[t.troopList[i]].life    = Data.options.calculator.data.defenseUnits[t.troopList[i]].qty * Data.options.calculator.data.defenseUnits[t.troopList[i]].life;
			t.defenseLosts[t.troopList[i]].qty      = 0;
			t.defenseLosts[t.troopList[i]].defense  = 0;
			t.defenseLosts[t.troopList[i]].life     = 0;
		}

		// Initialize terrain length and defense unit position
		t.terrainLength = 500 + maxRange;
		t.log ('', translate('Terrain length set to ') + t.terrainLength, '<b>'+translate('Start')+'</b>');
		for (var i=0; i<t.troopList.length; i++) {
			Data.options.calculator.data.attackUnits[t.troopList[i]].x = 0;
			Data.options.calculator.data.defenseUnits[t.troopList[i]].x = t.terrainLength;

			// if (Data.options.calculator.data.attackUnits[t.troopList[i]].qty > 0)
			// 	logit ('attackAlives[t.troopList[i]] : '+t.troopList[i]+' : '+inspectObj(t.attackAlives[t.troopList[i]]));
			// 	logit ('attackUnits[t.troopList[i]] : '+t.troopList[i]+' : '+inspectObj(Data.options.calculator.data.attackUnits[t.troopList[i]]));
			// if (Data.options.calculator.data.defenseUnits[t.troopList[i]].qty > 0)
			// 	logit ('defenseUnits[t.troopList[i]] : '+t.troopList[i]+' : '+inspectObj(Data.options.calculator.data.defenseUnits[t.troopList[i]]));
		}
		Data.options.calculator.battleTurn = 0;

		// Do battle turns
		while (!t.battleStop) {
			Data.options.calculator.battleTurn++;
			t.log (translate('<B>Attacker\'s move turn</B>'), '', '<B>' + Data.options.calculator.battleTurn + '</B>');
			t.attackMoveTurn ();
			t.log (translate('<B>Attacker\'s attack turn</B>'), '', '');
			t.attackTurn ();
			if (!t.battleStop) {
				t.log (translate('<B>Defender\'s move turn</B>'), '', '');
				t.defenseMoveTurn ();
				t.log (translate('<B>Defender\'s attack turn</B>'), '', '');
				t.defenseTurn ();
				t.log ('', '', '');
			}
		}
		var winner = translate('Battle lost !!');
		if (t.battleWinner == Data.options.calculator.ownStatus)
			winner = translate('Battle won !!');
		t.log ('<span class=' + UID['red'] + '>' + winner + '</span>', '', '<b>'+translate('End')+'</b>');
	},

	attackTurn : function () {
		var t = Tabs.Battle;
		var boolExists = true;
		t.logLine = '';
		// For each unit type
		for (var i=0; i<t.meleeListByPrior.length; i++) {
			var attPos = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].x;
			var attQty = t.attackAlives[t.meleeListByPrior[i]].qty;
			var attSpeed = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].speed;
			var attRange = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].range;
			var attMaxMeleeDamage = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].meleeDamage * attQty;
			var attMaxRangeDamage = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].rangeDamage * attQty;
			// if troop number = 0, nothing to do
			if (attQty > 0) {
				// Check again if ennemy troops in attack range. If troops in range, then attack it.
				if (t.checkInAttackRange ((attRange + attPos), Data.options.calculator.data.defenseUnits, t.defenseAlives)) {
					t.dealDamage ('A', t.meleeListByPrior[i], attPos, attRange, attMaxMeleeDamage, attMaxRangeDamage, Data.options.calculator.data.defenseUnits, t.defenseAlives, t.defenseLosts);
				}
				if (t.logLine != '') t.log ('', t.logLine, '');
				t.logLine = '';
			}
		}
		// Check for survival ennemy units
		boolExists = false;
		for (i=0; i<t.troopList.length; i++) {
			var nCount = t.defenseAlives[t.troopList[i]].qty;
			if (nCount > 0){
				boolExists = true;
				return;
			}
		}
		if (!boolExists){
			t.battleStop = true;
			t.battleWinner = 0;
		}
	},

	attackMoveTurn : function () {
		var t = Tabs.Battle;
		var boolExists = true;
		t.logLine = '';
		// For each unit type
		for (var i=0; i<t.meleeListByPrior.length; i++) {
			var attPos = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].x;
			var attQty = t.attackAlives[t.meleeListByPrior[i]].qty;
			var attSpeed = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].speed;
			var attRange = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].range;
			var attMeleeDmg = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].meleeDamage;
			var attRangeDmg = Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].rangeDamage;
			// if troop number = 0, nothing to do
			if (attQty > 0) {
				// get closest ennemy's position
				var minPos = t.terrainLength;
				for (var m=0; m<t.meleeListByPrior.length; m++) {
					if ((Data.options.calculator.data.defenseUnits[t.troopList[m]].x < minPos) && (t.defenseAlives[t.troopList[m]].qty > 0))
						minPos = Data.options.calculator.data.defenseUnits[t.troopList[m]].x;
				}
				if (attMeleeDmg > attRangeDmg) attRange = 0;
				// Check if ennemy troops in attack range. If no troops in range, move forward.
				if ((!t.checkInAttackRange ((attRange + attPos), Data.options.calculator.data.defenseUnits, t.defenseAlives)) && (attPos < t.terrainLength)) {
					if ((attPos + attSpeed) > minPos)
						attPos = minPos;
					else {  // other case, troop is avancing at normal speed
						attPos = attPos + attSpeed;
					}
					if (attPos > t.terrainLength) attPos = t.terrainLength;
					Data.options.calculator.data.attackUnits[t.meleeListByPrior[i]].x = attPos;
					t.logLine = translate(Names.troops.byName[t.meleeListByPrior[i]][1]) + translate(' move to ') + attPos;
				}
				if (t.logLine != '') t.log ('', t.logLine, '');
				t.logLine = '';
			}
		}
	},

	checkInAttackRange : function (range, trplist, trpAlives) {
		var t = Tabs.Battle;
		var exists = false;
		// For each unit type
		for (var r=0; r<t.troopList.length; r++) {
			var trpPos = trplist[t.troopList[r]].x;
			var trpQty = trpAlives[t.troopList[r]].qty;
			if (trpPos <= range && trpQty > 0) {
				exists = true;
				// return;
			}
		}
		return exists;
	},

	dealDamage : function (who, attacker, pos, range, mDamage, rDamage, trplist, trpAlives, trpLosts) {
		var t = Tabs.Battle;
		var done = false;
		var melee = false;
		var meleeHits = mDamage;
		var rangeHits = rDamage;
		var left = (t.logLine == '') ? translate(Names.troops.byName[attacker][1]) : ',';
		// For each unit type, deal first melee damages if any
		for (var i=0; i<t.meleeListByPrior.length; i++) {
			var nLosts = 0;
			if (!done) {
				var trpRemainQty  = trpAlives[t.meleeListByPrior[i]].qty;
				var trpRemainDef  = trpAlives[t.meleeListByPrior[i]].defense;
				var trpRemainLife = trpAlives[t.meleeListByPrior[i]].life;
				var trpPos  = trplist[t.meleeListByPrior[i]].x;
				var trpDef  = trplist[t.meleeListByPrior[i]].defense;
				var trpLife = trplist[t.meleeListByPrior[i]].life;
				if ((trpPos <= pos && trpRemainLife > 0 && who == 'A') ||
					(trpPos >= pos && trpRemainLife > 0 && who == 'D')) { // Troops are in contact => Deal melee damages
					melee = true;
					if (meleeHits >= trpRemainDef){
						var realDamage = trpRemainDef;
						trpRemainDef = 0;
					} else {
						var realDamage = meleeHits;
						trpRemainDef = trpRemainDef - meleeHits;
					}
					trpAlives[t.meleeListByPrior[i]].defense = trpRemainDef;
					trpLosts[t.meleeListByPrior[i]].defense  = trpLosts[t.meleeListByPrior[i]].defense  + realDamage;
					meleeHits = meleeHits - realDamage;
					if (meleeHits > 0) {
						if (meleeHits >= trpRemainLife){
							realDamage    = realDamage + trpRemainLife;
							meleeHits     = meleeHits - trpRemainLife;
							nLosts        = trpAlives[t.meleeListByPrior[i]].qty;
							trpAlives[t.meleeListByPrior[i]].life = 0;
							trpLosts[t.meleeListByPrior[i]].life = trpLosts[t.meleeListByPrior[i]].life + trpRemainLife;
							trpRemainLife = 0;
						} else {
							realDamage    = realDamage + meleeHits;
							trpRemainLife = trpRemainLife - meleeHits;
							nLosts        = Math.round (meleeHits / trpLife);
							trpAlives[t.meleeListByPrior[i]].life = trpRemainLife;
							trpLosts[t.meleeListByPrior[i]].life  = trpLosts[t.meleeListByPrior[i]].life  + meleeHits;
							meleeHits     = 0;
						}
					}
					if (realDamage > 0)
						t.logLine += left + translate(' deal ') + nombreFormate(realDamage,' ') + translate(' damages to ') + translate(Names.troops.byName[t.meleeListByPrior[i]][1]) + translate(' in melee');
					if (meleeHits > 0) {
						done = false;
						left = ',';
					} else done = true;
				}
				if (nLosts > 0) {
					trpAlives[t.meleeListByPrior[i]].qty = trpAlives[t.meleeListByPrior[i]].qty - nLosts;
					trpLosts[t.meleeListByPrior[i]].qty  = trpLosts[t.meleeListByPrior[i]].qty + nLosts;
					t.logLine += translate(' (kill ') + nombreFormate(nLosts,' ') + ', ' + nombreFormate(trpAlives[t.meleeListByPrior[i]].qty,' ') + translate(' survivals)');
				}
			}
		}
		if (!melee) {
			// For each unit type, deal range damages if any and if no melee damages done
			for (var i=0; i<t.rangeListByPrior.length; i++) {
				var nLosts = 0;
				if (!done) {
					var trpRemainQty  = trpAlives[t.rangeListByPrior[i]].qty;
					var trpRemainDef  = trpAlives[t.rangeListByPrior[i]].defense;
					var trpRemainLife = trpAlives[t.rangeListByPrior[i]].life;
					var trpPos  = trplist[t.rangeListByPrior[i]].x;
					var trpDef  = trplist[t.rangeListByPrior[i]].defense;
					var trpLife = trplist[t.rangeListByPrior[i]].life;
					if (((trpPos <= (pos + range)) && (trpRemainLife > 0) && (rDamage > 0) && (who == 'A')) ||
						((trpPos >= (pos - range)) && (trpRemainLife > 0) && (rDamage > 0) && (who == 'D'))) { // Troops are in range but not close  => Deal range damages
						if (rangeHits >= trpRemainDef){
							var realDamage = trpRemainDef;
							trpRemainDef = 0;
						} else {
							var realDamage = rangeHits;
							trpRemainDef = trpRemainDef - rangeHits;
						}
						trpAlives[t.rangeListByPrior[i]].defense = trpRemainDef;
						trpLosts[t.rangeListByPrior[i]].defense  = trpLosts[t.rangeListByPrior[i]].defense  + realDamage;
						rangeHits = rangeHits - realDamage;
						if (rangeHits > 0) {
							if (rangeHits >= trpRemainLife){
								realDamage    = realDamage + trpRemainLife;
								rangeHits     = rangeHits - trpRemainLife;
								nLosts        = trpAlives[t.rangeListByPrior[i]].qty;
								trpAlives[t.rangeListByPrior[i]].life = 0;
								trpLosts[t.rangeListByPrior[i]].life = trpLosts[t.rangeListByPrior[i]].life + trpRemainLife;
								trpRemainLife = 0;
							} else {
								realDamage    = realDamage + rangeHits;
								trpRemainLife = trpRemainLife - rangeHits;
								nLosts        = Math.round (rangeHits / trpLife);
								trpAlives[t.rangeListByPrior[i]].life = trpRemainLife;
								trpLosts[t.rangeListByPrior[i]].life  = trpLosts[t.rangeListByPrior[i]].life  + rangeHits;
								rangeHits     = 0;
							}
						}
						if (realDamage > 0)
							t.logLine += left + translate(' deal ') + nombreFormate(realDamage,' ') + translate(' damages to ') + translate(Names.troops.byName[t.rangeListByPrior[i]][1]) + translate(' at range');
						if (rangeHits > 0) {
							done = false;
							left = ',';
						} else done = true;
					}
					if (nLosts > 0) {
						trpAlives[t.rangeListByPrior[i]].qty = trpAlives[t.rangeListByPrior[i]].qty - nLosts;
						trpLosts[t.rangeListByPrior[i]].qty  = trpLosts[t.rangeListByPrior[i]].qty + nLosts;
						t.logLine += translate(' (kill ') + nombreFormate(nLosts,' ') + ', ' + nombreFormate(trpAlives[t.rangeListByPrior[i]].qty,' ') + translate(' survivals)');
					}
				}
			}
		}
	},

	defenseTurn : function () {
		var t = Tabs.Battle;
		var boolExists = true;
		t.logLine = '';
		// For each unit type
		for (var i=0; i<t.meleeListByPrior.length; i++) {
			var defPos = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].x;
			var defQty = t.defenseAlives[t.meleeListByPrior[i]].qty;
			var defSpeed = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].speed;
			var defRange = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].range;
			var defMaxMeleeDamage = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].meleeDamage * defQty;
			var defMaxRangeDamage = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].rangeDamage * defQty;
			// if troop number = 0, nothing to do
			if (defQty > 0) {
				// Check if ennemy troops in attack range. If troops in range, then attack it.
				if (t.checkInDefenseRange ((defPos - defRange), Data.options.calculator.data.attackUnits, t.attackAlives)) {
					t.dealDamage ('D', t.meleeListByPrior[i], defPos, defRange, defMaxMeleeDamage, defMaxRangeDamage, Data.options.calculator.data.attackUnits, t.attackAlives, t.attackLosts);
				}
				if (t.logLine != '') t.log ('', t.logLine, '');
				t.logLine = '';
			}
		}
		// Check for survival ennemy units
		boolExists = false;
		for (i=0; i<t.troopList.length; i++) {
			var nCount = t.attackAlives[t.troopList[i]].qty;
			if (nCount > 0){
				boolExists = true;
				return;
			}
		}
		if (!boolExists){
			t.battleStop = true;
			t.battleWinner = 1;
		}
	},

	defenseMoveTurn : function () {
		var t = Tabs.Battle;
		var boolExists = true;
		t.logLine = '';
		// For each unit type
		for (var i=0; i<t.meleeListByPrior.length; i++) {
			var defPos = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].x;
			var defQty = t.defenseAlives[t.meleeListByPrior[i]].qty;
			var defSpeed = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].speed;
			var defRange = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].range;
			var defMeleeDmg = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].meleeDamage;
			var defRangeDmg = Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].rangeDamage;
			// if troop number = 0, nothing to do
			if (defQty > 0) {
				// get closest ennemy's position
				var maxPos = t.terrainLength;
				for (var m=0; m<t.meleeListByPrior.length; m++) {
					if ((Data.options.calculator.data.attackUnits[t.troopList[m]].x > maxPos) && (t.attackAlives[t.troopList[m]].qty > 0))
						maxPos = Data.options.calculator.data.attackUnits[t.troopList[m]].x;
				}
				if (defMeleeDmg > defRangeDmg) defRange = 0;
				// Check if ennemy troops in attack range. If no troops in range, move forward.
				if ((!t.checkInDefenseRange ((defPos - defRange), Data.options.calculator.data.attackUnits, t.attackAlives)) && (defPos > 0)) {
					// get highest x pos from attacker's troops
					if ((defPos - defSpeed) < maxPos) // Defense troop will engage attacker in close combat
						defPos = maxPos;
					else {
						defPos = defPos - defSpeed;
						if (defPos < 0) defPos = 0;
					}
					Data.options.calculator.data.defenseUnits[t.meleeListByPrior[i]].x = defPos;  // Vérifier si on se déplace jusqu'à la troupe à portée la plus proche ou non
					t.logLine = translate(Names.troops.byName[t.meleeListByPrior[i]][1]) + translate(' move to ') + defPos;
				}
				if (t.logLine != '') t.log ('', t.logLine, '');
				t.logLine = '';
			}
		}
	},

	checkInDefenseRange : function (range, trplist, trpAlives) {
		var t = Tabs.Battle;
		var exists = false;
		// For each unit type
		for (var r=0; r<t.troopList.length; r++) {
			var trpPos = trplist[t.troopList[r]].x;
			var trpQty = trpAlives[t.troopList[r]].qty;
			if (trpPos >= range && trpQty > 0) {
				exists = true;
				// return;
			}
		}
		return exists;
	},


	/** BATTLE RULES SUB-TAB ***/
	tabBattleRules : function (){
		var t = Tabs.Battle;
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabBattleRules']).className='selected';
		document.getElementById(UID['tabBattleRules']).style.zIndex=1;
		t.lastSubTab = 'tabBattleRules';

		t.contentType = 3;
		Data.options.calculator.current_tab = t.contentType;
		var m = '<div id=' + setUID('tabBattle_Rules') + '>'
			+'	<div class=' + UID['title'] + '>' + translate('Battle mechanics') + '</div>'
			+'	<div class=' + UID['status_ticker'] + ' style="height:575px; max-height:575px; overflow-y:auto ; overflow-x:auto ; margin-top:1px !important">'
			+'		<table id=' + setUID('tabBattle_RulesTable') + ' class=' + UID['table_console'] + ' cellspacing=1 width=100%>';
			+'			<tr><td><br><div align=left style="color:#000000">';
		if ( navigator.language == 'fr' ) {
		m += 'La longueur du terrain est initialisée à <B>500 + portée maximale des unités offensives</B>.<BR>\
			Si il n\'y a que des unités de coprs-à-corps sélectionnées en attaque, la longueur du terrain sera initialisée à 500.<BR>\
			<BR>\
			Le tour de chaque joueur est composé d\'une phase de déplacement + une phase de combat.<BR>\
			Les unités offensives ont l\'initiative et se déplacent donc en premier.<BR>\
			<BR>\
			<B>Phase de déplacement :</B><BR>\
			- Chaque unité encore en vie va vérifier s\'il existe des unités ennemies à portée (en corps-à-corps ou à distance).\
			- Si aucune unité ennemie à portée, alors elle se déplace.<BR>\
			- S\'il existe au moins une unité ennemie à portée, alors l\'unité ne se déplace pas.<BR>\
			<BR>\
			- Au début du combat les unités offensives commencent à la position 0 ; les unités défensives à la position maximale du terrain (donc à la position égale à la longueur du terrain).<BR>\
			- Chaque unité se déplace de sa vitesse maximale à chaque fois sauf si elle rencontre une unité ennemie avec laquelle elle peut engager un corps-à-corps.<BR>\
			<BR>\
			<B>Phase de combat :</B><BR>\
			- Chaque unité encore en vie va vérifier s\'il existe des unités ennemies à portée (en corps-à-corps ou à distance).\
			- Sìl existe une unité ennemie à portée, l\'attaque est lancée.<BR>\
			<BR>\
			<B>Statistiques des unités :</B><BR>\
			- Objets modificateurs.<BR>\
			- Général.<BR>\
			<BR>\
			<B>Points particuliers :</B><BR>\
			- Utilité des remparts : Franchement ? Là, je vois pas... \
			Après plusieurs tests, les résultats semblent cohérents avec les rapports de bataille réels obtenus.\
			Or comme la simulation ne prend pas en compte le rempart...<BR>\
			- Questions en suspens : Ordre des unités qui subissent les dégâts ? Ordre des unités lors de la phase d\'attaque (qui frappe en premier) ?\
			...';
		}
		m += '</div></td></tr></table></div></div>';
		document.getElementById(UID['tabBattle_Content']).innerHTML = m; 
	},
};
// Jawz *********************************** Battle Simulation Tab *********************************************


// Jawz *********************************** Tower Tab *********************************************
Tabs.Tower = {
	tabOrder	: TOWER_TAB_ORDER,
	tabLabel	: 'Tower',
	tabDisabled	: !TOWER_TAB_ENABLE,
	container	: null,
	alarmTimer	: null,
	deleteTimer	: null,
	fetchTimer	: null,
	logTab		: null,
	maxEntries	: 100,
	saveEntries	: 100,
	readList	: [],

	init : function (div){
		var t = Tabs.Tower;
		//logit('Init : '+inspectObj(Data.options.tower));

		t.container = div;
		var m = '<div class=' + UID['title'] + '>'+ translate('Sentinel tower') +'</div>'
			//+'<div class=' + UID['status_ticker'] + ' id='+ setUID('tabTower_Status') +' style="margin-bottom:5px !important">'
			+'<table class=' + UID['table'] + ' style="color:#000;">'
			+'	<tr valign=top>'
			+'		<td colspan=4><b>' + translate('Tower configuration') + ': </b></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabTower_Alert') + ' type=checkbox /></label></td>'
			+'		<td colspan=2><label>' + translate('Enable the sentinel tower') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td></td><td colspan=2><label>' + translate('Check sentinel reports every ') + '</label>'
			+'		<input id=' + setUID('tabTower_chkTime') + ' size=1 maxlength=2 type=text value="' + Data.options.tower.delay + '" />&nbsp'
			+'		<select id=' + setUID('tabTower_chkUnit') + ' size=1>'
			+'			<option value=1 ' + (Data.options.tower.unit == 1 ? 'selected' : '') + '>' + translate('Seconds') + '</option>'
			+'			<option value=60 ' + (Data.options.tower.unit == 60 ? 'selected' : '') + '>' + translate('Minutes') + '</option>'
			+'			<option value=3600 ' + (Data.options.tower.unit == 3600 ? 'selected' : '') + '>' + translate('Hours') + '</option>'
			+'		</select>'
			+'		</td>'
			+'	</tr><tr valign=top>'
			+'		<td>&nbsp</td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabTower_NoSpy') + ' type=checkbox /></label></td>'
			+'		<td colspan=2><label>' + translate('Hide spy alerts') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabTower_Del') + ' type=checkbox /></label></td>'
			+'		<td colspan=2><label>' + translate('Do not show alerts obsolete since') + ' :</label>'
			+'		<input id=' + setUID('tabTower_DelTime') + ' size=1 maxlength=2 type=text value="' + Data.options.tower.delete_delay + '" />&nbsp'
			+'		<select id=' + setUID('tabTower_DelUnit') + ' size=1>'
			+'			<option value=60 ' + (Data.options.tower.delete_unit == 60 ? 'selected' : '') + '>' + translate('Minutes') + '</option>'
			+'			<option value=3600 ' + (Data.options.tower.delete_unit == 3600 ? 'selected' : '') + '>' + translate('Hours') + '</option>'
			+'			<option value=86400 ' + (Data.options.tower.delete_unit == 86400 ? 'selected' : '') + '>' + translate('Days') + '</option>'
			+'		</select>'
			+'		</td>'
			+'	</tr>'
			+'</table>'
			+'<br>'
			+'<table class=' + UID['table'] + ' style="color:#000;">'
			+'	<tr valign=top>'
			+'		<td colspan=4><b>' + translate('Sound configuration') + ': </b></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabTower_Sound') + ' type=checkbox '+ (Data.options.tower.play_sound?'CHECKED ':'') +'/></label></td>'
			+'		<td><label>' + translate('Play sound on incoming sentinel report') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td></td>'
			+'		<td><table cellpadding=0 cellspacing=0>'
			+'				<tr valign=top>'
			+'					<td><label>' + translate('Sound file') + '</label></td>'
			+'					<td><input id=' + setUID('tabTower_File') + ' size=50 maxlength=160 type=text value="' + Data.options.tower.sound_url + '" />&nbsp</td>'
			+'					<td><input id=' + setUID('tabTower_Play') + ' type=submit value=Play>'
			+'						<input id=' + setUID('tabTower_Stop') + ' type=submit value=Stop>'
			+'						<input id=' + setUID('tabTower_Default') + ' type=submit value=Default></td>'
			+'				</tr>'
			+'			</table>'
			+'		</td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabTower_Repeat') + ' type=checkbox '+ (Data.options.tower.repeat?'CHECKED ':'') +'/></label></td>'
			+'		<td><table cellpadding=0 cellspacing=0>'
			+'				<tr valign=top>'
			+'					<td><label>' + translate('Repeat every') + ' </label>'
			+'						<input id=' + setUID('tabTower_Every') + ' size=2 maxlength=5 type=text value="' + Data.options.tower.repeat_delay + '" />' + translate('minutes') + '</td>'
			+'					<td width="5px"></td>'
			+'					<td><label>' + translate('Play for') + ' </label>'
			+'						<input id=' + setUID('tabTower_Length') + ' size=3 maxlength=5 type=text value="' + Data.options.tower.play_length + '" />' + translate('seconds') + '</td>'
			+'				</tr>'
			+'			</table>'
			+'		</td>'
			+'	</tr>'
			+'</table>'
			//+'</div>'
			+'<br>'
			+'<div class=' + UID['title'] + '>' + translate('Alerts log') + '</div>'
			+'<div id=' + setUID('tabTower_LogList') + ' class=' + UID['status_ticker'] + ' style="height:465px; max-height:465px; overflow-y:auto ; overflow-x:auto ; margin-top:1px !important">'
			+'	<table id=' + setUID('tabTower_Log') + ' class=' + UID['table_console'] + ' cellpadding=0 cellspacing=1 width=100%>'
			+'	</table>'
			+'</div>'
			+'<div id=' + setUID('tabTower_SwfPlayer') + '></div>';

		t.container.innerHTML = m;
		t.logTab = document.getElementById(UID['tabTower_Log']);
		Data.options.messages_tower = [];
		t.printTab();  
		t.togOpt (UID['tabTower_Alert'], Data.options.tower.enabled, t.setEnable);
		t.togOpt (UID['tabTower_NoSpy'], Data.options.tower.nospy, t.setEnableNoSpy);
		t.togOpt (UID['tabTower_Del'], Data.options.tower.delete_report, t.setDeleteReport);
		document.getElementById(UID['tabTower_chkTime']).addEventListener ('change', t.timeChanged, false);
		document.getElementById(UID['tabTower_chkUnit']).addEventListener ('change', t.unitChanged, false);
		document.getElementById(UID['tabTower_DelTime']).addEventListener ('change', t.timeDeleteChanged, false);
		document.getElementById(UID['tabTower_DelUnit']).addEventListener ('change', t.unitDeleteChanged, false);
		t.deleteTick();
		t.alarmTick();

		document.getElementById(UID['tabTower_Sound']).addEventListener ('change', function (e){Data.options.tower.play_sound = e.target.checked}, false);
		document.getElementById(UID['tabTower_Repeat']).addEventListener ('change', function (e){Data.options.tower.repeat = e.target.checked}, false);
		document.getElementById(UID['tabTower_Every']).addEventListener ('change', function (e){Data.options.tower.repeat_delay = e.target.value}, false);
		document.getElementById(UID['tabTower_Length']).addEventListener ('change', function (e){Data.options.tower.play_length = e.target.value}, false);
		document.getElementById(UID['tabTower_File']).addEventListener ('change', function (){Data.options.tower.sound_url = document.getElementById(UID['tabTower_File']).value}, false);
		document.getElementById(UID['tabTower_Play']).addEventListener ('click', t.playSound, false);
		document.getElementById(UID['tabTower_Stop']).addEventListener ('click', t.stopSound, false);
		document.getElementById(UID['tabTower_Default']).addEventListener ('click', function (){
			document.getElementById(UID['tabTower_File']).value = DEFAULT_ALERT_SOUND_URL;
			Data.options.tower.sound_url = DEFAULT_ALERT_SOUND_URL;
			t.playSound;
			}, false);
		document.getElementById(UID['tabTower_Stop']).disabled = true;
		window.addEventListener('unload', t.onUnload, false);
	},

	onUnload : function (){
		var t = Tabs.Tower;
		logit ('===============  Tabs.Battle.onUnload');
		logit(inspectObj(Data.options.tower));
	},

	hide : function (){
	},
  
	show : function (){
	},

	printTab : function () {
		var t = Tabs.Tower;
		t.logTab.innerHTML = '';
		t._addTab ('', true);
		for (var i=0; i<Data.options.messages_tower.length; i++)
			t._addTab (Data.options.messages_tower[i], false);
	},
 
	_addTab : function (msg, head){
		var t = Tabs.Tower;
		if (!head &&Data.options.tower.nospy && msg.type == 1)
			return;
		var rows = t.logTab.getElementsByTagName('tr');
		var rowCount = rows.length;
		var row = t.logTab.insertRow((head==true? 0 : 1));
		row.vAlign = 'top';
		if (head) {
			row.id = 0;
			row.className = UID['row_headers'];
//			row.style.backgroundColor = "rgb(90,95,115)";
//			row.style.textAlign = "center";
//			row.style.lineHeight = "11pt";
		} else {
			if (rowCount % 2 == 1) row.style.backgroundColor = "White";
			else row.style.backgroundColor = "rgb(239,239,224)";
			row.id = msg.id;
		}
		var cell;
		var txt;
		for (var i=0;i<5;i++)
		{
			cell = row.insertCell(i);
			if (head) {
				switch (i) {
					case 0: txt = translate('Type'); break;
					case 1: txt = translate('Arrival time'); break;
					case 2: txt = translate('Attacker'); break;
					case 3: txt = translate('Alliance'); break;
					default: txt = translate('Troops'); break;
				}
			} else {
				switch (i) {
					case 0: txt = (msg.type == 0 ? translate('Attack') : translate('Spy')); break;
					case 1: if (msg.arrive_at != 0) txt = new Date(msg.arrive_at).formatDate() + ' ' + new Date(msg.arrive_at).formatTime();
							else txt = '';
							break;
					case 2: if (msg.x != -1) txt = msg.x+','+msg.y;
							else txt = '';
							break;
					case 3: txt = msg.alliance; break;
					default: txt = msg.troups; break;
				}
			}
			cell.innerHTML = txt;
			if (i>2) cell.width = '30%';
			else if (i==2) cell.width = '10%';
			else cell.width = '15%';
			if (head) {
				cell.style.fontWeight = 'bold';
//				cell.style.color = 'White';
//				cell.style.borderRight = "2px solid #eef";
//				cell.style.lineHeight = "11pt";
			} else {
				cell.style.fontWeight = 'normal';
				cell.style.color = 'Black';
			}
		}
	}, 

	removeRow : function (msg) {
		var t = Tabs.Tower;
		for (var i=0;i<t.logTab.rows.length;i++) {
			if (t.logTab.rows[i].id == msg.id) {
				t.logTab.deleteRow(i);
				break;
			}
		}
	},

	setEnable : function (onOff){
		var t = Tabs.Tower;
		Data.options.tower.enabled = onOff;
		if (Data.options.tower.enabled) t.alarmTick();
	},
  
	setEnableNoSpy : function (onOff){
		var t = Tabs.Tower;
		Data.options.tower.nospy = onOff;
		t.printTab();
	},
  
	setDeleteReport : function (onOff){
		var t = Tabs.Tower;
		Data.options.tower.delete_report = onOff;
		t.deleteTick();
	},

	timeChanged : function (e){
		var t = Tabs.Tower;
		var etime = document.getElementById(UID['tabTower_chkTime']);
		var time = parseIntZero (etime.value);
		etime.value = time;
		Data.options.tower.delay = time;
		t.alarmTick();
	},
  
	unitChanged : function (e){
		var t = Tabs.Tower;
		var eunit = document.getElementById(UID['tabTower_chkUnit']);
		var unit = parseIntZero (eunit.value);
		eunit.value = unit;
		Data.options.tower.unit = unit;
		t.alarmTick();
	},
  
	timeDeleteChanged : function (e){
		var t = Tabs.Tower;
		var etime = document.getElementById(UID['tabTower_DelTime']);
		var time = parseIntZero (etime.value);
		etime.value = time;
		Data.options.tower.delete_delay = time;
		t.deleteTick();
	},
 
	unitDeleteChanged : function (e){
		var t = Tabs.Tower;
		var eunit = document.getElementById(UID['tabTower_DelUnit']);
		var unit = parseIntZero (eunit.value);
		eunit.value = unit;
		Data.options.tower.delete_unit = unit;
		t.deleteTick();
	},

	alarmTick : function (){
		var t = Tabs.Tower;
		clearTimeout (t.alarmTimer);
		t.checkAlarm();
		t.alarmTimer = setTimeout (t.alarmTick, (Data.options.tower.delay*Data.options.tower.unit*1000)+Math.randRange(1000,5000));
	},

	deleteTick : function (){
		var t = Tabs.Tower;
		clearTimeout (t.deleteTimer);
		if (Data.options.tower.delete_report) {
			var d;
			for (var i=Data.options.messages_tower.length-1; i>=0; i--) {
				d = Date.parse(Data.options.messages_tower[i].arrive_at)/1000;
				var now = parseInt(serverTime());
				var diff = now - d;
				if (diff>=Data.options.tower.delete_delay*Data.options.tower.delete_unit) {
					t.removeRow(Data.options.messages_tower[i]);
					Data.options.messages_tower.splice(i,1);
				}
			}
			t.deleteTimer = setTimeout (t.deleteTick, Data.options.tower.delete_delay*Data.options.tower.delete_unit*1000);
		}
	},

	// check for alarm reports
	checkAlarm : function (){
		MyAjax.messageList ('all', 1, function (rslt){
			var t = Tabs.Tower;
			if (rslt != null) {
				//logit ('messageList:\n' + inspectObj (rslt, 7, 1));        
				for (var i=rslt.length-1; i>=0; i--){
					if (rslt[i].report_type == "SentinelWarning"){
						var found = false;
						for (var j=0; j<Data.options.messages_tower.length; j++) {
							if (Data.options.messages_tower[j].id == rslt[i].id) {
								found = true;
								break;
							}
						}
						if (!found) t.readList.push (rslt[i].id);
					}
				}
				clearTimeout (t.fetchTimer);
				if (t.readList.length > 0) t.fetchTimer = setTimeout (t.fetchNext, 2000);
			}
		});
	},  

	fetchNext : function (){
		var t = Tabs.Tower;
		var id = t.readList[0];
		if (!id) {
			logit ('Tabs.Tower.fetchNext BAD MESSAGE ID:\n'+ inspectObj (t.readList, 8, 1));
			return;
		}
		clearTimeout (t.fetchTimer);
		MyAjax.messageDetail (id, function (rslt){
			var t = Tabs.Tower;
			t.gotAlarmReport (rslt, id);
			t.readList.shift();
			if (t.readList.length > 0) t.fetchTimer = setTimeout (t.fetchNext, 2500);
		});
	},

	gotAlarmReport : function (rpt_alm, msgid){
		var msg = {id : msgid, type : 0, arrive_at : 0, alliance : '', x : 0, y : 0, troups : '', };
		var msgIndexed;
		var indmax = 4;
		var toAdd = 0;
		if (!rpt_alm) return;
		if (rpt_alm.report.warnings.length > indmax) {
			msgIndexed = rpt_alm.report.warnings[indmax-1]; 
			msg.arrive_at = getValueFromString (msgIndexed, indmax-1, 0, toAdd);
			var d = Date.parse(msg.arrive_at)/1000;
			if (parseInt(serverTime())-d >= Data.options.tower.delete_delay*Data.options.tower.delete_unit)
			return;
			indmax += 2;
		}
		if (rpt_alm.report.warnings.length > indmax) {
			msgIndexed = rpt_alm.report.warnings[indmax-1]; 
			msg.alliance = getValueFromString (msgIndexed, indmax-1, 0, toAdd);
			indmax++;
		}
		if (rpt_alm.report.warnings.length > indmax) {
			if (rpt_alm.report.warnings[indmax-1].indexOf('General') >= 0) {
				toAdd = 1;
				indmax++;
			} else
				msg.type = 1;
		}
		if (rpt_alm.report.warnings.length > indmax) {
			msgIndexed = rpt_alm.report.warnings[indmax-1]; 
			msg.x = getValueFromString(msgIndexed, indmax-1, 0, toAdd);
			msg.y = getValueFromString(msgIndexed, indmax-1, 1, toAdd);
			indmax++;
		}
		if (rpt_alm.report.warnings.length > indmax) {
			msgIndexed = rpt_alm.report.warnings[indmax-1]; 
			msg.troups = getValueFromString(msgIndexed, indmax-1, 0, toAdd);
		}
		function getValueFromString(warn, ind, value, toAdd) {
			var str = warn;
			var toSearch;
			var ritorno;
			var t = Tabs.Tower;
			if (ind == 3) toSearch = ' arrive by ';
			else if (ind == 5) toSearch = ' member of ';
			else if (ind == 6) toSearch = ' originate from ';
			else if (ind == 7) {
				if (toAdd == 1) toSearch = ' originate from ';
				else toSearch = ' include ';
			} else toSearch = ' include ';
			pos = str.indexOf(toSearch);
			if (pos < 0) {
				if (ind == 3) result = 0;
				else if (ind == 5) result = '';
				else if (ind == 6) result = -1;
				else if (ind == 7) {
					if (toAdd == 1) result = -1;
					else result = '';
				} else result = '';
				return result;
			}
			var strNew = str.substr(pos+toSearch.length);
			if (strNew.substr(strNew.length-1) == '.') strNew = strNew.substr(0, strNew.length-1);
			if (ind == 3) result = t.getTimeAlarm(strNew);
			else if (ind == 5) result = strNew;
			else if (ind == 6) result = t.getCoordXY(strNew, value);
			else if (ind == 7) {
				if (toAdd == 1) result = t.getCoordXY(strNew, value);
				else result = t.getTroups(strNew);
			} else result = t.getTroups(strNew);
			return result;
		}
logit ('Message : '+ msg.id + ', type '+msg.type+', arrive_at '+msg.arrive_at+', alliance '+msg.alliance+', at '+msg.x+','+msg.y);

		Data.options.messages_tower.push (msg);
		var t = Tabs.Tower;
		t._addTab (msg, false);
	},

	getTroups : function (str) {
		var result = '';
		var pos;
		var splitRes = str.split(", ");
		for (var i=splitRes.length-1; i>=0; i--) {
			pos = splitRes[i].indexOf(' ');
			if (pos < 0) splitRes.splice(i,1);
			else splitRes[i] = nombreFormate(splitRes[i].substr(0,pos),' ') + ' ' + translate ( splitRes[i].substr(pos+1) ); 
		}
		if (splitRes.length>0) result = splitRes.join(', ');
		return result;
	},
  
	getTimeAlarm : function (str) {
		var result = 0;
		if (str.length>=19) {
			var year = parseInt(str.substr(0,4));
			var month = parseInt(str.substr(5,2));
			if (month == 0) month = parseInt(str.substr(6,1));
			var day = parseInt(str.substr(8,2));
			if (day == 0) day = parseInt(str.substr(9,1));
			var hours = parseInt(str.substr(11,2));
			if (hours == 0) hours = parseInt(str.substr(12,1));
			var minutes = parseInt(str.substr(14,2));
			if (minutes == 0) minutes = parseInt(str.substr(15,1));
			var seconds = parseInt(str.substr(17,2));
			if (seconds == 0) seconds = parseInt(str.substr(18,1));
			result = new Date(Date.UTC(year, month-1, day, hours, minutes, seconds));
		}
		return result;
	},

	getCoordXY : function (str, value) {
		var pos;
		var result = -1;
		pos = str.indexOf('/');
		if (pos >= 0) result = (value == 0 ? parseInt(str.substr(0, pos)) : parseInt(str.substr(pos+1)));
		return result;
	},

	togOpt : function (checkboxId, optionVar, callEnable, callIsAvailable){
		var t = Tabs.Tower;
		var checkbox = document.getElementById(checkboxId);
		if (callIsAvailable && callIsAvailable() == false){
			checkbox.disabled = true;
			return;
		}
		if (optionVar) checkbox.checked = true;
		checkbox.addEventListener ('change', new eventToggle(checkboxId, optionVar, callEnable).handler, false);
		function eventToggle (checkboxId, optionVar, callOnChange){
			this.handler = handler;
			var optVar = optionVar;
			var callback = callOnChange;
			function handler(event){
				optVar = this.checked;
				if (callback != null)
					callback (this.checked);
			}
		}
	},

	playSound : function (doRepeats){
		var t = Tabs.Tower;
		document.getElementById(UID['tabTower_Stop']).disabled = false;
		clearTimeout (soundStopTimer);
		clearTimeout (soundRepeatTimer);
		simpleSoundPlayer.addPlayer(UID['tabTower_SwfPlayer'], Data.options.tower.sound_url);
		soundStopTimer = setTimeout (t.stopSound, Data.options.tower.play_length*1000);
		if (doRepeats && Data.options.tower.repeat)
			soundRepeatTimer = setTimeout (function (){t.playSound(true)}, Data.options.tower.repeat_delay*60000);
	},

	stopSound : function (){
		var t = Tabs.Tower;
		simpleSoundPlayer.removePlayer(UID['tabTower_SwfPlayer']);
		clearTimeout (soundStopTimer);
		clearTimeout (soundRepeatTimer);
		document.getElementById(UID['tabTower_Stop']).disabled = true;
	},
}
// Jawz *********************************** Tower Tab *********************************************


//*********************************** Options Tab *********************************************
Tabs.Options = {
	tabOrder       : OPTIONS_TAB_ORDER,
	tabLabel       : 'Opts',
	tabDisabled	   : !OPTIONS_TAB_ENABLE,
	container	   : null,
	refreshTimer   : null,
	readMsgsTimer  : null,
	readPagesTimer : null,
	pagesMessages  : 0,
	pageReading    : 0,
	readList       : [],
	idsToDelete    : [],
	year           : [],
	month          : [],
	day            : [],
	msDate         : [],
	cat            : '',

	init : function (div) {
		var t = Tabs.Options;
		t.container = div;

		var now = new Date();
		t.year[0] = 2010;
		t.month[0] = 10;
		t.day[0] = 1;
		t.year[1] = now.getFullYear();
		t.month[1] = now.getMonth()+1;
		t.day[1] = now.getDate();
		t.msDate[0] = 0;
		t.msDate[1] = 0;

		var selected = new Array(4);
		for (var i = 0; i < selected.length; i++){
			selected[i] = '';
		}
		
		switch (Data.options.autoCollect.unit) {
			case 1:
				selected[1] = 'selected';
				break
			case 60:
				selected[2] = 'selected';
				break;
			case 3600:
				selected[3] = 'selected';
				break;
			case 86400:
				selected[4] = 'selected';
				break;
			default:
				selected[3] = 'selected';
		}

		try {      
			m = '<div class=' + UID['title'] + ' style="margin-bottom:10px">'+ translate('Options') +'</div>'
			+'<div style="height:735px; ; max-height:735px; overflow-y:auto; color:#000;">'
			+'<table class=' + UID['table'] + '>' // Jawz - added class name
			+'	<tr valign=top>'
			+'		<td><b>' + translate('Game Options') + ': </b></td>'
			+'	</tr>'
			+'	<tr valign=top>'
			+'		<td>'
			+'		<label>'
			+'		<input id=' + setUID('tabOptions_CB_Collect') + ' type=checkbox /> ' + translate('Auto harvest resources from outposts every')
			+'		</label> '
			+'		<input id=' + setUID('tabOptions_collectTime') + ' size=1 maxlength=2 type=text value="' + Data.options.autoCollect.delay + '" />'
			+'		<select id=' + setUID('tabOptions_collectUnit') + ' size=1>'
			+'			<option value=1 ' + selected[1] + '>' + translate('Seconds') + '</option>'
			+'			<option value=60 ' + selected[2] + '>' + translate('Minutes') + '</option>'
			+'			<option value=3600 ' + selected[3] + '>' + translate('Hours') + '</option>'
			+'			<option value=86400 ' + selected[4] + '>' + translate('Days') + '</option>'
			+'		</select>'
			+'		</td>'
			+'	</tr><tr valign=top>'
			+'		<td>'
			+'		<label><input id=' + setUID('tabOptions_CB_UTCtime') + ' type=checkbox /> ' + translate('Check to use UTC time instead of local time') + '</label>'
			+'		</td>'
			+'	</tr><tr valign=top>'
			+'		<td>'
			+'		<label><input id=' + setUID('tabOptions_CB_Speedups') + ' type=checkbox /> ' + translate('Enable use of speed-ups in attacks waves') + '</label>'
			+'		</td>'
			+'	</tr>'
			+'</table>'
			+'<br>'
			+'<table class=' + UID['table'] + '>' // Jawz - added class name
			+'	<tr valign=top>'
			+'		<td><b>' + translate('Script Options') + ': </b></td>'
			+'	</tr><tr valign=top>'
			+'		<td>' + translate('Script language') + ': &nbsp'
			+'		<select id=' + setUID('tabOptions_language') + ' size=1>';
			for (var lang = 0; lang < Translation.available_langs.length; lang++) {
				m += '	<option value="' + Translation.available_langs[lang].code + '" '+ (Data.options.user_language==Translation.available_langs[lang].code ? 'selected' : '') + '>' + translate(Translation.available_langs[lang].desc) + '</option>'
			}
			m += '		</select>'
			+'		</td>'
			+'	</tr><tr valign=top>'
			+'		<td>'
			+'		<label><input id=' + setUID('tabOptions_CB_Drag') + ' type=checkbox /> ' + translate('Enable window drag') + '</label>'
			+'		</td>'
			+'	</tr><tr valign=top>'
			+'		<td>'
			+'		<label><input id=' + setUID('tabOptions_CB_Verbose') + ' type=checkbox /> ' + translate('Enable verbose logging') + '</label>'
			+'		</td>'
			+'	</tr><tr valign=top>'
			+'		<td>'
			+'		<label><input id=' + setUID('tabOptions_CB_Background') + ' type=checkbox '+(Data.options.background?' CHECKED ':'')+'  /> ' + translate('Display official background image') + '</label>'
			+'		</td>'
			+'	</tr><tr valign=top>'
			+'		<table cellpadding=3><tr valign=top>'
			+'			<td>&nbsp<label>' + translate('Wiki URL') + '</label>&nbsp &nbsp</td>'
			+'			<td><input id=' + setUID('tabOptions_Wiki') + ' size=70 maxlength=200 type=text value="' + Data.options.wikiUrl + '" />&nbsp</td>'
			+'		</tr><tr valign=top>'
			+'			<td>&nbsp<label>' + translate('Forum link') + '</label>&nbsp &nbsp</td>'
			+'			<td><input id=' + setUID('tabOptions_Forum') + ' size=70 maxlength=200 type=text value="' + Data.options.forumUrl + '" />&nbsp</td>'
			+'		</tr></table>'
			+'	</tr>'
			+'</table>'
			// Jawz
			+'<br>'
			+'<table class=' + UID['table'] + '>'
			+'	<tr valign=top>'
			+'		<td><b>' + translate('Features') + ': </b></td>'
			+'	</tr><tr valign=top>'
			+'		<td>'
			+'		<label><input id=' + setUID('tabOptions_AutoRefresh') + ' type=checkbox /> ' + translate('Auto refresh info tab data every') + '</label>'
			+'		<input id=' + setUID('tabOptions_refreshTime') + ' size=1 maxlength=2 type=text value="' + Data.options.autoRefresh.delay + '" />'
			+'		<select id=' + setUID('tabOptions_refreshUnit') + ' size=1>'
			+'			<option value=1 ' + (Data.options.autoRefresh.unit == 1 ? 'selected' : '') + '>' + translate('Seconds') + '</option>'
			+'			<option value=60 ' + (Data.options.autoRefresh.unit == 60 ? 'selected' : '') + '>' + translate('Minutes') + '</option>'
			+'			<option value=3600 ' + (Data.options.autoRefresh.unit == 3600 ? 'selected' : '') + '>' + translate('Hours') + '</option>'
			+'			<option value=86400 ' + (Data.options.autoRefresh.unit == 86400 ? 'selected' : '') + '>' + translate('Days') + '</option>'
			+'		</select>'
			+'		</td>'
			+'	</tr>'
			+'</table>'
			// End Jawz
			+'<br>'
			+'<table class=' + UID['table'] + '>' // Jawz - added class name
			+'	<tr valign=top>'
			+'		<td>'
			+'		<label><input id=' + setUID('tabOptions_btnRefresh') + ' type=button value="' + translate('Refresh') + '" /></label>'
			+'		</td>'
			+'	</tr>'
			+'</table>'
			+'<br>'
			// Jawz
			+'<table class=' + UID['table'] + ' width=100%>'
			+'	<tr valign=top>'
			+'		<td width=40%><b>' + translate('Tabs Options') + ': </b></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabOptions_TabWave') + ' type=checkbox /> ' + translate('Disable <B>Wave</B> tab') + '</label></td>'
			+'		<td><label><input id=' + setUID('tabOptions_TabMulti') + ' type=checkbox /> ' + translate('Disable <B>Multi</B> tab') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabOptions_TabSpy') + ' type=checkbox /> ' + translate('Disable <B>Spy</B> tab') + '</label></td>'
			+'		<td><label><input id=' + setUID('tabOptions_TabSearch') + ' type=checkbox /> ' + translate('Disable <B>Search</B> tab') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabOptions_TabBattle') + ' type=checkbox /> ' + translate('Disable <B>Battle</B> tab') + '</label></td>'
			+'		<td><label><input id=' + setUID('tabOptions_TabAlliance') + ' type=checkbox /> ' + translate('Disable <B>Alliance</B> tab') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabOptions_TabLog') + ' type=checkbox /> ' + translate('Disable <B>Log</B> tab') + '</label></td>'
			+'	</tr>'
			+'</table><br>'
			+'<div class=' + UID['title'] + ' style="margin-bottom:10px">'+ translate('Cache data') +'</div>'
			+'<table class=' + UID['table'] + ' width=100%>'
			+'	<tr valign=top>'
			+'		<td width=40%><label><input id=' + setUID('tabOptions_btnSave') + ' type=button value="' + translate('Save') + '" title="' + translate('Force saving current script settings') + '" /></label></td>'
			+'		<td width=60%><label><input id=' + setUID('tabOptions_btnClean') + ' type=button value="' + translate('Clear') + '" title="' + translate('Clear local storage (internet cache)') + '" /></label></td>'
			+'	</tr><tr valign=top><td style="font-size:2px">&nbsp</td>'
			+'	</tr><tr valign=top>'
			+'		<td width=40%><label><input id=' + setUID('tabOptions_btnBackup') + ' type=button value="' + translate('Backup') + '" title="' + translate('Save current script settings in a local file') + '" /></label></td>'
			+'		<td width=60%><label><input id=' + setUID('tabOptions_btnRestore') + ' type=button value="' + translate('Restore') + '" title="' + translate('Restore script settings from local file') + '" /></label>'
			+'		<input id=' + setUID('tabOptions_storage_file') + ' type="file" multiple style="opacity:0;position:absolute;z-index:-1"/></td>'
			+'	</tr>'
			+'</table><br>'
			+'<div class=' + UID['title'] + ' style="margin-bottom:10px">'+ translate('Delete messages') +'</div>'
			+'<table class=' + UID['table'] + '>'
			+'	<tr valign=top>'
			+'		<td><b>' + translate('Delete messages of this type') + ': </b></td>'
			+'		<td>'
			+'		<select id=' + setUID('tabOptions_msgType') + ' size=1>'
			+'			<option value=0 ' + (Data.options.messages_delete.type==MESSAGES_ALL ? 'selected' : '') + '>' + translate('All types') + '</option>'
			+'			<option value=1 ' + (Data.options.messages_delete.type==MESSAGES_ONLY ? 'selected' : '') + '>' + translate('Messages') + '</option>'
			+'			<option value=2 ' + (Data.options.messages_delete.type==REPORTS_ONLY ? 'selected' : '') + '>' + translate('Reports') + '</option>'
			+'		</select>'
			+'		</td>'
			+'	</tr><tr valign=top>'
			+'		<td  style="font-size:2px">&nbsp</td>'
			+'	</tr><tr valign=top>'
			+'		<td><b><i>' + translate('Messages') + ': </i></b></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabOptions_MsgG') + ' type=checkbox '+(Data.options.messages_delete.msgGame?' CHECKED ':'')+' /> ' + translate('Game messages') + '</label></td>'
			+'		<td><label><input id=' + setUID('tabOptions_MsgP') + ' type=checkbox '+(Data.options.messages_delete.msgPlayer?' CHECKED ':'')+' /> ' + translate('Player messages') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabOptions_MsgS') + ' type=checkbox '+(Data.options.messages_delete.msgSentinel?' CHECKED ':'')+' /> ' + translate('Sentinel messages') + '</label></td>'
			+'		<td><label><input id=' + setUID('tabOptions_MsgA') + ' type=checkbox '+(Data.options.messages_delete.msgAlliance?' CHECKED ':'')+' /> ' + translate('Alliance messages') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td  style="font-size:2px">&nbsp</td>'
			+'	</tr><tr valign=top>'
			+'		<td><b><i>' + translate('Reports') + ': </i></b></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabOptions_RepA') + ' type=checkbox '+(Data.options.messages_delete.rptAnthropus?' CHECKED ':'')+' /> ' + translate('Camps/wilds attack reports') + '</label></td>'
			+'		<td><label><input id=' + setUID('tabOptions_RepT') + ' type=checkbox '+(Data.options.messages_delete.rtpTransport?' CHECKED ':'')+' /> ' + translate('Transport reports') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabOptions_RepS') + ' type=checkbox '+(Data.options.messages_delete.rptSpy?' CHECKED ':'')+' /> ' + translate('Spy reports') + '</label></td>'
			+'		<td><label><input id=' + setUID('tabOptions_RepF') + ' type=checkbox '+(Data.options.messages_delete.rptReinforcement?' CHECKED ':'')+' /> ' + translate('Reinforcement reports') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td><label><input id=' + setUID('tabOptions_RepB') + ' type=checkbox '+(Data.options.messages_delete.rptBattle?' CHECKED ':'')+' /> ' + translate('Battle notes') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td  style="font-size:2px">&nbsp</td>'
			+'	</tr><tr valign=top>'
			+'		<td><b><i>' + translate('Exception') + ': </i></b></td>'
			+'	</tr><tr valign=top>'
			+'		<td colspan=2><label><input id=' + setUID('tabOptions_ExcM') + ' type=checkbox '+(Data.options.messages_delete.rptExceptMyAttacks?' CHECKED ':'')+' /> ' + translate('Keep battle reports of my attacks on other players') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td colspan=2><label><input id=' + setUID('tabOptions_ExcY') + ' type=checkbox '+(Data.options.messages_delete.rptExceptYourAttacks?' CHECKED ':'')+' /> ' + translate('Keep battle reports of attacks from other players') + '</label></td>'
			+'	</tr><tr valign=top>'
			+'		<td  style="font-size:2px">&nbsp</td>'
			+'	</tr><tr valign=top>'
			+'		<td colspan=2><b><i>' + translate('Date range') + ': </i></b>&nbsp &nbsp<input id=' + setUID('tabOptions_ChkD') + ' type=checkbox '+(Data.options.messages_delete.dateAll?' CHECKED ':'')+' /> ' + translate('All') + '</label></td>'
			+'	</tr><tr valign=top>';
			for (var type=0; type<2; type++) {
				m += '<td>' + (type == 0 ? translate('From') : translate('To')) +' : ';
				m += '<select id=' + setUID('tabOptions_DD' + type) + ' size=1>';
				for (var i=1; i<32; i++)
					m += '<option value=' + i + (i == t.day[type] ? ' selected' : '') + '>' + (i < 10 ? '0' : '') + i + '</option>';
				m += '</select>';
				m += '<select id=' + setUID('tabOptions_DM' + type) + ' size=1>';
				for (var i=1; i<13; i++)
					m += '<option value=' + i + (i == t.month[type] ? ' selected' : '') + '>' + (i < 10 ? '0' : '') + i + '</option>';
				m += '</select>';
				m += '<select id=' + setUID('tabOptions_DY' + type) + ' size=1>';
				for (var i=2010; i<t.year[1]+1; i++)
					m += '<option value=' + i + (i == t.year[type] ? ' selected' : '') + '>' + i + '</option>';
				m += '</select></td>';
			}
			m += '</tr>'
			+'	<tr valign=top>'
			+'		<td colspan=2><br>'
			+'		<label><input id=' + setUID('tabOptions_ButDel') + ' type=button value="' + translate('Delete now') + '" /></label>'
			+'		</td>'
			+'	</tr>'
			+'</table>'
			+'<br><div id=' + setUID('tabOptions_DelFB') + '></div><hr></div>';

			t.container.innerHTML = m;
			
			t.togOpt(UID['tabOptions_CB_Collect'], Data.options.autoCollect.enabled, AutoCollect.setEnable);
			
			document.getElementById(UID['tabOptions_collectTime']).addEventListener ('change', t.timeChanged, false);
			document.getElementById(UID['tabOptions_collectUnit']).addEventListener ('change', t.unitChanged, false);
			document.getElementById(UID['tabOptions_refreshTime']).addEventListener ('change', t.refreshTimeChanged, false);
			document.getElementById(UID['tabOptions_refreshUnit']).addEventListener ('change', t.refreshUnitChanged, false);
			document.getElementById(UID['tabOptions_language']).addEventListener ('change', t.onChangeLanguage, false);

			t.togOpt(UID['tabOptions_CB_Drag'], Data.options.popUp.drag, onChangeDrag);
			t.togOpt(UID['tabOptions_CB_Verbose'], Data.options.verboseLog.enabled, VerboseLog.setEnable);
			t.togOpt(UID['tabOptions_CB_Background'], Data.options.background, t.onChangeBackground);

			// Jawz
			document.getElementById(UID['tabOptions_CB_Speedups']).addEventListener ('click', function(e){Data.options.speedups_enabled=e.target.checked}, false);
			document.getElementById(UID['tabOptions_CB_Speedups']).addEventListener ('change', function(e){Data.options.speedups_enabled=e.target.checked}, false);
			document.getElementById(UID['tabOptions_CB_UTCtime']).addEventListener ('click', function(e){Data.options.utc_time=e.target.checked}, false);
			document.getElementById(UID['tabOptions_CB_UTCtime']).addEventListener ('change', function(e){Data.options.utc_time=e.target.checked}, false);
			document.getElementById(UID['tabOptions_Wiki']).addEventListener ('change', function (){Data.options.wikiUrl = document.getElementById(UID['tabOptions_Wiki']).value}, false);
			document.getElementById(UID['tabOptions_Forum']).addEventListener ('change', function (){Data.options.forumUrl = document.getElementById(UID['tabOptions_Forum']).value}, false);
			t.togOpt (UID['tabOptions_AutoRefresh'], Data.options.autoRefresh.enabled, t.setEnableRefresh);
			t.togOpt (UID['tabOptions_TabWave'], Data.options.disable_wave, t.setEnableTab);
			t.togOpt (UID['tabOptions_TabMulti'], Data.options.disable_multi, t.setEnableTab);
			t.togOpt (UID['tabOptions_TabSpy'], Data.options.disable_spies, t.setEnableTab);
			t.togOpt (UID['tabOptions_TabSearch'], Data.options.disable_search, t.setEnableTab);
			t.togOpt (UID['tabOptions_TabBattle'], Data.options.disable_battle, t.setEnableTab);
			t.togOpt (UID['tabOptions_TabAlliance'], Data.options.disable_alliance, t.setEnableTab);
			t.togOpt (UID['tabOptions_TabLog'], Data.options.disable_log, t.setEnableTab);

			// Message deletion fields listeners
			document.getElementById(UID['tabOptions_msgType']).addEventListener ('change', ctlChanged, false);
			document.getElementById(UID['tabOptions_MsgG']).addEventListener ('click', function(e){Data.options.messages_delete.msgGame=e.target.checked}, false);
			document.getElementById(UID['tabOptions_MsgP']).addEventListener ('click', function(e){Data.options.messages_delete.msgPlayer=e.target.checked}, false);
			document.getElementById(UID['tabOptions_MsgS']).addEventListener ('click', function(e){Data.options.messages_delete.msgSentinel=e.target.checked}, false);
			document.getElementById(UID['tabOptions_MsgA']).addEventListener ('click', function(e){Data.options.messages_delete.msgAlliance=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepA']).addEventListener ('click', function(e){Data.options.messages_delete.rptAnthropus=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepT']).addEventListener ('click', function(e){Data.options.messages_delete.rptTransport=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepS']).addEventListener ('click', function(e){Data.options.messages_delete.rptSpy=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepB']).addEventListener ('click', function(e){Data.options.messages_delete.rptBattle=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepF']).addEventListener ('click', function(e){Data.options.messages_delete.rptReinforcement=e.target.checked}, false);
			document.getElementById(UID['tabOptions_ExcM']).addEventListener ('click', function(e){Data.options.messages_delete.rptExceptMyAttacks=e.target.checked}, false);
			document.getElementById(UID['tabOptions_ExcY']).addEventListener ('click', function(e){Data.options.messages_delete.rptExceptYourAttacks=e.target.checked}, false);
			document.getElementById(UID['tabOptions_ChkD']).addEventListener ('click', function(e){Data.options.messages_delete.dateAll=e.target.checked; disableDates();}, false);
			document.getElementById(UID['tabOptions_MsgG']).addEventListener ('change', function(e){Data.options.messages_delete.msgGame=e.target.checked}, false);
			document.getElementById(UID['tabOptions_MsgP']).addEventListener ('change', function(e){Data.options.messages_delete.msgPlayer=e.target.checked}, false);
			document.getElementById(UID['tabOptions_MsgS']).addEventListener ('change', function(e){Data.options.messages_delete.msgSentinel=e.target.checked}, false);
			document.getElementById(UID['tabOptions_MsgA']).addEventListener ('change', function(e){Data.options.messages_delete.msgAlliance=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepA']).addEventListener ('change', function(e){Data.options.messages_delete.rptAnthropus=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepT']).addEventListener ('change', function(e){Data.options.messages_delete.rptTransport=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepS']).addEventListener ('change', function(e){Data.options.messages_delete.rptSpy=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepB']).addEventListener ('change', function(e){Data.options.messages_delete.rptBattle=e.target.checked}, false);
			document.getElementById(UID['tabOptions_RepF']).addEventListener ('change', function(e){Data.options.messages_delete.rptReinforcement=e.target.checked}, false);
			document.getElementById(UID['tabOptions_ExcM']).addEventListener ('change', function(e){Data.options.messages_delete.rptExceptMyAttacks=e.target.checked}, false);
			document.getElementById(UID['tabOptions_ExcY']).addEventListener ('change', function(e){Data.options.messages_delete.rptExceptYourAttacks=e.target.checked}, false);
			document.getElementById(UID['tabOptions_ChkD']).addEventListener ('change', function(e){Data.options.messages_delete.dateAll=e.target.checked; disableDates();}, false);
			for (var type=0; type<2; type++)
			{
				document.getElementById(UID['tabOptions_DD'+type]).addEventListener ('change', ctlChanged, false);
				document.getElementById(UID['tabOptions_DM'+type]).addEventListener ('change', ctlChanged, false);
				document.getElementById(UID['tabOptions_DY'+type]).addEventListener ('change', ctlChanged, false);
				disableCheckMsgsRpts(false);
				disableDates();
			}
			document.getElementById(UID['tabOptions_ButDel']).addEventListener ('click', t.beforeDeleteReport, false);
			// End Jawz
			
			document.getElementById(UID['tabOptions_btnRefresh']).addEventListener ('click', t.onClickRefresh, false);
			document.getElementById(UID['tabOptions_btnSave']).addEventListener ('click', t.onClickSaveSetting, false);
			document.getElementById(UID['tabOptions_btnClean']).addEventListener ('click', t.onClickClearStorage, false);
			document.getElementById(UID['tabOptions_btnBackup']).addEventListener ('click', t.onClickBackupFile, false);
			document.getElementById(UID['tabOptions_storage_file']).addEventListener ('change', t.onChangeRestoreFile, false);
			document.getElementById(UID['tabOptions_btnRestore']).addEventListener ('click', function(){
				console.log (document.getElementById(UID['tabOptions_storage_file']));
				document.getElementById(UID['tabOptions_storage_file']).click();}, false);

		} catch (e) {
			t.container.innerHTML = '<PRE>'+ e.name +' : '+ e.message +'</pre>';  
		}

		// Jawz
		function onChangeDrag (state) {
			Data.options.popUp.drag = state;
			mainPop.setEnableDrag (state);
		}
		function ctlChanged (e){
			var t = Tabs.Options;
			var elem = document.getElementById(e.target.id);
			var value = parseIntZero (elem.value);
			elem.value = value;
			if (e.target.id==UID['tabOptions_msgType']) {
				Data.options.messages_delete.type = value;
				disableCheckMsgsRpts(true);
			} else {
				for (var type=0; type<2; type++) {
					if (e.target.id==UID['tabOptions_DD'+type]) t.day[type] = value;
					else if (e.target.id==UID['tabOptions_DM'+type]) t.month[type] = value;
					else if (e.target.id==UID['tabOptions_DY'+type]) t.year[type] = value;
				}
			}
		}
		function disableDates() {
			for (var type=0; type<2; type++) {
				document.getElementById(UID['tabOptions_DD'+type]).disabled = Data.options.messages_delete.dateAll;
				document.getElementById(UID['tabOptions_DM'+type]).disabled = Data.options.messages_delete.dateAll;
				document.getElementById(UID['tabOptions_DY'+type]).disabled = Data.options.messages_delete.dateAll;
			}
		}
		function disableCheckMsgsRpts(byCtl) {
			disableCheckMessages(false);
			disableCheckReports(false);
			setCheckMessages((Data.options.messages_delete.type != REPORTS_ONLY), byCtl);
			setCheckReports ((Data.options.messages_delete.type != MESSAGES_ONLY), byCtl);
			if (Data.options.messages_delete.type!=MESSAGES_ALL) {
				disableCheckMessages((Data.options.messages_delete.type == REPORTS_ONLY));
				disableCheckReports ((Data.options.messages_delete.type == MESSAGES_ONLY));
			}
		}
		function disableCheckMessages (OnOff) {
			document.getElementById(UID['tabOptions_MsgG']).disabled = OnOff;
			document.getElementById(UID['tabOptions_MsgP']).disabled = OnOff;
			document.getElementById(UID['tabOptions_MsgS']).disabled = OnOff;
			document.getElementById(UID['tabOptions_MsgA']).disabled = OnOff;
		}
		function setCheckMessages (OnOff, byCtl) {
			document.getElementById(UID['tabOptions_MsgG']).checked = OnOff;
			document.getElementById(UID['tabOptions_MsgP']).checked = OnOff;
			document.getElementById(UID['tabOptions_MsgS']).checked = OnOff;
			document.getElementById(UID['tabOptions_MsgA']).checked = OnOff;
			if (byCtl) {
				Data.options.messages_delete.msgGame = OnOff;
				Data.options.messages_delete.msgPlayer = OnOff;
				Data.options.messages_delete.msgSentinel = OnOff;
				Data.options.messages_delete.msgAlliance = OnOff;
			}
		}
		function disableCheckReports (OnOff) {
			document.getElementById(UID['tabOptions_RepA']).disabled = OnOff;
			document.getElementById(UID['tabOptions_RepT']).disabled = OnOff;
			document.getElementById(UID['tabOptions_RepS']).disabled = OnOff;
			document.getElementById(UID['tabOptions_RepB']).disabled = OnOff;
			document.getElementById(UID['tabOptions_RepF']).disabled = OnOff;
			document.getElementById(UID['tabOptions_ExcM']).disabled = OnOff;
			document.getElementById(UID['tabOptions_ExcY']).disabled = OnOff;
		}
		function setCheckReports (OnOff, byCtl) {
			document.getElementById(UID['tabOptions_RepA']).checked = OnOff;
			document.getElementById(UID['tabOptions_RepT']).checked = OnOff;
			document.getElementById(UID['tabOptions_RepS']).checked = OnOff;
			document.getElementById(UID['tabOptions_RepB']).checked = OnOff;
			document.getElementById(UID['tabOptions_RepF']).checked = OnOff;
			document.getElementById(UID['tabOptions_ExcM']).checked = OnOff;
			document.getElementById(UID['tabOptions_ExcY']).checked = OnOff;
			if (byCtl) {
				Data.options.messages_delete.rptAnthropus = OnOff;
				Data.options.messages_delete.rptTransport = OnOff;
				Data.options.messages_delete.rptSpy = OnOff;
				Data.options.messages_delete.rptBattle = OnOff;
				Data.options.messages_delete.rptReinforcement = OnOff;
				Data.options.messages_delete.rptExceptMyAttacks = OnOff;
				Data.options.messages_delete.rptExceptYourAttacks = OnOff;
			}
		}
		// End Jawz
	}, 

	hide : function () {
	},

	show : function () {
		
	},
	
	togOpt : function (checkboxId, optionVar, callEnable, callIsAvailable) {
		var t = Tabs.Options;
		var checkbox = document.getElementById(checkboxId);
		if (callIsAvailable && callIsAvailable() == false) {
			checkbox.disabled = true;
			return;
		}
		if (optionVar){
			checkbox.checked = true;
		}
		checkbox.addEventListener ('change', new eventToggle(checkboxId, optionVar, callEnable).handler, false);
		function eventToggle(checkboxId, optionVar, callOnChange) {
			this.handler = handler;
			var optVar = optionVar;
			var callback = callOnChange;
			function handler(event) {
				optVar = this.checked;
				if (callback != null){
					callback(this.checked);
				}
			}
		}
	},
	
	timeChanged : function (e) {
		var etime = document.getElementById(UID['tabOptions_collectTime']);
		var time = parseIntZero(etime.value);
		etime.value = time;
		Data.options.autoCollect.delay = time;
	},

	unitChanged : function (e) {
		var eunit = document.getElementById(UID['tabOptions_collectUnit']);
		var unit = parseIntZero(eunit.value);
		eunit.value = unit;
		Data.options.autoCollect.unit = unit;
	},
	
	// Jawz
    refreshTimeChanged : function (e){
      var t = Tabs.Options;
      var etime = document.getElementById(UID['tabOptions_refreshTime']);
      var time = parseIntZero (etime.value);
      etime.value = time;
      Data.options.autoRefresh.delay = time;
      t.autoRefreshTick();
    },
  
    refreshUnitChanged : function (e){
      var t = Tabs.Options;
      var eunit = document.getElementById(UID['tabOptions_refreshUnit']);
      var unit = parseIntZero (eunit.value);
      eunit.value = unit;
      Data.options.autoRefresh.unit = unit;
      t.autoRefreshTick();
    },

	autoRefreshTick : function (){
		var t = Tabs.Options;
		clearTimeout (t.refreshTimer);
		if (Data.options.autoRefresh.enabled) {
			logit('fetchPlayer from Tab.Options Auto-refresh tick');
			Seed.fetchPlayer();
			t.refreshTimer = setTimeout (t.autoRefreshTick, Data.options.autoRefresh.delay*Data.options.autoRefresh.unit*1000);
		}
	},

	setEnableRefresh : function (){
		var t = Tabs.Options;
		var cR = document.getElementById(UID['tabOptions_AutoRefresh']);
		Data.options.autoRefresh.enabled = cR.checked;
		t.autoRefreshTick();
	},

	setEnableTab : function (){
		var t = Tabs.Options;
		var cW = document.getElementById(UID['tabOptions_TabWave']);
		var cM = document.getElementById(UID['tabOptions_TabMulti']);
		var cS = document.getElementById(UID['tabOptions_TabSpy']);
		var cC = document.getElementById(UID['tabOptions_TabSearch']);
		var cB = document.getElementById(UID['tabOptions_TabBattle']);
		var cA = document.getElementById(UID['tabOptions_TabAlliance']);
		var cL = document.getElementById(UID['tabOptions_TabLog']);
		Data.options.disable_wave = cW.checked;
		Data.options.disable_multi = cM.checked;
		Data.options.disable_spies = cS.checked;
		Data.options.disable_search = cC.checked;
		Data.options.disable_battle = cB.checked;
		Data.options.disable_alliance = cA.checked;
		Data.options.disable_log = cL.checked;
	},
	// End Jawz

	onChangeLanguage : function () {
		var lang = document.getElementById(UID['tabOptions_language']).value;
		Data.options.user_language = lang;
		setLanguage (lang);
	},

	onChangeBackground : function (state) {
		Data.options.background = state;
		try {
			localStorage.setItem( '118446_background', JSON.stringify( Data.options.background ) );
		} catch(e){}
	},

	onClickRefresh : function () {
		var t = Tabs.Options;
		Seed.fetchPlayer();  
	},

	onClickSaveSetting : function () {
		var t = Tabs.Options;
		dialogConfirm(translate('Do you want to save in Permanent Data the current script setting') + ' ?',
			function(){
				try {
					verboseLog('Save Data in localStorage');
					var keys = getKeys (Data.defaults);
					for (var i=0; i < keys.length; i++) {
						var item_name = keys[i];
						Data.setObject ( item_name, Data[item_name] );
					}
				} catch(e) {}
			},
			// Cancel
			function(){
			}, true
		);
	},

	onClickClearStorage : function () {
		var t = Tabs.Options;
			dialogConfirm(translate('Are you sure you want to delete All Permanent Data') + ' ?',
                function(){
					try {
						Data.clearStorage ();
						Data.setDefaultValues ('all');
					} catch(e) {}
				},
				// Cancel
				function(){
				}, true
			);
	},

	onClickBackupFile : function () {
		var t = Tabs.Options;
		dialogConfirm(translate('Do you want to save Permanent Data in local file') + ' ?',
			function(){
				try {
					setTimeout ( function () {
						var zip_file = Data.makeZip();
						var winpop = window.open('data:application/zip;base64,' + zip_file,'ZipFile','width=300,height=200,toolbar=0,resizable=0');
					}, 1000);
				} catch(e) {}
			},
			// Cancel
			function(){
			}, true
		);
	},

	onChangeRestoreFile : function () {
		var t = Tabs.Options;
		var files = document.getElementById(UID['tabOptions_storage_file']).files;
		if (!files.length) {
			return;
		}
		var reader = new FileReader();
		reader.onload = function(event) {
			try {
				if (event.target.result) {
					Data.mergeWith (JSON.parse( event.target.result ));
					var dial = new ModalDialog (t.container, 300, 150, '', true);
					dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
					dial.getContentDiv().innerHTML = '<B>' +translate('Restore') + ' ' + translate('Successfully') + '</b>';
				}
			} catch (e) {
				var dial = new ModalDialog (t.container, 300, 150, '', true);
				dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
				dial.getContentDiv().innerHTML = '<B>' +translate('Restore') + ' ' + translate('Error') + ' : <br><br> '+ e +'</b>';
			}
			// Clear the file container for the next change
			document.getElementById(UID['tabOptions_storage_file']).files = [];
			document.getElementById(UID['tabOptions_storage_file']).value = '';
		};
		reader.onerror = function (event) {
			var error = event.target.error.name;
			console.log (error);
			if (error == "NOT_READABLE_ERR") {}
			// Clear the file container for the next change
			document.getElementById(UID['tabOptions_storage_file']).files = [];
			document.getElementById(UID['tabOptions_storage_file']).value = '';
		};
		for (var i = 0, file; file = files[i]; i++) {
			// Read file into memory as UTF-8
			reader.readAsText (file, 'UTF-8');
		}
	}, 

	// Jawz - Functions for messages deletion
	beforeDeleteReport : function () {
		var t = Tabs.Options;
		var leastOneCheck=false;
		if (Data.options.messages_delete.type != REPORTS_ONLY)
			if (Data.options.messages_delete.msgGame ||
				Data.options.messages_delete.msgPlayer ||
				Data.options.messages_delete.msgSentinel ||
				Data.options.messages_delete.msgAlliance)
				leastOneCheck = true;
		if (!leastOneCheck && Data.options.messages_delete.type != MESSAGES_ONLY)
			if (Data.options.messages_delete.rptAnthropus ||
				Data.options.messages_delete.rptTransport ||
				Data.options.messages_delete.rptSpy ||
				Data.options.messages_delete.rptBattle ||
				Data.options.messages_delete.rptReinforcement)
				leastOneCheck = true;
		if (!leastOneCheck) {
			var dial = new ModalDialog (t.cont, 300, 150, '', true);
			dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Error') + '</b></center></div>';
			dial.getContentDiv().innerHTML = '<B>' + translate ('Select at least one type of message or report to delete') + ' !</b>';
			return;
		}
		if (!Data.options.messages_delete.dateAll) {
			for (type=0; type<2; type++) {
				if (!isValidDate(t.day[type],t.month[type],t.year[type])) {
					var dial = new ModalDialog (t.cont, 300, 150, '', true);
					dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Error') + '</b></center></div>';
					dial.getContentDiv().innerHTML = '<B>' + translate ('Invalid date') + ' "' + (type == 0 ? translate ('From') : translate ('To')) +'" !</b>';
					return;
				}
				t.msDate[type] = Date.parse(new Date(Date.UTC(t.year[type], t.month[type]-1, t.day[type], 0, 0, 0)))/1000;
			}
			if (t.msDate[1] < t.msDate[0]) {
				var dial = new ModalDialog (t.cont, 300, 150, '', true);
				dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Error') + '</b></center></div>';
				dial.getContentDiv().innerHTML = '<B>' + translate ('Invalid date range') + ' !</b>';
				return;
			}
			t.msDate[1] += 86400;
		}
		t.cat = 'all';
		if (Data.options.messages_delete.type == MESSAGES_ONLY) t.cat = 'messages';
		else if (Data.options.messages_delete.type == REPORTS_ONLY) t.cat = 'reports';
		var totMessages = 0;
		t.pagesMessages = 0;
		MyAjax.messageList (t.cat, -1, function (rslt){
			if (rslt==null)
				return;
			var t = Tabs.Options;
			totMessages = parseIntNan(rslt);
			if (totMessages==0) return;
			else {
				t.pagesMessages = parseInt(totMessages/12);
				if (totMessages%12 != 0)
					t.pagesMessages++;
				t.readList = [];
				t.pageReading = t.pagesMessages;
				clearTimeout (t.readPagesTimer);
				t.readPagesTimer = setTimeout (t.readPages, 2000);
			}
		});
  
		function isValidDate(day, month, year) {
			var result=false;
			var daysMonth;
			if ((month < 8 && month%2 == 1) || (month > 7 && month%2 == 0)) daysMonth = 31;
			else if (month != 2) daysMonth = 30;
			else if (isLeapYear(year)) daysMonth = 29;
			else daysMonth = 28;
			if (day > 0 && day < daysMonth && month > 0 && month < 13) result=true;
			return result;
		}
    
		function isLeapYear(year) {
			var result=false;
			if (year%4 == 0) {
				result=true;
				if (year%100 == 0 && year%400 != 0) result=false;
			}
			return result;
		}
	},
  
	readPages : function () {
		var t = Tabs.Options;
		document.getElementById(UID['tabOptions_DelFB']).innerHTML = '<CENTER>' + translate ('Read page ') + (t.pagesMessages + 1 - t.pageReading) + translate (' of ') + t.pagesMessages +'</center>';
		clearTimeout (t.readPagesTimer);
		MyAjax.messageList (t.cat, t.pageReading, function (rslt){
			if (rslt==null) return;
			var typeMsg;
			for (var i=rslt.length-1; i>=0; i--) {
				var msgToDelete = true;
				if (rslt[i].report_type == "BattleReport") {
					typeMsg = MSG_BATTLE_REPORT;
					msgToDelete = (Data.options.messages_delete.rptBattle || Data.options.messages_delete.rptAnthropus);
				} else if (rslt[i].report_type == "TransportMarchReport") {
					typeMsg = TRANSPORT_MARCH_REPORT;
					msgToDelete = Data.options.messages_delete.rptTransport;
				} else if (rslt[i].report_type == "SpyReport") {
					typeMsg = SPY_REPORT;
					msgToDelete = Data.options.messages_delete.rptSpy;
				} else if (rslt[i].report_type == "SentinelWarning") {
					typeMsg = SENTINEL_WARNING;
					msgToDelete = Data.options.messages_delete.msgSentinel;
				} else if (rslt[i].report_type == "ReinforcementsReport") {
					typeMsg = REINFORCEMENTS_REPORT;
					msgToDelete = Data.options.messages_delete.rptReinforcement;
				} else if (rslt[i].report_type == "SystemMessage") {
					typeMsg = SYSTEM_MESSAGE;
					msgToDelete = Data.options.messages_delete.msgGame;
				} else if (rslt[i].report_type == "PlayerMessage") {
					typeMsg = PLAYER_MESSAGE;
					msgToDelete = Data.options.messages_delete.msgPlayer;
				} else if (rslt[i].report_type == "AllianceMessage") {
					typeMsg = ALLIANCE_MESSAGE;
					msgToDelete = Data.options.messages_delete.msgAlliance;
				} else
					msgToDelete = false;
				if (msgToDelete && !Data.options.messages_delete.dateAll)
					if (rslt[i].created_at < t.msDate[0] || rslt[i].created_at > t.msDate[1])
						msgToDelete = false;
				var index = rslt[i].id * 1000 + t.pageReading * 10 + typeMsg;
				if (msgToDelete && t.readList.indexOf(index) < 0)
					t.readList.push (index);
			}
			if (t.pageReading > 1) {
				t.pageReading--;
				t.readPagesTimer = setTimeout (t.readPages, 2000);
			} else if (t.readList.length != 0) {
				t.idsToDelete = [];
				clearTimeout (t.readMsgsTimer);
				t.readMsgsTimer = setTimeout (t.readMsgs, 2000);
			} else
				document.getElementById(UID['tabOptions_DelFB']).innerHTML = '';
		});
	},

	readMsgs : function () {
		var t = Tabs.Options;
		var index = t.readList[0];
		document.getElementById(UID['tabOptions_DelFB']).innerHTML = '<CENTER>' + translate ('Message(s) deletion in progress') + '</center>';
		if (!index) {
			if (t.idsToDelete.length > 0) {
				MyAjax.messageDelete (t.idsToDelete);
				var dial = new ModalDialog (t.cont, 300, 150, '', true);
				dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Error') + '</b></center></div>';
				dial.getContentDiv().innerHTML = '<B>Je ne sais pas trop ce qu\'il doit y avoir comme message ici... !</b>';
				t.idsToDelete = [];
				document.getElementById(UID['tabOptions_DelFB']).innerHTML = '';
			}
			logit ('Tabs.Options.readMsgs BAD MESSAGE ID:\n'+ inspectObj (t.readList, 8, 1));
			return;
		}
		id = parseInt(index/1000);
		var typeMsg = index%10;    
		clearTimeout (t.readMsgsTimer);
		MyAjax.messageDetail (id, function (rslt){
			var msgToDelete=true;
			if (typeMsg == MSG_BATTLE_REPORT) {
				if (Data.options.messages_delete.rptBattle) {
					msgToDelete = rslt.report.sanctuary;
					if (msgToDelete && (
						(Data.options.messages_delete.rptExceptMyAttacks && rslt.report.attacker.name == Seed.player.name) ||
						(Data.options.messages_delete.rptExceptYourAttacks && rslt.report.attacker.name != Seed.player.name)))
						msgToDelete = false;
				}
				else if (Data.options.messages_delete.rptAnthropus) {
					msgToDelete = !rslt.report.sanctuary;
					if (msgToDelete && (
						(Data.options.messages_delete.rptExceptMyAttacks && rslt.report.attacker.name == Seed.player.name) ||
						(Data.options.messages_delete.rptExceptYourAttacks && rslt.report.attacker.name != Seed.player.name)))
						msgToDelete = false;
				}
			}
			if (msgToDelete) {
				if (t.idsToDelete.length > 11) {
					MyAjax.messageDelete (t.idsToDelete);
					t.idsToDelete = [];
				}
				t.idsToDelete.push (id);
			}
			t.readList.shift();
			if (t.readList.length > 0)
				t.readMsgsTimer = setTimeout (t.readMsgs, 2500);
			else {
				if (t.idsToDelete.length > 0) {
					MyAjax.messageDelete (t.idsToDelete);
					t.idsToDelete = [];
				}
				var dial = new ModalDialog (t.container, 300, 150, '', true);
				dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Message') + '</b></center></div>';
				dial.getContentDiv().innerHTML = '<B>' + translate ('Message(s) deleted') + ' !</b>';
				document.getElementById(UID['tabOptions_DelFB']).innerHTML = '';
			}
		});
	},
	// End Jawz - Functions for messages deletion
}
//*********************************** Options Tab *********************************************


//*********************************** Log Tab *********************************************
Tabs.Log = {
	tabOrder	: LOG_TAB_ORDER,
	tabLabel	: 'Log',
	tabDisabled	: !LOG_TAB_ENABLE,
	lastSubTab	: 'tabLogActions',
	container	: null,
	content		: [],
	title		: null,
	maxEntries	: 500,
	saveEntries	: 200,
	state		: 0,
	
	init : function (div){
		var t = Tabs.Log;
		t.container = div;
		div.innerHTML = ''
		+'<ul class=tabs>'
		+'	<li class="tab first"><a id='+ setUID('tabLogActions') +'>'+ translate('Actions') +'</a></li>'
		+'	<li class=tab><a id='+ setUID('tabLogConsole') +'>'+ translate('Console') +'</a></li>'
		+'</ul>'
		+'<div id='+ setUID('tabLog_Title') +' class=' + UID['title'] + '>'+translate('Action Log')+'</div>'
		+'<div id='+ setUID('tabLog_DivAction') + ' class=' + UID['status_ticker'] + ' style="height:695px; max-height:695px; overflow-y:auto;">'  // Jawz - remove "position:absolute;" in style and added class name
		+'	<table id='+ setUID('tabLog_ContAction') +' class='+UID['table_console']+' cellspacing=1 width=100%>'  // Jawz - added width
		+'	<tr>'
		+'		<td class=' + UID['underline'] + ' width=5%></td>' // Jawz - added width
		+'		<td class=' + UID['underline'] + ' width=95%></td>'
		+'	<tr>'
		+'	</table>'
		+'</div>'
		+'<div id='+ setUID('tabLog_DivConsole') + ' class=' + UID['status_ticker'] + ' style="height:695px; max-height:695px; overflow-y:auto;">'  // Jawz - remove "position:absolute;" in style and added class name
		+'	<table id='+ setUID('tabLog_ContConsole') +' class='+UID['table_console']+' cellspacing=1 width=100%>'  // Jawz - added width
		+'	<tr>'
		+'		<td class=' + UID['underline'] + ' width=5%></td>' // Jawz - added width
		+'		<td class=' + UID['underline'] + ' width=95%></td>'
		+'	<tr>'
		+'	</table>'
		+'</div>';
		
		t.content.push(document.getElementById(UID['tabLog_ContAction']));
		t.content.push(document.getElementById(UID['tabLog_ContConsole']));
		
		t.title = document.getElementById(UID['tabLog_Title']);
		
		document.getElementById(UID['tabLogActions']).addEventListener ('click', t.tabLogActions, false);
		document.getElementById(UID['tabLogConsole']).addEventListener ('click', t.tabLogConsole, false);
		
		t.state = 1;
		
		for (var i=0; i < Data.log.length && i < 2; ++i) // Jawz - Added test "i < 2" to be sure... Case of remaingin old data still in local storage
		{
			var log = Data.log[i];
			for (var j=0; j < log.length; ++j)
			{
				t._addRow(log[j].msg, log[j].ts, i);
			}
		}
		
		t.tabLogActions();
		
	},

	tabLogActions : function (){
		var t = Tabs.Log;

		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabLogActions']).className='selected';
		document.getElementById(UID['tabLogActions']).style.zIndex=1;
		t.lastSubTab = 'tabLogActions';

		t.content[0].parentNode.style.display = 'block';
		t.content[1].parentNode.style.display = 'none';

		t.title.innerHTML = translate('Action Log');

	},

	tabLogConsole : function (){
		var t = Tabs.Log;
		
		document.getElementById(UID[t.lastSubTab]).className='';
		document.getElementById(UID[t.lastSubTab]).style.zIndex=0;
		document.getElementById(UID['tabLogConsole']).className='selected';
		document.getElementById(UID['tabLogConsole']).style.zIndex=1;
		t.lastSubTab = 'tabLogConsole';
		
		t.content[1].parentNode.style.display = 'block';
		t.content[0].parentNode.style.display = 'none';

		t.title.innerHTML = translate('Console Log');
	},

	hide : function (){
	},

	show : function (){
	},

	_addRow : function (msg, ts, to){
		var t = Tabs.Log;
		var n = to ? to : 0;
		
		if (t.state != 1) {
			return;
		}
		
		if (t.content[n].rows.length > t.maxEntries) {
			t.content[n].deleteRow(t.maxEntries-1);
		}
		
		var row = t.content[n].insertRow(0);
		// row.vAlign = 'top';
		var ts_cell = row.insertCell(0);
		var msg_cell = row.insertCell(1);
		
		ts_cell.className = 'jewel';
		ts_cell.innerHTML = '(&nbsp;'+ ts +'&nbsp;)&nbsp;';
		
		msg_cell.innerHTML = msg;
		msg_cell.style.whiteSpace = 'normal';
	}, 

	addMsg : function (msg, to){
		if (Tabs.Log.tabDisabled){
			return;
		}

		var t = Tabs.Log;
		var n = to ? to : 0;
		var ts = new Date().toTimeString().substring (0,8);

		t._addRow (msg, ts, to);

		while (Data.log[n].length > t.saveEntries){
			Data.log[n].shift();
		}
		Data.log[n].push ({msg:msg, ts:ts});

	}
}

function actionLog(msg) {
	Tabs.Log.addMsg(msg, 0);
}
function consoleLog(msg) {
	Tabs.Log.addMsg(msg, 1);  
}
function verboseLog(msg) {
	if (Data.options.verboseLog.enabled){
		consoleLog(msg);
	}
}
//*********************************** Log Tab *********************************************


//*********************************** Debug Tab *********************************************
// No need to translate the DEBUG tab
Tabs.Debug = {
	tabOrder    : DEBUG_TAB_ORDER,
	tabLabel    : 'Debug',
	tabDisabled : !DEBUG_TAB_ENABLE,
	container   : null,

	init : function (div){
		var t = Tabs.Debug;
		t.container = div;
		t.mouseElement = div;
		var m = ''
			+ '<textarea id="'+setUID('tabsDebug_TA_Unescape')+'" row=3 cols=50></textarea>'
			+ '<input type=button value="unescape" id="'+setUID('tabsDebug_BTN_Unescape')+'" />'
			+ '<br><br>'
			+ '<input type=button value="Seed.Player" id="'+setUID('tabsDebug_BTN_SeedPlayer')+'" /> <br><br>'
			+ '<input type=button value="Seed.Jobs.city" id="'+setUID('tabsDebug_BTN_SeedJobCity')+'" /><br><br>'
			+ '<input type=button value="Seed.Marches" id="'+setUID('tabsDebug_BTN_SeedMarches')+'" /><br><br>'
			+ '<input type=button value="Seed.Buildings" id="'+setUID('tabsDebug_BTN_SeedBuildings')+'" /><br><br>'
			+ '<input type=button value="Clear MAP data" id="'+setUID('tabsDebug_BTN_ClearMap')+'" /><br><br>'
			+ '<input type=button value="All Terrains.last to null" id="'+setUID('tabsDebug_BTN_LastNull')+'" /><br><br>'
			+ '<input type=button value="Check reports" id="'+setUID('tabsDebug_BTN_Reports')+'" /><br><br>'
			+ '<input type=button value="Persistant Data" id="'+setUID('tabsDebug_BTN_Data')+'" /><br><br>'
			+ '<input type=button value="Scripts" id="'+setUID('tabsDebug_BTN_Scripts')+'" /><br><br>'
			+ '<br>Missing Reports:<span id="'+setUID('tabsDebug_MissRep')+'"></span> &nbsp; <input id="'+setUID('tabsDebug_BTN_Reset')+'" type=button value="RESET" />';
		
		div.innerHTML = m;
		
		document.getElementById(UID['tabsDebug_BTN_Unescape']).addEventListener ('click', t.unescape, false);
		document.getElementById(UID['tabsDebug_BTN_SeedPlayer']).addEventListener ('click', t.seedPlayer, false);
		document.getElementById(UID['tabsDebug_BTN_SeedJobCity']).addEventListener ('click', t.seedJobsCity, false);
		document.getElementById(UID['tabsDebug_BTN_SeedMarches']).addEventListener ('click', t.seedMarches, false);
		document.getElementById(UID['tabsDebug_BTN_SeedBuildings']).addEventListener ('click', t.seedBuildings, false);
		document.getElementById(UID['tabsDebug_BTN_LastNull']).addEventListener ('click', t.setLastNull, false);
		document.getElementById(UID['tabsDebug_BTN_ClearMap']).addEventListener ('click', t.clearMap, false);
		document.getElementById(UID['tabsDebug_BTN_Reports']).addEventListener ('click', t.readReports, false);
		document.getElementById(UID['tabsDebug_BTN_Scripts']).addEventListener ('click', t.dispScripts, false);
		document.getElementById(UID['tabsDebug_BTN_Data']).addEventListener ('click', t.dispData, false);
		document.getElementById(UID['tabsDebug_BTN_Reset']).addEventListener ('click', function(){
			Data.options.messages.missing=0; 
			t.showMissingReports()
		}, false);

		t.showMissingReports ();
	},

	show : function (){
		
	},
	hide : function (){
	},
	
	unescape : function (div){
		var t = Tabs.Debug;
		var e = document.getElementById(UID['tabsDebug_TA_Unescape']);
		e.value = unescape (e.value);
	},
	
	seedBuildings : function (){
		var t = Tabs.Debug;
		t.dispBuildings ('Seed.cities.capital.buildings', Seed.cities[CAPITAL_ID].buildings);
		t.dispBuildings ('Seed.cities.outpost.buildings', Seed.cities['outpost'].buildings);
	},

	dispScripts : function (){
		pop = new PopUp ('debug', 0,0, 1000,800, true); 
		pop.getTopDiv ().innerHTML = '<B><CENTER>Debug - List Scripts</center></b>' ;
		var scripts = document.getElementsByTagName('script');
		var m = '<DIV style="height:560px; max-height:560px; overflow:auto">';
		for (var i=0; i<scripts.length; i++){
			var code = scripts[i].innerHTML;
			if (code == undefined)
			m += 'no code<BR>';
			else
			m += 'Source: '+ scripts[i].src +'<BR>Length: '+ code.length +'<BR>'+ code.substr(0,1000).escapeHTML() +'<BR><HR>';
		}
		pop.getMainDiv().innerHTML = '</div>'+ m;
		pop.show(true);
	},  
	
	dispBuildings : function (msg, buildings){
		var b = [];
		for (var i=0; i<buildings.length; i++)
		b.push (buildings[i]);
		b.sort (function (a,b){
			if (a.location != b.location){
				if (a.location == 'city')
				return -1;
				return 1;
			}
			return a.slot - b.slot;
		});
		var m = msg + ':\n';
		for (var i=0; i<b.length; i++)
			m += b[i].location +' slot #'+ b[i].slot +' : Level '+ b[i].level +' '+ b[i].type +'\n';
		logit (m);
	},

	showMissingReports : function (){
		var t = Tabs.Debug;
		document.getElementById(UID['tabsDebug_MissRep']).innerHTML = Data.options.messages.missing;
		setTimeout (t.showMissingReports, 2000);
	},

	readReports : function (){
		Messages.checkMessages();
	},
	
	seedPlayer : function (){
		logit (inspectObj (Seed.player, 8, 1));
	},
	
	seedJobsCity : function (){
		var now = parseInt(serverTime());
		for (var c in Seed.jobs)
			logit ('Seed.jobs['+ c +'] (city #'+ Seed.cityIdx[c] +') now='+ now +':\n'+ inspectObj (Seed.jobs[c], 8, 1));
	},
	
	seedMarches : function (){
		var now = parseInt(serverTime());
		var msg = '***** Seed.marches: *****  (now='+ parseInt(serverTime())+')\n';
		for (var p in Seed.marches){
			var march = Seed.marches[p];
			var status = march.status;
			if (status == 'returning')
			status = 'returning ';
			msg += 'OWNER: '+  march.ownerId +' ID: '+ march.id +' '+ translate(status) +' '+ march.x +','+ march.y +' '+ march.run_at +'('+ (march.run_at-now)  +') '+ march.duration +'\n';
		}
		logit (msg);
	},

	dispData : function (){
		var m = '';
		for (var i=0; i<Data.names.length; i++){
			m += '***** Data.'+ Data.names[i] +':\n'+ inspectObj (Data[Data.names[i]], 12, 1);
		}
		logit (m);
	},
	
	clearMap : function (){
		Data.map = {
			terrains: {
				AnthropusCamp:[],
				Bog			:[],
				Forest		:[],
				Grassland	:[],
				Hill		:[],
				Lake		:[],
				Mountain	:[],
				Plain		:[],
				Fog			:[],
				City		:[],
				Outpost		:[],
				Wildernesses:[]
			},
			radius : 35,
			position: {
				x:Seed.cities[CAPITAL_ID].x, 
				y:Seed.cities[CAPITAL_ID].y
			},
			targets: []
		};
	},
	
	setLastNull : function (){
		for (var type in Data.map.terrains) {
			for (var i=0; i<Data.map.terrains[type].length; i++) {
				(Data.map.terrains[type])[i].last = 0;
			}
		}
	},

} // END Tabs.Debug
//*********************************** Debug Tab *********************************************














/********************************************************************************
* Performs the following actions:                                              *
*  - Places all parameters into an object                                      *
*  - Determines method                                                         *
*  - Sets maximum timeout                                                      *
*  - Validates returned data and passes back results to originating function   *
*                                                                              *
* Returns the following data:                                                  *
*  - ok (boolean)                                                              *
*  - dat (object if present)                                                   *
*  - errmsg (string if present)                                                *
********************************************************************************/
function MyAjaxRequest(url, params, callback, isPost) {

	var options = {onSuccess:onSuccess, onFailure:onFailure, on403:on403};
	var ajax, msg, headers={};
	
	options.method = (isPost) ? 'POST' : 'GET';
	options.parameters = params;
	options.timeoutSecs = 45;
	
	function onSuccess(r) {
		if (r.status === 200 && r.responseText) {
			if (url.indexOf(".xml") !== -1) {
				callback({ok:true, dat:r.responseText});
			} else {
				var data;
				try {
					data= JSON.parse( r.responseText );
				} catch (e) {}
				callback({ok:true, dat:data});
			}
		} else {
			msg = 'The request was successful but no data was returned';
			callback({ok:false, errmsg:msg});
		}
	}
	
	function onFailure(r) {
		var res = {
			ok		: false,
			status	: r.status,
			errmsg	: r.statusText,
		};
		if (r.status > 200 && r.responseText) {
			res.dat = r.responseText;
		} else if (r.status == 509 && !r.responseText) {
			res.errmsg = 'Rate Limit Exceeded, too many requests!';
		} else {
			res.errmsg = 'This browser is not compatible at this time';
		}
		callback(res);
	}
	
	function on403 (r) {
		dialogFatal('<b>' + kFatalSeedTitle + '</b><br><br>'
					+'<br>'
					+'<font color="#C00"><b> ' + r.statusText + '</b></font>'
					+'<br><br><div align=left>'
					+'<b>Previous Requirements</b><br><br>'
					+'<b>FIREFOX</b>'
					+'<ul><li>Download and install <a href="https://addons.mozilla.org/es-ES/firefox/addon/refcontrol/">RefControl</a>'
					+'</li><li>Once installed click Tools - RefControlOptions'
					+'</li><li>Click Add Site and type in <b>wonderhill.com</b>'
					+'</li><li>Check the Block - Send no referer radio box'
					+'</li><li>Click OK and then OK again'
					+'</li></ul><br>'
					+'<b>CHROME</b>'
					+'<ul><li>Right click on your "Chrome" icon (either on your Desktop or your Taskbar)'
					+'</li><li>Choose properties'
					+'</li><li>At the end of your target line, place these parameters: <b>--no-referrers</b>'
					+'</li><li>Click OK'
					+'</li></ul><br><br></div>'
					+'<a id="' + UID['support_link'] + '" href="" target="_blank">Bugs and Known Issues</a><br>');
		var res = {
			ok		: false,
			status	: r.status,
			errmsg	: r.statusText,
		};
		callback(res);
	}

	ajax = new AjaxRequest (C.attrs.apiServer +'/'+ url, options);

}

/********************************************************************************
* Performs the following actions:                                              *
*  - Generates an appropriate request header                                   *
*  - Parses the request parameters                                             *
*  - Sends the actual request                                                  *
*  - Determines if request was successful based on returned status only        *
*  - Handles a request timed out condition                                     *
*                                                                              *
* Returns the following data:                                                  *
*  - responseText (should be JSON but could be almost anything)                *
*  - status (integar)                                                          *
*  - statusText (string if present)                                            *
*  - ajax (raw ajax request)                                                   *
********************************************************************************/	
function AjaxRequest(url, opts) {
	var timer = null, ajax, headers = {}, h, params;
	
	// Parse request parameters
	//params = Object.toQueryString(opts.parameters).replace(/\_/g,'%5F');
	params = typeof opts === 'string' ? opts.parameters : Object.toQueryString(opts.parameters).replace(/\_/g,'%5F');

	// Change Accept request header based on browser
	if (IsChrome) {
		headers['Accept'] = '*/*';
	} else {
		headers['Accept'] = 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8';
	}
	
	// Add request header specific to POST request only
	if (opts.method == 'POST') {
		headers['content-type'] = 'application/x-www-form-urlencoded';
		//headers['Origin'] = 'http://castlemania-production.s3.amazonaws.com';  // Jawz - Force Origin parameter
		headers['x-s3-aws'] = SHA1("Dracunculiasis" + params + "LandCrocodile" + url  + "Bevar-Asp");
	} else {
		url += (url.include('?') ? '&' : '?') + params;
	}
	
	ajax = new XMLHttpRequest();

	ajax.onreadystatechange = function () {
		if (ajax.readyState === 4) {
			clearTimeout(timer);
			var response = {
				responseText	: ajax.responseText,
				status			: ajax.status,
				statusText		: ajax.statusText,
				ajax			: ajax
			}
			if ((ajax.status >= 200 && ajax.status < 300) || ajax.status === 304) {
				if (opts.onSuccess) {
					opts.onSuccess (response);
				}
			} else {
				if (opts.onFailure) {
					opts.onFailure (response);
				}
				if ( opts['on' + ajax.status] ) {
					opts['on' + ajax.status] (response);
				}
			}
		} 
	} 
	
	ajax.open(opts.method, url, true);
	
	// Add request headers to ajax request
	for (h in headers) {
		ajax.setRequestHeader(h, headers[h]);
	}
	
	// Start timeout check before request is sent
	if (opts.timeoutSecs) {
		timer = setTimeout(timedOut, opts.timeoutSecs*1000);
	}
	
	// Send request with params if POST otherwise just send request
	if (opts.method == 'POST') { 
		ajax.send(params);
	} else if (opts.method == 'GET') {
		ajax.send();
	}

	function timedOut() {
		ajax.abort();
		if (opts.onFailure) {
			// CHECK: 599 is custom error code. See if better option exists.
			opts.onFailure({responseText:null, status:599, statusText:'Request Timed Out', ajax:ajax});
		}
	}
}


function dialogConfirm (msg, onContinue, onCancel, two_buttons){
	var save_popUp	= {x:Data.options.popUp.x, y:Data.options.popUp.y};
	var confirmPop = new PopUp ('newversion', 800+Math.randRange(1,50), 300, 300, 150, true); //, canNotify);
	confirmPop.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>'+ scriptName +': ' + translate('Confirmation') + '!</b></center></div>';
	var layoutDiv = document.createElement('div');
	layoutDiv.className = 'container';
	layoutDiv.style.backgroundColor = 'rgb(245,245,228)';
 	layoutDiv.style.color = '#000';
	layoutDiv.style.height = '100%';
	var layout = '<table align=center valign=center style="height: 100%">'
				+'<tr align=center height=60%>'
				+'<td>'+ msg +'</td>'
				+'</tr>'
				+'<tr align=center>'
				+'<td>'
				+'<input id='+setUID('btn_ok')+' type=button class=confirm_button value="'+ translate('OK') +'" />';
	if (two_buttons) {
		layout += '	&nbsp; &nbsp;'
				+'<input id='+setUID('btn_cancel')+' type=button class=confirm_button value='+ translate('Cancel') +' />';
	}
	layout += '</td></tr></table>';
	if (confirmPop.getMainDiv().lastChild)
		confirmPop.getMainDiv().removeChild(confirmPop.getMainDiv().lastChild);
	confirmPop.getMainDiv().appendChild(layoutDiv);
	layoutDiv.innerHTML = layout;

	document.getElementById(UID['btn_ok']).addEventListener ('click', function (){
		confirmPop.show(false); 
		Data.options.popUp = {x:save_popUp.x, y:save_popUp.y};
		if (onContinue && typeof(onContinue) == "function") onContinue();
	}, false);

	if (two_buttons) {
		document.getElementById(UID['btn_cancel']).addEventListener ('click', function (){
			confirmPop.show(false); 
			Data.options.popUp = {x:save_popUp.x, y:save_popUp.y};
			if (onCancel && typeof(onContinue) == "function") onCancel();
		}, false);
	}
	confirmPop.show(true);
}

function updaterConfirm (msg, onContinue, onCancel, two_buttons){
	var save_popUp	= {x:Data.options.popUp.x, y:Data.options.popUp.y};
	var updaterPop = new PopUp ('updater', 800+Math.randRange(1,50), 300, 300, 150, true); //, canNotify);
	updaterPop.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>'+ scriptName +': ' + translate('Confirmation') + '!</b></center></div>';
	var layoutDiv = document.createElement('div');
	layoutDiv.className = 'container';
	layoutDiv.style.backgroundColor = 'rgb(245,245,228)';
 	layoutDiv.style.color = '#000';
	layoutDiv.style.height = '100%';
	var layout = '<table align=center valign=center style="height: 100%">'
				+'<tr align=center height=60%>'
				+'<td>'+ msg +'</td>'
				+'</tr>'
				+'<tr align=center>'
				+'<td>'
				+'<input id='+setUID('btn_ok')+' type=button class=confirm_button value="'+ translate('OK') +'" />';
	if (two_buttons) {
		layout += '	&nbsp; &nbsp;'
				+'<input id='+setUID('btn_cancel')+' type=button class=confirm_button value='+ translate('Cancel') +' />';
	}
	layout += '</td></tr></table>';
	if (updaterPop.getMainDiv().lastChild)
		updaterPop.getMainDiv().removeChild(updaterPop.getMainDiv().lastChild);
	updaterPop.getMainDiv().appendChild(layoutDiv);
	layoutDiv.innerHTML = layout;

	document.getElementById(UID['btn_ok']).addEventListener ('click', function (){
		updaterPop.show(false); 
		Data.options.popUp = {x:save_popUp.x, y:save_popUp.y};
		if (onContinue && typeof(onContinue) == "function") onContinue();
	}, false);

	if (two_buttons) {
		document.getElementById(UID['btn_cancel']).addEventListener ('click', function (){
			updaterPop.show(false); 
			Data.options.popUp = {x:save_popUp.x, y:save_popUp.y};
			if (onCancel && typeof(onContinue) == "function") onCancel();
		}, false);
	}
	updaterPop.show(true);
}

function dialogFatal(msg) {
	var pop = new PopUp('fatal', 800+Math.randRange(1,50), 300, 400,300, true);
	pop.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>'+ scriptName +': ' + translate('Error') + '!</b></center></div>';
	var layoutDiv = document.createElement('div');
	layoutDiv.className = 'container';
	layoutDiv.style.backgroundColor = 'rgb(245,245,228)';
 	layoutDiv.style.color = '#000';
	layoutDiv.style.height = '100%';
	var layout = '<div style="height:270px; max-height:270px; overflow-y:auto">'
				+'<table width=100%><tr align=center><td width=96%><BR>' + msg + '</td></tr></table></div>';
	pop.getMainDiv().appendChild(layoutDiv);
	layoutDiv.innerHTML = layout;
	pop.show(true);

	document.getElementById(UID['support_link']).addEventListener('click', redirect, false);
	
	function redirect() {
		window.open(scriptUrlError, 'MMOG Wiki');
	}
}

// TODO: add 'Retry Now' button
var rTimer;
var cdTimer;
function dialogRetry (errMsg, seconds, onRetry, onCancel){
	var secs, pop;

	secs = parseInt(seconds);
	pop = new PopUp ('retry', 0, 0, 400,200, true);
	pop.centerMe(mainPop.getMainDiv());
	pop.getTopDiv().innerHTML = '<CENTER>'+ scriptName +'</center>';
	pop.getMainDiv().innerHTML = '<CENTER><BR><FONT COLOR=#550000><B>'+ translate('An error has occurred:') +'</b></font><BR><BR><DIV id=paretryErrMsg></div>\
		<BR><BR><B>'+ translate('Retry in') +' <SPAN id=paretrySeconds></b></span> '+ translate('Seconds') +'...<BR><BR><INPUT id=paretryCancel type=button value="'+ translate('Cancel').toUpperCase +' '+ translate('Retry') +'" />';
	document.getElementById('paretryCancel').addEventListener ('click', doCancel, false);
	pop.show(true);
	document.getElementById('paretryErrMsg').innerHTML = errMsg;
	document.getElementById('paretrySeconds').innerHTML = secs;
	rTimer = setTimeout (doRetry, secs*1000);
	cdTimer = null;
	countdown ();

	function countdown (){
		document.getElementById('paretrySeconds').innerHTML = secs--;
		if (secs > 0)
			cdTimer = setTimeout (countdown, 1000);
	}
	function doCancel(){
		clearTimeout (rTimer);
		clearTimeout (cdTimer);
		pop.destroy();
		onCancel ();
	}
	function doRetry (){
		clearTimeout (rTimer);
		clearTimeout (cdTimer);
		pop.show(false);
		onRetry();
	}
}


function dispError (msg,target){
	var target = target != undefined ? target : document.body;
	var dial = new ModalDialog (target, 300, 150, '', true);
	dial.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + translate('Error') + '</b></center></div>';
	dial.getContentDiv().innerHTML = msg;
}

// Jawz
function checkPoint(msg) { 
  if (KABAM_CHECK) logit ('Kabam Checkpoint : '+msg);
}
// End Jawz

function logit(msg) {
	var serverID = SERVER_ID;
	var now = new Date();
	console.log(serverID + ' @ ' + now.toTimeString().substring (0,8) + '.' + now.getMilliseconds() + ': ' +  msg);
	if (Data.log) consoleLog(msg.replace(/\n/g, '<br/>'));
}


// Random scriptTitle
function makeRandomTitle(){
	/*
	var len = wordArr.length-1;
	var w1 = Math.ceil (Math.random() * len);
	var w2 = Math.ceil (Math.random() * len);
	scriptTitle = translate(wordArr[w1]) +' '+ translate(wordArr[w2]);
	*/
	scriptTitle = scriptName.split('');
	var tags = ['SPAN','FONT','BDO','CENTER','DIV','LABEL','B','STRONG','P','TD'];
	var len = tags.length-1;
	var newTitle = [];
	
	for (var i=0; i < scriptTitle.length; i++){
		if(scriptTitle[i]==' ') newTitle.push('&nbsp;');
		var t = tags[Math.ceil (Math.random() * len)];
		newTitle.push( '<' + t + '>' + scriptTitle[i] + '</' + t + '>');
	}
	scriptTitle = '<span class='+ UID['title'] +'>' + newTitle.join('') + '<span>';
}



// CLASS!
function ModalDialog (curtainDiv, width, height, styleName, allowClose, notifyClose){
	this.allowClose = function (onOff){
		if (onOff)
			document.getElementById(UID['ModalDialog_btnClose']).style.display = 'block';
		else
			document.getElementById(UID['ModalDialog_btnClose']).style.display = 'none';
	}
	this.destroy = function (){
		if (!this.destroyed){
			this.curtainDiv.removeChild(this.curtain);
			this.curtainDiv.removeChild(this.div);
		}
	}
	this.hide = function (){
		this.curtainDiv.style.display='none';
		this.curtainDiv.style.display='none';
	}
	this.show = function (){
		this.curtainDiv.style.display='block';
		this.curtainDiv.style.display='block';
	}

	this.getContentDiv = function (){
		return document.getElementById(UID['ModalDialog_Close']);
	}
	this.getTopDiv = function (){
		return document.getElementById(UID['ModalDialog_Top']);
	}

	//var offset = $(curtainDiv).positionedOffset();
	var offset = Element.positionedOffset(curtainDiv);
	this.curtainDiv = curtainDiv;
	this.curtain = document.createElement ('div');
	this.curtain.style.top = (offset.top) +'px';
	this.curtain.style.left = (offset.left) + 'px';
	this.curtain.style.width = curtainDiv.offsetWidth +'px';
	this.curtain.style.height = (curtainDiv.offsetHeight) +'px';
	this.curtain.style.backgroundColor = '#000';
	this.curtain.style.opacity = '0.6';
	this.curtain.style.zIndex = parseInt(curtainDiv.style.zIndex) + 1;
	this.curtain.style.position = 'absolute';
	this.curtain.style.margin = curtainDiv.style.margin;
	this.curtain.style.padding = curtainDiv.style.padding;
	curtainDiv.appendChild (this.curtain);

	this.div = document.createElement('div');
	if (styleName)
		this.div.className = styleName;
	else {
		this.div.className = 'container';
//		this.div.style.backgroundColor = 'white';
//		this.div.style.border = '1px solid black';
	}
	this.div.style.backgroundColor = 'rgb(245,245,228)';
	this.div.style.color = '#000';
	this.div.style.width = width +'px';
	this.div.style.height = height +'px';
	this.div.style.position = 'absolute';
	this.div.style.zindex = parseInt(curtainDiv.style.zIndex) + 2;
	this.div.style.top = ((curtainDiv.offsetHeight-height)/2 + offset.top) + 'px';
	this.div.style.left = ((curtainDiv.offsetWidth-width)/2 + offset.left) + 'px';

	this.div.innerHTML = ''
		+'<table height=100% width=100%>'
		+'	<tr valign=middle height=10%>'
		+'		<td width=100% valign=top>'
		+'		<div id='+ setUID('ModalDialog_Top') +' class="'+UID['popup_top']+'"></div>'
		+'		</td>'
		+'	</tr>'
		+'	<tr valign=middle height=70%>'
		+'		<td>'
		+'		<div id='+ setUID('ModalDialog_Close') +' style="text-align:center"></div>'
		+'		</td>'
		+'	</tr>'
		+'	<tr valign=middle align=center>'
		+'		<td style="text-align:center;">'
		+'		<input id='+ setUID('ModalDialog_btnClose') +' type=button value="' + translate('Close') + '" style="display:none" />'
		+'		</td>'
		+'	</tr>'
		+'</table>';
	curtainDiv.appendChild(this.div);
	this.allowClose(allowClose);
	this.notifyClose = notifyClose;
	var t = this;
	document.getElementById(UID['ModalDialog_btnClose']).addEventListener('click', function (){
		t.destroyed = true;
		t.curtainDiv.removeChild(t.curtain);
		t.curtainDiv.removeChild(t.div);
		if (t.notifyClose)
			notifyClose();
	}, false);
}

var tabManager = {
	tabList : {},           // {name, obj, div}
	currentTab : null,

	init : function (mainDiv){
		var t = tabManager;
		var sorter = [];
		for (k in Tabs){
			// Jawz
			if ((k == 'Waves'     && isEmpty(Data.options.disable_wave, !WAVE_TAB_ENABLE)) ||
				(k == 'Multiple'  && isEmpty(Data.options.disable_multi, !MULTI_TAB_ENABLE)) ||
				(k == 'Spies'     && isEmpty(Data.options.disable_spies, !SPY_TAB_ENABLE)) ||
				(k == 'Search'    && isEmpty(Data.options.disable_search, !SEARCH_TAB_ENABLE)) ||
				(k == 'Battle'    && isEmpty(Data.options.disable_battle, !BATTLE_TAB_ENABLE)) ||
				(k == 'Alliance'  && isEmpty(Data.options.disable_alliance, !ALLIANCE_TAB_ENABLE)) ||
				(k == 'Log'       && isEmpty(Data.options.disable_log, !LOG_TAB_ENABLE)))
				Tabs[k].tabDisabled = true;
			else if (k == 'Waves' || k == 'Multiple' || k == 'Spies' || k == 'Search' || k == 'Battle' || k == 'Alliance' || k == 'Log')
				Tabs[k].tabDisabled = false;
			// End Jawz
			if (!Tabs[k].tabDisabled){
				t.tabList[k] = {};
				t.tabList[k].name = k;
				t.tabList[k].uid = setUID('tab_' + k);
				t.tabList[k].obj = Tabs[k];
				if (Tabs[k].tabLabel != null)
					t.tabList[k].label = translate(Tabs[k].tabLabel);
				else
					t.tabList[k].label = k;
				if (Tabs[k].tabOrder != null)
					sorter.push([Tabs[k].tabOrder, t.tabList[k]]);
				else
					sorter.push([1000, t.tabList[k]]);
				t.tabList[k].div = document.createElement('div');
			}
		}

		sorter.sort (function (a,b){return a[0]-b[0]});

		// Jawz
		var ntabs = sorter.length;
		if (ntabs > 10) { var line1 = 10; var addStyle = 'style="border-bottom:none; padding-bottom:0;"'; var addClass = ' line1'; }
		else { var line1 = sorter.length; var addStyle = ''; var addClass = ''; }
		// End Jawz
		var m = '<ul class=tabs '+addStyle+'>'; // Jawz - Adding more style if tabs display on 2 lines
		m += '<li class="tab first'+addClass+'"><a id='+ sorter[0][1].uid +'>'+ sorter[0][1].label +'</a></li>';
		for (var i=1; i<line1; i++)  // Jawz - Replace sorter.length by nline1
			m += '<li class="tab'+addClass+'"><a id='+ sorter[i][1].uid +'>'+ sorter[i][1].label +'</a></li>';
		m += '</ul>';
		// Jawz
		if (sorter.length > line1) {
			m += '<ul class="tabs line2">';
			for (var i=line1; i<sorter.length; i++) {
				if (i==line1) var addClass = ' first';
				else var addClass = '';
				m += '<li class="tab line2'+addClass+'"><a id='+ sorter[i][1].uid +'>'+ sorter[i][1].label +'</a></li>';
			}
			m += '</ul>';
		}
		// End Jawz
		m += '<div id=' + setUID('jawz_SwfPlyr') + '></div>';  // Jawz
		mainPop.getTopDiv().innerHTML = m;
		
		t.currentTab = null;
		for (k in t.tabList) {
			if (t.tabList[k].name == Data.options.currentTab)
				t.currentTab = t.tabList[k] ;
			document.getElementById(t.tabList[k].uid).addEventListener('click', this.e_clickedTab, false);
			var div = t.tabList[k].div;
			div.className = 'container';
			div.style.display = 'none';
			//div.style.maxWidth = document.getElementById(t.tabList[k].uid).parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.style.width;
			mainDiv.appendChild(div);
			try {
				t.tabList[k].obj.init(div);
			} catch (e){
				div.innerHTML += "INIT ERROR: "+ e;
			}
		}
		if (t.currentTab == null)
			t.currentTab = sorter[0][1];    
		t.setTabStyle (document.getElementById (t.currentTab.uid), true);
		t.currentTab.div.style.display = 'block';
	},

	hideTab : function (){
		var t = tabManager;
		t.currentTab.obj.hide();
	},

	showTab : function (){
		var t = tabManager;
		t.currentTab.obj.show();
	},
		
	setTabStyle : function (e, selected){
		if (selected){
			e.style.zIndex = 1;
			e.className = 'tab selected';
		} 
		else {
			e.style.zIndex = 0;
			e.className = 'tab';
		}
	},

	e_clickedTab : function (e){
		var t = tabManager;
		for (k in t.tabList)
			if (t.tabList[k].uid == e.target.id) {
				var newTab = t.tabList[k];
				break;
			}
		if (t.currentTab.name != newTab.name){
			t.setTabStyle (document.getElementById (newTab.uid), true);
			t.setTabStyle (document.getElementById (t.currentTab.uid), false);
			t.currentTab.obj.hide ();
			t.currentTab.div.style.display = 'none';
			t.currentTab = newTab;
			newTab.div.style.display = 'block';
			Data.options.currentTab = newTab.name;      
		}
		newTab.obj.show();
	}
}


function titleLine (msg){
	return '<table cellpadding=0 cellspacing=0 width=100%><tr><td width=50%><HR></td><td> '+ msg +' </td><TD width=50%><HR></td></tr></table>';
}


var WINLOG_MAX_ENTRIES = 1000;     // TODO
var WinLog = {
	state : null,
	win: null,
	eOut : null,
	lastE : null,
	enabled : true,
	reverse : true,
	busy : false,
	isOpening : false,
	lineNum : 0,

	open : function (){
		var t = WinLog;

		function eventButClear(){
			var t = WinLog;
			t.lastE = null;
			t.eOut.innerHTML ='';
			t.lineNum = 0;
		}
		function eventButReverse(){
			var t = WinLog;
			if (t.busy)
				return;
			t.busy = true;
			if (t.reverse){
				t.win.document.getElementById('wlRev').value= 'Top';
				t.reverse = false;
			} 
			else{
				t.win.document.getElementById('wlRev').value= 'Bottom';
				t.reverse = true;
			}
			var n = t.eOut.childNodes.length;
			if (n < 2)
				return;
			for (i=n-2; i>=0; i--){
				t.eOut.appendChild (t.eOut.childNodes[i]);
			}
			t.busy = false;
		}
		
		if (!t.win || t.win.closed){
			t.isOpening = true;  
			// Firefox bug??? It appears as if a new thread is started on open, withOUT reusing same window
			t.win = window.open('', 'uwtrace', 'top=30,left=0,width=900,height=700,scrollbars=no,location=no,menubar=no,directories=no,status=no');
			t.isOpening = false; 
			t.state = null; 
		}
		
		if (t.state == null){
			t.win.document.body.innerHTML = '\
				<STYLE>pre{margin:0px} hr{margin:3px; height:1px; border:0px; color:#cee; background-color:#cee}</style>\
				<BODY style="margin:0px; padding:0px; border:none">\
				<DIV id=winlogtop style="background-color:#d0d0d0; margin:0px; padding:0px; border:1px solid">\
				<INPUT id=wlClear type=button value="'+translate('Delete')+'" /> &nbsp; <INPUT id=wlRev type=button value="Bottom" ></div>\
				<DIV id=wlOut style="overflow-y:auto; height:100%; max-height:100%"></div></body>';
			t.win.document.getElementById('wlClear').addEventListener('click', eventButClear, false);
			t.win.document.getElementById('wlRev').addEventListener('click', eventButReverse, false);
			t.eOut =  t.win.document.getElementById('wlOut');
			t.lastE = null;
			t.state = 1;
		}
	},


	writeText : function (msg){
		WinLog.write (msg.escapeHTML()); 
	},

	write : function (msg){
		var t = WinLog;
		if (!t.enabled || t.isOpening)
		return;
		t.open();
		var te = document.createElement('pre');
		if (++t.lineNum % 2)    
		te.style.backgroundColor = '#eeeeee'; 
		else
		te.style.backgroundColor = '#ffffff'; 
		var now = new Date();
		var m = [];
		var millis = now.getMilliseconds();
		m.push (now.toTimeString().substring (0,8));
		m.push ('.');
		if (millis<100)
		m.push('0');
		if (millis<10)
		m.push('0');
		m.push(millis);
		m.push (': ');
		m.push (msg);
		te.innerHTML = m.join('');

		if (t.reverse){
		if (t.lastE == null){
			t.eOut.appendChild(te);
			t.lastE = te;
		} 
		else {
			t.eOut.insertBefore(te, t.lastE);
		}
		var hr = document.createElement('hr');
		t.eOut.insertBefore(hr, te);
		t.lastE = hr;
		} 
		else {
		t.eOut.appendChild(te);
		t.eOut.appendChild(document.createElement('hr'));
		}
	}
};



var WinManager = {
	wins : {},    // prefix : PopUp obj

	get : function (prefix){
		var t = WinManager;
		return t.wins[prefix];
	},

	add : function (prefix, pop){
		var t = WinManager;
		t.wins[prefix] = pop;
	},

	delete : function (prefix){
		var t = WinManager;
		delete t.wins[prefix];
	}    
}


// creates a 'popup' div
// prefix must be a unique (short) name for the popup window
function PopUp (prefix, x, y, width, height, enableDrag, onClose) {
	var pop = WinManager.get(prefix);
	if (pop){
		pop.show (false);
		return pop;
	}
	this.BASE_ZINDEX = 100;
		
	// protos ...
	this.show = show;
	this.toggleHide = toggleHide;
	this.getTopDiv = getTopDiv;
	this.getMainDiv = getMainDiv;
	this.getLayer = getLayer;
	this.setLayer = setLayer;
	this.setEnableDrag = setEnableDrag;
	this.getLocation = getLocation;
	this.setLocation = setLocation;
	this.focusMe = focusMe;
	this.unfocusMe = unfocusMe;
	this.centerMe = centerMe;
	this.destroy = destroy;
	this.setModal = setModal;

	// object vars ...
	this.div = document.createElement('div');
	document.body.appendChild(this.div);
	
	this.prefix = prefix;
	this.onClose = onClose;

	if ( x < 0 || x > document.body.offsetWidth) x = 0;  // Jawz : Changed X calculation (based on left)
	if ( y < 0 || y > document.body.offsetHeight) y = 0;

	// Scramble
	rndPopup = ['outer', 'bar', 'top', 'main', 'close'];
		
	for (var s=0; s<rndPopup.length; s++) {
		rndPopup[rndPopup[s]] = setUID(prefix + '_' + rndPopup[s]);
	}

	var t = this;
	this.div.id = rndPopup['outer'];
	this.div.className = UID['popup_outer'];
	this.div.style.zIndex = this.BASE_ZINDEX;
	this.div.style.position = 'absolute';
	this.div.style.display = 'none';
	this.div.style.width = width + 'px';
	this.div.style.height = height + 'px';
	this.div.style.top = (y||0) + 'px';
	this.div.style.left = (x||0) + 'px';  // Jawz : Changed X calculation (based on left)

	// consoleLog(x+' = '+this.div.style.left);  // Jawz : Changed X calculation (based on left)
		
	var m = '<span id='+ rndPopup['close'] +' class="'+UID['popup_close']+'">X</span>\
			<TABLE cellspacing=0 width=100% height=100%>\
			<TR id="'+ rndPopup['bar'] +'" class="'+UID['popup_bar']+'">\
				<TD width=100% valign=bottom>\
				<SPAN id="'+ rndPopup['top'] +'" class="'+UID['popup_top']+'"></span></td>\
			</tr>\
			<TR><TD height=100% valign=top colspan=2 id="'+ rndPopup['main'] +'" class="'+UID['popup_main']+'" style="background-image:url(\'' + urlBackgroundImage + '\')"></td></tr></table>'; // Jawz - added background image

	this.div.innerHTML = m;
	
	document.getElementById(rndPopup['close']).addEventListener ('click', e_XClose, false);
	
	if (enableDrag) {
		this.dragger = new Draggable(this.div, { 
			handle		: rndPopup['bar'], 
			scroll		: window,
			onEnd		: function(dragger, event){
				var el = dragger.element;
				var offset = Element.cumulativeOffset(el);
				// Data.options.popUp.x = (offset.left + el.offsetWidth) - document.body.offsetWidth;  // Jawz : Changed X calculation (based on left)
				Data.options.popUp.x = offset.left;  // Jawz : Changed X calculation (based on left)
				Data.options.popUp.y = offset.top;
			}
		});
	}

	this.div.addEventListener ('mousedown', e_divClicked, false);
	WinManager.add(prefix, this);

	function setModal (onOff){
	}

	function e_divClicked (){
		t.focusMe();
	}  
	function e_XClose (){
		t.show(false);
		if (t.onClose != null)
			t.onClose();
	}

	function focusMe (){
		t.setLayer(5);
	}
	function unfocusMe (){
		t.setLayer(-5);
	}

	function getLocation() {
		return {x: parseInt(this.div.style.left), y: parseInt(this.div.style.top)};  // Jawz : Changed X calculation (based on left)
	}

	function setLocation (loc){
		t.div.style.left = loc.x +'px';  // Jawz : Changed X calculation (based on left)
		t.div.style.top = loc.y +'px';
	}
	function destroy (){
		document.body.removeChild(t.div);
		WinManager.delete (t.prefix);
	}
	function centerMe (parent){
		if (parent == null){
			var coords = Element.cumulativeOffset(document.body);
		} 
		else
		var coords = Element.cumulativeOffset(parent);
		var left = ((document.body.offsetWidth - parseInt(t.div.style.width)) / 2) + coords.left;
		var top = ((document.body.offsetHeight - parseInt(t.div.style.height)) / 2) + coords.top;
		if (left<0)
			left = 0;
		if (top<0)
			top = 0;
		t.div.style.left = x +'px';
		t.div.style.top = y +'px';
	}
	function setEnableDrag (b){
		//t.dragger.draggable(b);
		Data.options.popUp.drag = b;
	}
	function setLayer(zi){
		t.div.style.zIndex = ''+ (this.BASE_ZINDEX + zi);
	}
	function getLayer(){
		return parseInt(t.div.style.zIndex) - this.BASE_ZINDEX;
	}
	function getTopDiv(){
		return document.getElementById(rndPopup['top']);
	}
	function getMainDiv(){
		return document.getElementById(rndPopup['main']);
	}
	function show(b){
		if (b){
			t.div.style.display = 'block';
			t.focusMe ();
		} 
		else {
			t.div.style.display = 'none';
		}
		return b;
	}
	function toggleHide(t){
		if (t.div.style.display == 'block') {
			return t.show (false);
		} 
		else {
			return t.show (true);
		}
	}
}




//************ Prototype Functions **************
Object.defineProperty(Object.prototype, "cleanRemoved", {
    enumerable: false,
    value: function () {
		 // Create a new array from the contents of arguments
		var args = Array.prototype.slice.call(arguments);
		var obj  = this,
            from = args.shift(),
			max_depth = 0,
			path,
			depth = 0;
		if ( typeof ( from ) == 'undefined' ) return;
		if ( typeof( args[0] ) == 'number' ) {
			max_depth = args.shift()
		}
		if ( typeof( args[0] ) == 'number' ) {
			depth = args.shift()
		}
		path = args[0] || '';
		if ( max_depth ) {
			if ( depth >= max_depth ) return;
			depth++;
		}
		if ( typeof( obj ) == "object" && typeof( from ) == "object") {
			Object.getOwnPropertyNames( obj ).forEach( function ( name ) 
			{
				if ( obj [ name ] != null && typeof( obj [ name ] ) == "object" && typeof( from [ name ] ) == "object" ) 
				{
					obj [ name ].cleanRemoved ( from [ name ], max_depth, depth, path + name + '.' );
				} 
				else if ( typeof( from[ name ] ) == 'undefined' ) {
					var msg = path + name + '  DELETED!';
					console.log( msg );
					delete obj[ name ];
				}
			});
		}
        return this;
    }
});
Object.defineProperty(Object.prototype, "mergeWith", {
    enumerable: false,
    value: function () {
        var override = true,
            dest = this,
            len = arguments.length,
            props, merge, i, from;

        if (typeof(arguments[arguments.length - 1]) === "boolean") {
            override = arguments[arguments.length - 1];
            len = arguments.length - 1;
        }

        for (i = 0; i < len; i++) {
            from = arguments[i];
			if (from == undefined) continue;
			if (from != null || typeof(from) == "object") {
				Object.getOwnPropertyNames(from).forEach(function (name) {
					var descriptor;

					// nesting
					if ((typeof(dest[name]) == "object" || typeof(dest[name]) == "undefined")
							&& typeof(from[name]) == "object") {

						// ensure proper types (Array rsp Object)
						if (typeof(dest[name]) == "undefined") {
							dest[name] = Array.isArray(from[name]) ? [] : {};
						}
						if (override) {
							if (!Array.isArray(dest[name]) && Array.isArray(from[name])) {
								dest[name] = [];
							}
							else if (Array.isArray(dest[name]) && !Array.isArray(from[name])) {
								dest[name] = {};
							}
						}
						if (dest[name] != undefined) {
							dest[name].mergeWith(from[name], override);
						}
					}

					// flat properties
					else if ((name in dest && override) || !(name in dest)) {
						descriptor = Object.getOwnPropertyDescriptor(from, name);
						if (descriptor.configurable) {
							Object.defineProperty(dest, name, descriptor);
						}
					}
				});
			} else {
				dest = from;
			}
        }
        return this;
    }
});

Array.prototype.compare = function(testArr) {
	if (this.length != testArr.length) return false;
	for (var i = 0; i < testArr.length; i++) {
		if (this[i].compare) { 
			if (!this[i].compare(testArr[i])) return false;
		}
		if (this[i] !== testArr[i]) return false;
	}
	return true;
}
Date.prototype.myString = function (){
	return this.toDateString() +' '+ this.toTimeString().substr (0,8);
}
// Jawz
Date.prototype.formatTime = function (){
	var curr_hour = this.getHours();
	var curr_min = this.getMinutes();
	var curr_sec = this.getSeconds();
	return (curr_hour < 10 ? '0' : '') + curr_hour + gFormatTime + (curr_min < 10 ? '0' : '') + curr_min + gFormatTime + (curr_sec < 10 ? '0' : '') + curr_sec;
}
Date.prototype.formatDate = function (){
	var curr_day = this.getDate();
	var curr_month = this.getMonth();
	curr_month++;
	var curr_year = this.getFullYear();
	return (curr_day < 10 ? '0' : '') + curr_day + gFormatDate + (curr_month < 10 ? '0' : '') + curr_month + gFormatDate + curr_year;
}
Math.randRange = function(from, to){
 return Math.floor( ( Math.random() * (to-from+1) ) + from);
}
// End Jawz
Number.prototype.intToCommas = function(){
	var nStr = parseInt(this) + '';
	var rgx = /(\d+)(\d{3})/;
	while (rgx.test(nStr)) {
		nStr = nStr.replace(rgx, '$1' + ',' + '$2');
	}
	return nStr;
}
String.prototype.escapeHTML = function() {
	return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;');
}
String.prototype.intToCommas = function(){
	return parseInt(this);
}
String.prototype.nowrap = function()
{
	return this.replace(/\s/g,'&nbsp;');
}
String.prototype.strip = function() {
	return this.replace(/^\s+/, '').replace(/\s+$/, '');
}


//************ Functions **************

function addCommas(nStr){
	nStr += '';
	x = nStr.split('.');
	x1 = x[0];
	x2 = x.length > 1 ? '.' + x[1] : '';
	var rgx = /(\d+)(\d{3})/;
	while (rgx.test(x1)) {
		x1 = x1.replace(rgx, '$1' + ',' + '$2');
	}
	return x1 + x2;
}

function addScript (scriptText){
	var scr = document.createElement('script');   
	scr.innerHTML = scriptText;
	document.body.appendChild(scr);
//    setTimeout ( function (){document.body.removeChild(scr);}, 500);
}

function addStyle(css) {
	var target = document.getElementsByTagName('head')[0];
	if (target.getElementsByTagName('style').length > 0)
		target.removeChild(target.getElementsByTagName('style')[0]);
	var obj = document.createElement('style');
	obj.type = 'text/css';
	obj.appendChild(document.createTextNode(css));
	target.appendChild(obj);
}

/*function setBaseURL() {
	var baseTags = document.getElementsByTagName('base')[0];
	if (!baseTags || baseTags == undefined) {
		var headTarget = document.getElementsByTagName('head')[0];
		baseTags = headTarget.appendChild(document.createElement('base'));
	}
	baseTags.setAttribute("href", "http://castlemania-production.s3.amazonaws.com");
}
*/
function cloneProps (src) {
	var newObj = (src instanceof Array) ? [] : {};
	for (i in src) {
		if (matTypeof(src[i]) == 'function')
		continue;
		if (src[i] && typeof src[i] == 'object') {
		newObj[i] = cloneProps(src[i]);
		} 
		else 
		newObj[i] = src[i];
	} 
	return newObj;
};

function debugPos  (e){
	return 'client - offset: '+ e.clientRight +','+ e.clientTop +','+ e.clientWidth +','+ e.clientHeight
			+' - '+ e.offsetRight +','+ e.offsetTop +','+ e.offsetWidth +','+ e.offsetHeight +' '+ e +' --OP--> '+ e.offsetParent;
}

DebugTimer = {
	startTime : 0,
	start : function (){
		now = new Date();
		DebugTimer.startTime = now.getTime();
	},
	display : function (label, noReset){
		now = new Date();
		elapsed = now.getTime() - DebugTimer.startTime;
		logit (label +": "+ elapsed/1000);
		if (noReset===null || !noReset)
		DebugTimer.startTime = now.getTime();
	}
};


function decodeEntity (str){
	var ta=document.createElement('textarea');
	ta.innerHTML = str; 
	return ta.value;
}


function findAllBetween (txt, find1, find2){
	var m = [];
	var last = 0;
	while ( (i1=txt.indexOf(find1, last))>=0 && (i2=txt.indexOf (find2, i1))>=0 ) {
		m.push (txt.substring(i1+find1.length, i2));
		last = i2 + find2.length;
	}
	return m;
}

function findSimilarWord (word, source){
	var pattern = new RegExp(RegExp.escape(word)+'[\\w]+', 'i');
	var match = source.match(pattern);
	return match ? match[0].capitalize() : word;
}


// Pythagorean theorum for the hypotenuse of a right triangle
function getDistance (d, f, c, e) {
	var a = 750;
	var g = a / 2;
	var b = Math.abs(c - d);
	if (b > g)
		b = a - b;
	var h = Math.abs(e - f);
	if (h > g)
		h = a - h;
	return Math.round(100 * Math.sqrt(b * b + h * h)) / 100;
};

function getFunctionName (func){
	var name=/\W*function\s+([\w\$]+)\(/.exec(func);
	if (!name)
		return '';
	return name[1];
}

function getKeys( obj ){
	var arr = new Array();
	for (var key in obj) {
		if (obj.hasOwnProperty(key)) {
			arr.push(key);
		}
	}
	return arr;
}

function htmlOptions (a, curVal){
	m = '';
	for (k in a)
		m += '<option value="'+ k +'"'+ (k==curVal?' selected':'')  +'>'+ a[k] +'</option>';
	return m;
}

function htmlSelector (valNameObj, curVal, tags){
	m = [];
	m.push ('<select');
	if (tags){
		m.push (' ');
		m.push (tags);
	}  
	for (k in valNameObj){
		m.push ('><option ');
		if (k == curVal){
			m.push ('selected ');
		}
		m.push ('value="');
		m.push (k);
		m.push ('">');
		m.push (valNameObj[k]);
		m.push ('</option>');
	}
	m.push ('</select>');
	return m.join ('');
}

function htmlTitleLine (msg){
	return '<table><tr><td width=50%><HR></td><td>[ '+ msg +' ]</td><td width=50%><HR></td></tr></table>';  
}

function implodeUrlArgs (obj){
	var a = [];
	for (var k in obj)
		a.push (k +'='+ encodeURI(obj[k]) );
	return a.join ('&');
}

function inspectObj(obj, maxLevels, level, doFunctions){
	var str = '', type, msg;
	if(level == null)  level = 0;
	if(maxLevels == null) maxLevels = 1;
	if(maxLevels < 1)
		return 'Inspect Error: Levels number must be > 0';
	if(obj == null)
		return 'ERROR: Object is NULL\n';
	var indent = '';
	for (var i=0; i<level; i++)
		indent += ' ';
	for(property in obj) {
		try {
			type =  matTypeof(obj[property]);
			if (doFunctions==true && (type == 'function')){
			str += indent + '(' + type + ') ' + property + "[FUNCTION]\n";
			} 
			else if (type != 'function') {
			str += indent + '(' + type + ') ' + property + ( (obj[property]==null)?(': null'):('')) +' = '+ obj[property] +"\n";
			}
			if((type=='object' || type=='array') && (obj[property] != null) && (level+1 < maxLevels))
			str += inspectObj(obj[property], maxLevels, level+1, doFunctions);  // recurse
		}
		catch(err) {
			// Is there some properties in obj we can't access? Print it red.
			if(typeof(err) == 'string') msg = err;
			else if(err.message)        msg = err.message;
			else if(err.description)    msg = err.description;
			else                        msg = 'Unknown';
			str += '(Error) ' + property + ': ' + msg +"\n";
		}
	}
	str += "\n";
	return str;
}
// Jawz - Default value
function isEmpty(obj, defaultval) { 
  if (typeof obj == 'undefined' || obj === undefined || obj === null || obj === '') return defaultval; 
  return obj; 
}
// End Jawz - Default value
function matTypeof (v){
	if (v == undefined)
	return 'undefined';
	if (typeof (v) == 'object'){
		if (!v)
		return 'null';
		else if (v.constructor.toString().indexOf("Array")>=0 && typeof(v.splice)=='function')
		return 'array';
		else return 'object';
	}
	return typeof (v);
}

// Jawz - Number formatting
function nombreFormate (nNombre, separateurMilliers) {
	var sNombre = String(nNombre);
	var i;
	if (separateurMilliers == undefined) separateurMilliers = ' ';
	function separeMilliers (_sNombre) {
		var sRetour = "";
		while (_sNombre.length % 3 != 0) {
			_sNombre = "0"+_sNombre;
		}
		for (i = 0; i < _sNombre.length; i += 3) {
			if (i ==  _sNombre.length-1) separateurMilliers = '';
			sRetour += _sNombre.substr(i, 3)+separateurMilliers;
		}
		while (sRetour.substr(0, 1) == "0") {
			sRetour = sRetour.substr(1);
		}
		return sRetour.substr(0, sRetour.lastIndexOf(separateurMilliers));
	}
	return isEmpty(separeMilliers(sNombre),'0');
}
// End Jawz - Number formatting

function objectName (o){
	var s = o.toString();
	return s.substr(7,s.length-8);
}

function parseIntNan (n){
	var x = parseInt(n, 10);
	return (isNaN(x)) ? 0 : x;
}

function parseIntZero (n){
	return (!n || n=='') ? 0 : parseInt(n, 10);
}

function parseNvQuoted(str){
	var obj = {};
	var pattern = /\s*(.*?)\s*=\s*('|")(.*?)\2/gi;
	var match;
	while ((match = pattern.exec(str)) != null){
		obj[match[1]] = match[3];
	}
	return obj;
}

// Jawz - Allow to reload DOA for the same realm as connected in one click
function reloadTools (){
  var serverId = SERVER_ID;
  if(serverId == '??') window.location.reload(true);
  var goto = REALM_URL+serverId;
  var t = '<FORM target="_top" action="'+ goto +'" method=post><INPUT id=xxpbButReload type=submit value=RELOAD><INPUT type=hidden name=s value="'+ serverId +'"</form>';
  var e = document.createElement ('div');
  e.innerHTML = t;
  document.body.appendChild (e);
  setTimeout (function (){document.getElementById('xxpbButReload').click();}, 0);
}
// End Jawz

function searchDOM (node, condition, maxLevel, doMult){
	var found = [];
	eval ('var compFunc = function (node) { return ('+ condition +') }');
	doOne(node, 1);
	if(!doMult){
		if (found.length==0){
			return null;
		}
		return found[0];
	}

	return found;

	function doOne (node, curLevel){
		try {
			if (compFunc(node)){
				found.push(node);
			}      
		} catch (e){}

		if (!doMult && found.length>0){
			return; 
		}
		if (++curLevel<maxLevel && node.childNodes!=undefined){
			for (var c=0; c<node.childNodes.length; c++){
				doOne (node.childNodes[c], curLevel);
			}
		}
	}
}

function serverTime (){
	return parseInt (new Date().getTime() / 1000) + Seed.serverTimeOffset;
}

function SHA1 (msg) {

	function rotate_left(n,s) {
		var t4 = ( n<<s ) | (n>>>(32-s));
		return t4;
	};

	function lsb_hex(val) {
		var str="";
		var i;
		var vh;
		var vl;

		for( i=0; i<=6; i+=2 ) {
			vh = (val>>>(i*4+4))&0x0f;
			vl = (val>>>(i*4))&0x0f;
			str += vh.toString(16) + vl.toString(16);
		}
		return str;
	};

	function cvt_hex(val) {
		var str="";
		var i;
		var v;

		for( i=7; i>=0; i-- ) {
			v = (val>>>(i*4))&0x0f;
			str += v.toString(16);
		}
		return str;
	};


	function Utf8Encode(string) {
		string = string.replace(/\r\n/g,"\n");
		var utftext = "";

		for (var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			}
			else if((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			}
			else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	};

	var blockstart;
	var i, j;
	var W = new Array(80);
	var H0 = 0x67452301;
	var H1 = 0xEFCDAB89;
	var H2 = 0x98BADCFE;
	var H3 = 0x10325476;
	var H4 = 0xC3D2E1F0;
	var A, B, C, D, E;
	var temp;

	msg = Utf8Encode(msg);

	var msg_len = msg.length;

	var word_array = new Array();
	for( i=0; i<msg_len-3; i+=4 ) {
		j = msg.charCodeAt(i)<<24 | msg.charCodeAt(i+1)<<16 |
		msg.charCodeAt(i+2)<<8 | msg.charCodeAt(i+3);
		word_array.push( j );
	}

	switch( msg_len % 4 ) {
		case 0:
			i = 0x080000000;
		break;
		case 1:
			i = msg.charCodeAt(msg_len-1)<<24 | 0x0800000;
		break;

		case 2:
			i = msg.charCodeAt(msg_len-2)<<24 | msg.charCodeAt(msg_len-1)<<16 | 0x08000;
		break;

		case 3:
			i = msg.charCodeAt(msg_len-3)<<24 | msg.charCodeAt(msg_len-2)<<16 | msg.charCodeAt(msg_len-1)<<8	| 0x80;
		break;
	}

	word_array.push( i );

	while( (word_array.length % 16) != 14 ) word_array.push( 0 );

	word_array.push( msg_len>>>29 );
	word_array.push( (msg_len<<3)&0x0ffffffff );


	for ( blockstart=0; blockstart<word_array.length; blockstart+=16 ) {

		for( i=0; i<16; i++ ) W[i] = word_array[blockstart+i];
		for( i=16; i<=79; i++ ) W[i] = rotate_left(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);

		A = H0;
		B = H1;
		C = H2;
		D = H3;
		E = H4;

		for( i= 0; i<=19; i++ ) {
			temp = (rotate_left(A,5) + ((B&C) | (~B&D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
			E = D;
			D = C;
			C = rotate_left(B,30);
			B = A;
			A = temp;
		}

		for( i=20; i<=39; i++ ) {
			temp = (rotate_left(A,5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
			E = D;
			D = C;
			C = rotate_left(B,30);
			B = A;
			A = temp;
		}

		for( i=40; i<=59; i++ ) {
			temp = (rotate_left(A,5) + ((B&C) | (B&D) | (C&D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
			E = D;
			D = C;
			C = rotate_left(B,30);
			B = A;
			A = temp;
		}

		for( i=60; i<=79; i++ ) {
			temp = (rotate_left(A,5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
			E = D;
			D = C;
			C = rotate_left(B,30);
			B = A;
			A = temp;
		}

		H0 = (H0 + A) & 0x0ffffffff;
		H1 = (H1 + B) & 0x0ffffffff;
		H2 = (H2 + C) & 0x0ffffffff;
		H3 = (H3 + D) & 0x0ffffffff;
		H4 = (H4 + E) & 0x0ffffffff;

	}
	var temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);
	return temp.toLowerCase();
}

function strUpTo (s, find){
	var i = s.indexOf(find);
	if (i > 0){
		return s.substr(0, i);
	}
	return s;
}


/**********************
part       full
Xd Xh Xm   Xd Xh Xm Xs
Xh Xm      Xh Xm Xs
Xm Xs      Xm Xs
Xs         Xs
**********************/
function timestr(time, full) {
	time = parseInt (time);
	var m = [];
	var t = time;
	
	if (t < 61){
		return  t + 's';
	}
	
	if (t > 86400){
		m.push (parseInt(t/86400)); 
		m.push ('d ');
		t %= 86400;
	}  
	if (t>3600 || time>3600){
		m.push (parseInt(t/3600)); 
		m.push ('h ');
		t %= 3600;
	}  
	m.push (parseInt(t/60)); 
	m.push ('m');
	if (full || time<=3600 ){
		m.push (' ');
		m.push (t%60);
		m.push ('s');  
	}
	var str = m.join('');
	
	if (str[str.length-1] == ' '){
		str = str.substring(0, str.length-1);
	}
	
	return str;
}

/********
Xd Xh
Xh Xm
Xm Xs
Xs
********/
function timestrShort(time) {
	time = parseInt (time);
	if (time > 86400){
		var m = [];
		time /= 3600;
		m.push (parseInt(time/24)); 
		m.push ('d ');
		m.push (parseInt(time%24)); 
		m.push ('h');
		return m.join ('');    
	} 
	else {
		return timestr (time);
	}
}




// ========================================================================
//  XML.ObjTree -- XML source code from/to JavaScript object like E4X
// ========================================================================
// http://www.kawa.net/works/js/xml/objtree-e.html
//

if ( typeof(XML) == 'undefined' ) XML = function() {};

//  constructor

XML.ObjTree = function () {
    return this;
};

//  class variables

XML.ObjTree.VERSION = "0.24";

//  object prototype

XML.ObjTree.prototype.xmlDecl = '<?xml version="1.0" encoding="UTF-8" ?>\n';
XML.ObjTree.prototype.attr_prefix = '-';
XML.ObjTree.prototype.overrideMimeType = 'text/xml';

//  method: parseXML( xmlsource )

XML.ObjTree.prototype.parseXML = function ( xml ) {
    var root;
    if ( window.DOMParser ) {
        var xmldom = new DOMParser();
//      xmldom.async = false;           // DOMParser is always sync-mode
        var dom = xmldom.parseFromString( xml, "application/xml" );
        if ( ! dom ) return;
        root = dom.documentElement;
    } else if ( window.ActiveXObject ) {
        xmldom = new ActiveXObject('Microsoft.XMLDOM');
        xmldom.async = false;
        xmldom.loadXML( xml );
        root = xmldom.documentElement;
    }
    if ( ! root ) return;
    return this.parseDOM( root );
};

//  method: parseHTTP( url, options, callback )

XML.ObjTree.prototype.parseHTTP = function ( url, options, callback ) {
    var myopt = {};
    for( var key in options ) {
        myopt[key] = options[key];                  // copy object
    }
    if ( ! myopt.method ) {
        if ( typeof(myopt.postBody) == "undefined" &&
             typeof(myopt.postbody) == "undefined" &&
             typeof(myopt.parameters) == "undefined" ) {
            myopt.method = "get";
        } else {
            myopt.method = "post";
        }
    }
    if ( callback ) {
        myopt.asynchronous = true;                  // async-mode
        var __this = this;
        var __func = callback;
        var __save = myopt.onComplete;
        myopt.onComplete = function ( trans ) {
            var tree;
            if ( trans && trans.responseXML && trans.responseXML.documentElement ) {
                tree = __this.parseDOM( trans.responseXML.documentElement );
            } else if ( trans && trans.responseText ) {
                tree = __this.parseXML( trans.responseText );
            }
            __func( tree, trans );
            if ( __save ) __save( trans );
        };
    } else {
        myopt.asynchronous = false;                 // sync-mode
    }
    var trans;
    if ( typeof(HTTP) != "undefined" && HTTP.Request ) {
        myopt.uri = url;
        var req = new HTTP.Request( myopt );        // JSAN
        if ( req ) trans = req.transport;
    } else if ( typeof(Ajax) != "undefined" && Ajax.Request ) {
        var req = new Ajax.Request( url, myopt );   // ptorotype.js
        if ( req ) trans = req.transport;
    }
//  if ( trans && typeof(trans.overrideMimeType) != "undefined" ) {
//      trans.overrideMimeType( this.overrideMimeType );
//  }
    if ( callback ) return trans;
    if ( trans && trans.responseXML && trans.responseXML.documentElement ) {
        return this.parseDOM( trans.responseXML.documentElement );
    } else if ( trans && trans.responseText ) {
        return this.parseXML( trans.responseText );
    }
}

//  method: parseDOM( documentroot )

XML.ObjTree.prototype.parseDOM = function ( root ) {
    if ( ! root ) return;

    this.__force_array = {};
    if ( this.force_array ) {
        for( var i=0; i<this.force_array.length; i++ ) {
            this.__force_array[this.force_array[i]] = 1;
        }
    }

    var json = this.parseElement( root );   // parse root node
    if ( this.__force_array[root.nodeName] ) {
        json = [ json ];
    }
    if ( root.nodeType != 11 ) {            // DOCUMENT_FRAGMENT_NODE
        var tmp = {};
        tmp[root.nodeName] = json;          // root nodeName
        json = tmp;
    }
    return json;
};

//  method: parseElement( element )

XML.ObjTree.prototype.parseElement = function ( elem ) {
    //  COMMENT_NODE
    if ( elem.nodeType == 7 ) {
        return;
    }

    //  TEXT_NODE CDATA_SECTION_NODE
    if ( elem.nodeType == 3 || elem.nodeType == 4 ) {
        var bool = elem.nodeValue.match( /[^\x00-\x20]/ );
        if ( bool == null ) return;     // ignore white spaces
        return elem.nodeValue;
    }

    var retval;
    var cnt = {};

    //  parse attributes
    if ( elem.attributes && elem.attributes.length ) {
        retval = {};
        for ( var i=0; i<elem.attributes.length; i++ ) {
            var key = elem.attributes[i].nodeName;
            if ( typeof(key) != "string" ) continue;
            var val = elem.attributes[i].nodeValue;
            if ( ! val ) continue;
            key = this.attr_prefix + key;
            if ( typeof(cnt[key]) == "undefined" ) cnt[key] = 0;
            cnt[key] ++;
            this.addNode( retval, key, cnt[key], val );
        }
    }

    //  parse child nodes (recursive)
    if ( elem.childNodes && elem.childNodes.length ) {
        var textonly = true;
        if ( retval ) textonly = false;        // some attributes exists
        for ( var i=0; i<elem.childNodes.length && textonly; i++ ) {
            var ntype = elem.childNodes[i].nodeType;
            if ( ntype == 3 || ntype == 4 ) continue;
            textonly = false;
        }
        if ( textonly ) {
            if ( ! retval ) retval = "";
            for ( var i=0; i<elem.childNodes.length; i++ ) {
                retval += elem.childNodes[i].nodeValue;
            }
        } else {
            if ( ! retval ) retval = {};
            for ( var i=0; i<elem.childNodes.length; i++ ) {
                var key = elem.childNodes[i].nodeName;
                if ( typeof(key) != "string" ) continue;
                var val = this.parseElement( elem.childNodes[i] );
                if ( ! val ) continue;
                if ( typeof(cnt[key]) == "undefined" ) cnt[key] = 0;
                cnt[key] ++;
                this.addNode( retval, key, cnt[key], val );
            }
        }
    }
    return retval;
};

//  method: addNode( hash, key, count, value )

XML.ObjTree.prototype.addNode = function ( hash, key, cnts, val ) {
    if ( this.__force_array[key] ) {
        if ( cnts == 1 ) hash[key] = [];
        hash[key][hash[key].length] = val;      // push
    } else if ( cnts == 1 ) {                   // 1st sibling
        hash[key] = val;
    } else if ( cnts == 2 ) {                   // 2nd sibling
        hash[key] = [ hash[key], val ];
    } else {                                    // 3rd sibling and more
        hash[key][hash[key].length] = val;
    }
};

//  method: writeXML( tree )

XML.ObjTree.prototype.writeXML = function ( tree ) {
    var xml = this.hash_to_xml( null, tree );
    return this.xmlDecl + xml;
};

//  method: hash_to_xml( tagName, tree )

XML.ObjTree.prototype.hash_to_xml = function ( name, tree ) {
    var elem = [];
    var attr = [];
    for( var key in tree ) {
        if ( ! tree.hasOwnProperty(key) ) continue;
        var val = tree[key];
        if ( key.charAt(0) != this.attr_prefix ) {
            if ( typeof(val) == "undefined" || val == null ) {
                elem[elem.length] = "<"+key+" />";
            } else if ( typeof(val) == "object" && val.constructor == Array ) {
                elem[elem.length] = this.array_to_xml( key, val );
            } else if ( typeof(val) == "object" ) {
                elem[elem.length] = this.hash_to_xml( key, val );
            } else {
                elem[elem.length] = this.scalar_to_xml( key, val );
            }
        } else {
            attr[attr.length] = " "+(key.substring(1))+'="'+(this.xml_escape( val ))+'"';
        }
    }
    var jattr = attr.join("");
    var jelem = elem.join("");
    if ( typeof(name) == "undefined" || name == null ) {
        // no tag
    } else if ( elem.length > 0 ) {
        if ( jelem.match( /\n/ )) {
            jelem = "<"+name+jattr+">\n"+jelem+"</"+name+">\n";
        } else {
            jelem = "<"+name+jattr+">"  +jelem+"</"+name+">\n";
        }
    } else {
        jelem = "<"+name+jattr+" />\n";
    }
    return jelem;
};

//  method: array_to_xml( tagName, array )

XML.ObjTree.prototype.array_to_xml = function ( name, array ) {
    var out = [];
    for( var i=0; i<array.length; i++ ) {
        var val = array[i];
        if ( typeof(val) == "undefined" || val == null ) {
            out[out.length] = "<"+name+" />";
        } else if ( typeof(val) == "object" && val.constructor == Array ) {
            out[out.length] = this.array_to_xml( name, val );
        } else if ( typeof(val) == "object" ) {
            out[out.length] = this.hash_to_xml( name, val );
        } else {
            out[out.length] = this.scalar_to_xml( name, val );
        }
    }
    return out.join("");
};

//  method: scalar_to_xml( tagName, text )

XML.ObjTree.prototype.scalar_to_xml = function ( name, text ) {
    if ( name == "#text" ) {
        return this.xml_escape(text);
    } else {
        return "<"+name+">"+this.xml_escape(text)+"</"+name+">\n";
    }
};

//  method: xml_escape( text )

XML.ObjTree.prototype.xml_escape = function ( text ) {
    return String(text).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
};

// ********************************** END XML.ObjTree *****************************************



// ========================================================================
//  JSZip - A Javascript class for generating Zip files
// ========================================================================
// http://jszip.stuartk.co.uk
//
// (c) 2009 Stuart Knightley <stuart [at] stuartk.co.uk>
// Licenced under the GPLv3 and the MIT licences
//
// Usage:
//    zip = new JSZip();
//    zip.add("hello.txt", "Hello, World!").add("tempfile", "nothing");
//    zip.folder("images").add("smile.gif", base64Data, {base64: true});
//    zip.add("Xmas.txt", "Ho ho ho !", {date : new Date("December 25, 2007 00:00:01")});
//    zip.remove("tempfile");
// 
//    base64zip = zip.generate();
// 
function JSZip(compression) {
   // default : no compression
   this.compression = (compression || "STORE").toUpperCase();
   this.files = [];
   // Where we are in the hierarchy
   this.root = "";
   // Default properties for a new file
   this.d = {
      base64: false,
      binary: false,
      dir: false,
      date: null
   };
   if (!JSZip.compressions[this.compression]) {
      throw compression + " is not a valid compression method !";
   }
}
// Add a file to the zip file
// @param   name  The name of the file
// @param   data  The file data, either raw or base64 encoded
// @param   o     File options
// @return  this JSZip object
JSZip.prototype.add = function(name, data, o) {
   o = o || {};
   name = this.root+name;
   if (o.base64 === true && o.binary == null) o.binary = true;
   for (var opt in this.d) {
      o[opt] = o[opt] || this.d[opt];
   }
   // date
   // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
   // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
   // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html
   o.date = o.date || new Date();
   var dosTime, dosDate;
   dosTime = o.date.getHours();
   dosTime = dosTime << 6;
   dosTime = dosTime | o.date.getMinutes();
   dosTime = dosTime << 5;
   dosTime = dosTime | o.date.getSeconds() / 2;
   dosDate = o.date.getFullYear() - 1980;
   dosDate = dosDate << 4;
   dosDate = dosDate | (o.date.getMonth() + 1);
   dosDate = dosDate << 5;
   dosDate = dosDate | o.date.getDate();
   if (o.base64 === true) data = JSZipBase64.decode(data);
   // decode UTF-8 strings if we are dealing with text data
   if(o.binary === false) data = this.utf8encode(data);
   var compression    = JSZip.compressions[this.compression];
   var compressedData = compression.compress(data);
   var header = "";
   // version needed to extract
   header += "\x0A\x00";
   // general purpose bit flag
   header += "\x00\x00";
   // compression method
   header += compression.magic;
   // last mod file time
   header += this.decToHex(dosTime, 2);
   // last mod file date
   header += this.decToHex(dosDate, 2);
   // crc-32
   header += this.decToHex(this.crc32(data), 4);
   // compressed size
   header += this.decToHex(compressedData.length, 4);
   // uncompressed size
   header += this.decToHex(data.length, 4);
   // file name length
   header += this.decToHex(name.length, 2);
   // extra field length
   header += "\x00\x00";
   // file name

   this.files[name] = {header: header, data: compressedData, dir: o.dir};
   return this;
};
// Add a directory to the zip file
// @param   name  The name of the directory to add
// @return  JSZip object with the new directory as the root
JSZip.prototype.folder = function(name) {
   // Check the name ends with a /
   if (name.substr(-1) != "/") name += "/";
   // Does this folder already exist?
   if (typeof this.files[name] === "undefined") this.add(name, '', {dir:true});
   // Allow chaining by returning a new object with this folder as the root
   var ret = this.clone();
   ret.root = this.root+name;
   return ret;
};
// Compare a string or regular expression against all of the filenames and
// return an informational object for each that matches.
// @param   string/regex The regular expression to test against
// @return  An array of objects representing the matched files. In the form
//          {name: "filename", data: "file data", dir: true/false}
JSZip.prototype.find = function(needle) {
   var result = [], re;
   if (typeof needle === "string") {
      re = new RegExp("^"+needle+"$");
   } else {
      re = needle;
   }
   for (var filename in this.files) {
      if (re.test(filename)) {
         var file = this.files[filename];
         result.push({name: filename, data: file.data, dir: !!file.dir});
      }
   }
   return result;
};
// Delete a file, or a directory and all sub-files, from the zip
// @param   name  the name of the file to delete
// @return  this JSZip object
JSZip.prototype.remove = function(name) {
   var file = this.files[name];
   if (!file) {
      // Look for any folders
      if (name.substr(-1) != "/") name += "/";
      file = this.files[name];
   }
   if (file){
      if (name.match("/") === null) {
         // file
         delete this.files[name];
      } else {
         // folder
         var kids = this.find(new RegExp("^"+name));
         for (var i = 0; i < kids.length; i++) {
            if (kids[i].name == name) {
               // Delete this folder
               delete this.files[name];
            } else {
               // Remove a child of this folder
               this.remove(kids[i].name);
            }
         }
      }
   }
   return this;
};
// Generate the complete zip file
// @return  A base64 encoded string of the zip file
JSZip.prototype.generate = function(asBytes) {
   asBytes = asBytes || false;
   // The central directory, and files data
   var directory = [], files = [], fileOffset = 0;
   for (var name in this.files){
      if( !this.files.hasOwnProperty(name) ) { continue; }
      var fileRecord = "", dirRecord = "";
      fileRecord = "\x50\x4b\x03\x04" + this.files[name].header + name + this.files[name].data;
      dirRecord = "\x50\x4b\x01\x02" +
      // version made by (00: DOS)
      "\x14\x00" +
      // file header (common to file and central directory)
      this.files[name].header +
      // file comment length
      "\x00\x00" +
      // disk number start
      "\x00\x00" +
      // internal file attributes TODO
      "\x00\x00" +
      // external file attributes
      (this.files[name].dir===true?"\x10\x00\x00\x00":"\x00\x00\x00\x00")+
      // relative offset of local header
      this.decToHex(fileOffset, 4) +
      // file name
      name;
      fileOffset += fileRecord.length;
      files.push(fileRecord);
      directory.push(dirRecord);
   }
   var fileData = files.join("");
   var dirData = directory.join("");
   var dirEnd = "";
   // end of central dir signature
   dirEnd = "\x50\x4b\x05\x06" +
   // number of this disk
   "\x00\x00" +
   // number of the disk with the start of the central directory
   "\x00\x00" +
   // total number of entries in the central directory on this disk
   this.decToHex(files.length, 2) +
   // total number of entries in the central directory
   this.decToHex(files.length, 2) +
   // size of the central directory   4 bytes
   this.decToHex(dirData.length, 4) +
   // offset of start of central directory with respect to the starting disk number
   this.decToHex(fileData.length, 4) +
   // .ZIP file comment length
   "\x00\x00";
   var zip = fileData + dirData + dirEnd;
   return (asBytes) ? zip : JSZipBase64.encode(zip);
};
// Compression methods
// This object is filled in as follow :
// name :
//    magic // the 2 bytes indentifying the compression method
//    compress // function, take the uncompressed content and return it compressed.
//
// STORE is the default compression method, so it's included in this file.
// Other methods should go to separated files : the user wants modularity.
JSZip.compressions = {
   "STORE" : {
      magic : "\x00\x00",
      compress : function (content) {
         return content; // no compression
      }
   }
};

// Utility functions
JSZip.prototype.decToHex = function(dec, bytes) {
   var hex = "";
   for(var i=0;i<bytes;i++) {
      hex += String.fromCharCode(dec&0xff);
      dec=dec>>>8;
   }
   return hex;
};
// Javascript crc32
// http://www.webtoolkit.info/
JSZip.prototype.crc32 = function(str, crc) {
   if (str === "") return "\x00\x00\x00\x00";
   var table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";
   if (typeof(crc) == "undefined") { crc = 0; }
   var x = 0;
   var y = 0;
   crc = crc ^ (-1);
   for( var i = 0, iTop = str.length; i < iTop; i++ ) {
      y = ( crc ^ str.charCodeAt( i ) ) & 0xFF;
      x = "0x" + table.substr( y * 9, 8 );
      crc = ( crc >>> 8 ) ^ x;
   }
   return crc ^ (-1);
};
// Inspired by http://my.opera.com/GreyWyvern/blog/show.dml/1725165
JSZip.prototype.clone = function() {
   var newObj = new JSZip();
   for (var i in this){
      if (typeof this[i] !== "function") {
         newObj[i] = this[i];
      }
   }
   return newObj;
};
JSZip.prototype.utf8encode = function(input){
   input = encodeURIComponent(input);
   input = input.replace(/%.{2,2}/g, function(m) {
      var hex = m.substring(1);
      return String.fromCharCode(parseInt(hex,16));
   });
   return input;
};
//  Base64 encode / decode
//  http://www.webtoolkit.info/
//  Hacked so that it doesn't utf8 en/decode everything
var JSZipBase64 = function() {
   // private property
   var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
   return {
      // public method for encoding
      encode : function(input, utf8) {
         var output = "";
         var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
         var i = 0;
         while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
               enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
               enc4 = 64;
            }
            output = output +
            _keyStr.charAt(enc1) + _keyStr.charAt(enc2) +
            _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
         }
         return output;
      },
      // public method for decoding
      decode : function(input, utf8) {
         var output = "";
         var chr1, chr2, chr3;
         var enc1, enc2, enc3, enc4;
         var i = 0;
         input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
         while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
               output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
               output = output + String.fromCharCode(chr3);
            }
         }
         return output;
      }
   };
}();
// ********************************** END JZIP *****************************************







/*  Prototype JavaScript framework, version 1.7
 *  (c) 2005-2010 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 *
 *--------------------------------------------------------------------------*/
// Form.Methods & Ajax Class NOT INCLUDED
 
 
/*  Prototype JavaScript framework, version 1.7
 *  (c) 2005-2010 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 *
 *--------------------------------------------------------------------------*/
 
var Sizzle;
var sortOrder;
var Event;
var Prototype = {

  Version: '1.7',

  Browser: (function(){
    var ua = navigator.userAgent;
    var isOpera = Object.prototype.toString.call(window.opera) == '[object Opera]';
    return {
      IE:             !!window.attachEvent && !isOpera,
      Opera:          isOpera,
      WebKit:         ua.indexOf('AppleWebKit/') > -1,
      Gecko:          ua.indexOf('Gecko') > -1 && ua.indexOf('KHTML') === -1,
      MobileSafari:   /Apple.*Mobile/.test(ua)
    }
  })(),

  BrowserFeatures: {
    XPath: !!document.evaluate,

    SelectorsAPI: !!document.querySelector,

    ElementExtensions: (function() {
      var constructor = window.Element || window.HTMLElement;
      return !!(constructor && constructor.prototype);
    })(),
    SpecificElementExtensions: (function() {
      if (typeof window.HTMLDivElement !== 'undefined')
        return true;

      var div = document.createElement('div'),
          form = document.createElement('form'),
          isSupported = false;

      if (div['__proto__'] && (div['__proto__'] !== form['__proto__'])) {
        isSupported = true;
      }

      div = form = null;

      return isSupported;
    })()
  },

  ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script>',
  JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,

  emptyFunction: function() { },

  K: function(x) { return x }
};

if (Prototype.Browser.MobileSafari)
  Prototype.BrowserFeatures.SpecificElementExtensions = false;


var Abstract = { };


var Try = {
  these: function() {
    var returnValue;

    for (var i = 0, length = arguments.length; i < length; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (e) { }
    }

    return returnValue;
  }
};

/* Based on Alex Arnell's inheritance implementation. */

var Class = (function() {

  var IS_DONTENUM_BUGGY = (function(){
    for (var p in { toString: 1 }) {
      if (p === 'toString') return false;
    }
    return true;
  })();

  function subclass() {};
  function create() {
    var parent = null, properties = $A(arguments);
    if (Object.isFunction(properties[0]))
      parent = properties.shift();

    function klass() {
      this.initialize.apply(this, arguments);
    }

    Object.extend(klass, Class.Methods);
    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      subclass.prototype = parent.prototype;
      klass.prototype = new subclass;
      parent.subclasses.push(klass);
    }

    for (var i = 0, length = properties.length; i < length; i++)
      klass.addMethods(properties[i]);

    if (!klass.prototype.initialize)
      klass.prototype.initialize = Prototype.emptyFunction;

    klass.prototype.constructor = klass;
    return klass;
  }

  function addMethods(source) {
    var ancestor   = this.superclass && this.superclass.prototype,
        properties = Object.keys(source);

    if (IS_DONTENUM_BUGGY) {
      if (source.toString != Object.prototype.toString)
        properties.push("toString");
      if (source.valueOf != Object.prototype.valueOf)
        properties.push("valueOf");
    }

    for (var i = 0, length = properties.length; i < length; i++) {
      var property = properties[i], value = source[property];
      if (ancestor && Object.isFunction(value) &&
          value.argumentNames()[0] == "$super") {
        var method = value;
        value = (function(m) {
          return function() { return ancestor[m].apply(this, arguments); };
        })(property).wrap(method);

        value.valueOf = method.valueOf.bind(method);
        value.toString = method.toString.bind(method);
      }
      this.prototype[property] = value;
    }

    return this;
  }

  return {
    create: create,
    Methods: {
      addMethods: addMethods
    }
  };
})();
(function() {

  var _toString = Object.prototype.toString,
      NULL_TYPE = 'Null',
      UNDEFINED_TYPE = 'Undefined',
      BOOLEAN_TYPE = 'Boolean',
      NUMBER_TYPE = 'Number',
      STRING_TYPE = 'String',
      OBJECT_TYPE = 'Object',
      FUNCTION_CLASS = '[object Function]',
      BOOLEAN_CLASS = '[object Boolean]',
      NUMBER_CLASS = '[object Number]',
      STRING_CLASS = '[object String]',
      ARRAY_CLASS = '[object Array]',
      DATE_CLASS = '[object Date]',
      NATIVE_JSON_STRINGIFY_SUPPORT = window.JSON &&
        typeof JSON.stringify === 'function' &&
        JSON.stringify(0) === '0' &&
        typeof JSON.stringify(Prototype.K) === 'undefined';

  function Type(o) {
    switch(o) {
      case null: return NULL_TYPE;
      case (void 0): return UNDEFINED_TYPE;
    }
    var type = typeof o;
    switch(type) {
      case 'boolean': return BOOLEAN_TYPE;
      case 'number':  return NUMBER_TYPE;
      case 'string':  return STRING_TYPE;
    }
    return OBJECT_TYPE;
  }

  function extend(destination, source) {
    for (var property in source)
      destination[property] = source[property];
    return destination;
  }

  function inspect(object) {
    try {
      if (isUndefined(object)) return 'undefined';
      if (object === null) return 'null';
      return object.inspect ? object.inspect() : String(object);
    } catch (e) {
      if (e instanceof RangeError) return '...';
      throw e;
    }
  }

  function toJSON(value) {
    return Str('', { '': value }, []);
  }

  function Str(key, holder, stack) {
    var value = holder[key],
        type = typeof value;

    if (Type(value) === OBJECT_TYPE && typeof value.toJSON === 'function') {
      value = value.toJSON(key);
    }

    var _class = _toString.call(value);

    switch (_class) {
      case NUMBER_CLASS:
      case BOOLEAN_CLASS:
      case STRING_CLASS:
        value = value.valueOf();
    }

    switch (value) {
      case null: return 'null';
      case true: return 'true';
      case false: return 'false';
    }

    type = typeof value;
    switch (type) {
      case 'string':
        return value.inspect(true);
      case 'number':
        return isFinite(value) ? String(value) : 'null';
      case 'object':

        for (var i = 0, length = stack.length; i < length; i++) {
          if (stack[i] === value) { throw new TypeError(); }
        }
        stack.push(value);

        var partial = [];
        if (_class === ARRAY_CLASS) {
          for (var i = 0, length = value.length; i < length; i++) {
            var str = Str(i, value, stack);
            partial.push(typeof str === 'undefined' ? 'null' : str);
          }
          partial = '[' + partial.join(',') + ']';
        } else {
          var keys = Object.keys(value);
          for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i], str = Str(key, value, stack);
            if (typeof str !== "undefined") {
               partial.push(key.inspect(true)+ ':' + str);
             }
          }
          partial = '{' + partial.join(',') + '}';
        }
        stack.pop();
        return partial;
    }
  }

  function stringify(object) {
    return JSON.stringify(object);
  }

  function toQueryString(object) {
    return $H(object).toQueryString();
  }

  function toHTML(object) {
    return object && object.toHTML ? object.toHTML() : String.interpret(object);
  }

  function keys(object) {
    if (Type(object) !== OBJECT_TYPE) { throw new TypeError(); }
    var results = [];
    for (var property in object) {
      if (object.hasOwnProperty(property)) {
        results.push(property);
      }
    }
    return results;
  }

  function values(object) {
    var results = [];
    for (var property in object)
      results.push(object[property]);
    return results;
  }

  function clone(object) {
    return extend({ }, object);
  }

  function isElement(object) {
    return !!(object && object.nodeType == 1);
  }

  function isArray(object) {
    return _toString.call(object) === ARRAY_CLASS;
  }

  var hasNativeIsArray = (typeof Array.isArray == 'function')
    && Array.isArray([]) && !Array.isArray({});

  if (hasNativeIsArray) {
    isArray = Array.isArray;
  }

  function isHash(object) {
    return object instanceof Hash;
  }

  function isFunction(object) {
    return _toString.call(object) === FUNCTION_CLASS;
  }

  function isString(object) {
    return _toString.call(object) === STRING_CLASS;
  }

  function isNumber(object) {
    return _toString.call(object) === NUMBER_CLASS;
  }

  function isDate(object) {
    return _toString.call(object) === DATE_CLASS;
  }

  function isUndefined(object) {
    return typeof object === "undefined";
  }

  extend(Object, {
    extend:        extend,
    inspect:       inspect,
    toJSON:        NATIVE_JSON_STRINGIFY_SUPPORT ? stringify : toJSON,
    toQueryString: toQueryString,
    toHTML:        toHTML,
    keys:          Object.keys || keys,
    values:        values,
    clone:         clone,
    isElement:     isElement,
    isArray:       isArray,
    isHash:        isHash,
    isFunction:    isFunction,
    isString:      isString,
    isNumber:      isNumber,
    isDate:        isDate,
    isUndefined:   isUndefined
  });
})();
Object.extend(Function.prototype, (function() {
  var slice = Array.prototype.slice;

  function update(array, args) {
    var arrayLength = array.length, length = args.length;
    while (length--) array[arrayLength + length] = args[length];
    return array;
  }

  function merge(array, args) {
    array = slice.call(array, 0);
    return update(array, args);
  }

  function argumentNames() {
    var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
      .replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
      .replace(/\s+/g, '').split(',');
    return names.length == 1 && !names[0] ? [] : names;
  }

  function bind(context) {
    if (arguments.length < 2 && Object.isUndefined(arguments[0])) return this;
    var __method = this, args = slice.call(arguments, 1);
    return function() {
      var a = merge(args, arguments);
      return __method.apply(context, a);
    }
  }

  function bindAsEventListener(context) {
    var __method = this, args = slice.call(arguments, 1);
    return function(event) {
      var a = update([event || window.event], args);
      return __method.apply(context, a);
    }
  }

  function curry() {
    if (!arguments.length) return this;
    var __method = this, args = slice.call(arguments, 0);
    return function() {
      var a = merge(args, arguments);
      return __method.apply(this, a);
    }
  }

  function delay(timeout) {
    var __method = this, args = slice.call(arguments, 1);
    timeout = timeout * 1000;
    return window.setTimeout(function() {
      return __method.apply(__method, args);
    }, timeout);
  }

  function defer() {
    var args = update([0.01], arguments);
    return this.delay.apply(this, args);
  }

  function wrap(wrapper) {
    var __method = this;
    return function() {
      var a = update([__method.bind(this)], arguments);
      return wrapper.apply(this, a);
    }
  }

  function methodize() {
    if (this._methodized) return this._methodized;
    var __method = this;
    return this._methodized = function() {
      var a = update([this], arguments);
      return __method.apply(null, a);
    };
  }

  return {
    argumentNames:       argumentNames,
    bind:                bind,
    bindAsEventListener: bindAsEventListener,
    curry:               curry,
    delay:               delay,
    defer:               defer,
    wrap:                wrap,
    methodize:           methodize
  }
})());



(function(proto) {


  function toISOString() {
    return this.getUTCFullYear() + '-' +
      (this.getUTCMonth() + 1).toPaddedString(2) + '-' +
      this.getUTCDate().toPaddedString(2) + 'T' +
      this.getUTCHours().toPaddedString(2) + ':' +
      this.getUTCMinutes().toPaddedString(2) + ':' +
      this.getUTCSeconds().toPaddedString(2) + 'Z';
  }


  function toJSON() {
    return this.toISOString();
  }

  if (!proto.toISOString) proto.toISOString = toISOString;
  if (!proto.toJSON) proto.toJSON = toJSON;

})(Date.prototype);


RegExp.prototype.match = RegExp.prototype.test;

RegExp.escape = function(str) {
  return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
};
var PeriodicalExecuter = Class.create({
  initialize: function(callback, frequency) {
    this.callback = callback;
    this.frequency = frequency;
    this.currentlyExecuting = false;

    this.registerCallback();
  },

  registerCallback: function() {
    this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
  },

  execute: function() {
    this.callback(this);
  },

  stop: function() {
    if (!this.timer) return;
    clearInterval(this.timer);
    this.timer = null;
  },

  onTimerEvent: function() {
    if (!this.currentlyExecuting) {
      try {
        this.currentlyExecuting = true;
        this.execute();
        this.currentlyExecuting = false;
      } catch(e) {
        this.currentlyExecuting = false;
        throw e;
      }
    }
  }
});
Object.extend(String, {
  interpret: function(value) {
    return value == null ? '' : String(value);
  },
  specialChar: {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '\\': '\\\\'
  }
});

Object.extend(String.prototype, (function() {
  var NATIVE_JSON_PARSE_SUPPORT = window.JSON &&
    typeof JSON.parse === 'function' &&
    JSON.parse('{"test": true}').test;

  function prepareReplacement(replacement) {
    if (Object.isFunction(replacement)) return replacement;
    var template = new Template(replacement);
    return function(match) { return template.evaluate(match) };
  }

  function gsub(pattern, replacement) {
    var result = '', source = this, match;
    replacement = prepareReplacement(replacement);

    if (Object.isString(pattern))
      pattern = RegExp.escape(pattern);

    if (!(pattern.length || pattern.source)) {
      replacement = replacement('');
      return replacement + source.split('').join(replacement) + replacement;
    }

    while (source.length > 0) {
      if (match = source.match(pattern)) {
        result += source.slice(0, match.index);
        result += String.interpret(replacement(match));
        source  = source.slice(match.index + match[0].length);
      } else {
        result += source, source = '';
      }
    }
    return result;
  }

  function sub(pattern, replacement, count) {
    replacement = prepareReplacement(replacement);
    count = Object.isUndefined(count) ? 1 : count;

    return this.gsub(pattern, function(match) {
      if (--count < 0) return match[0];
      return replacement(match);
    });
  }

  function scan(pattern, iterator) {
    this.gsub(pattern, iterator);
    return String(this);
  }

  function truncate(length, truncation) {
    length = length || 30;
    truncation = Object.isUndefined(truncation) ? '...' : truncation;
    return this.length > length ?
      this.slice(0, length - truncation.length) + truncation : String(this);
  }

  function strip() {
    return this.replace(/^\s+/, '').replace(/\s+$/, '');
  }

  function stripTags() {
    return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, '');
  }

  function stripScripts() {
    return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), '');
  }

  function extractScripts() {
    var matchAll = new RegExp(Prototype.ScriptFragment, 'img'),
        matchOne = new RegExp(Prototype.ScriptFragment, 'im');
    return (this.match(matchAll) || []).map(function(scriptTag) {
      return (scriptTag.match(matchOne) || ['', ''])[1];
    });
  }

  function evalScripts() {
    return this.extractScripts().map(function(script) { return eval(script) });
  }

  function escapeHTML() {
    return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  function unescapeHTML() {
    return this.stripTags().replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&');
  }


  function toQueryParams(separator) {
    var match = this.strip().match(/([^?#]*)(#.*)?$/);
    if (!match) return { };

    return match[1].split(separator || '&').inject({ }, function(hash, pair) {
      if ((pair = pair.split('='))[0]) {
        var key = decodeURIComponent(pair.shift()),
            value = pair.length > 1 ? pair.join('=') : pair[0];

        if (value != undefined) value = decodeURIComponent(value);

        if (key in hash) {
          if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
          hash[key].push(value);
        }
        else hash[key] = value;
      }
      return hash;
    });
  }

  function toArray() {
    return this.split('');
  }

  function succ() {
    return this.slice(0, this.length - 1) +
      String.fromCharCode(this.charCodeAt(this.length - 1) + 1);
  }

  function times(count) {
    return count < 1 ? '' : new Array(count + 1).join(this);
  }

  function camelize() {
    return this.replace(/-+(.)?/g, function(match, chr) {
      return chr ? chr.toUpperCase() : '';
    });
  }

  function capitalize() {
    return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
  }

  function underscore() {
    return this.replace(/::/g, '/')
               .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
               .replace(/([a-z\d])([A-Z])/g, '$1_$2')
               .replace(/-/g, '_')
               .toLowerCase();
  }

  function dasherize() {
    return this.replace(/_/g, '-');
  }

  function inspect(useDoubleQuotes) {
    var escapedString = this.replace(/[\x00-\x1f\\]/g, function(character) {
      if (character in String.specialChar) {
        return String.specialChar[character];
      }
      return '\\u00' + character.charCodeAt().toPaddedString(2, 16);
    });
    if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
    return "'" + escapedString.replace(/'/g, '\\\'') + "'";
  }

  function unfilterJSON(filter) {
    return this.replace(filter || Prototype.JSONFilter, '$1');
  }

  function isJSON() {
    var str = this;
    if (str.blank()) return false;
    str = str.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@');
    str = str.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
    str = str.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
    return (/^[\],:{}\s]*$/).test(str);
  }

  function evalJSON(sanitize) {
    var json = this.unfilterJSON(),
        cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    if (cx.test(json)) {
      json = json.replace(cx, function (a) {
        return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
      });
    }
    try {
      if (!sanitize || json.isJSON()) return eval('(' + json + ')');
    } catch (e) { }
    throw new SyntaxError('Badly formed JSON string: ' + this.inspect());
  }

  function parseJSON() {
    var json = this.unfilterJSON();
    return JSON.parse(json);
  }

  function include(pattern) {
    return this.indexOf(pattern) > -1;
  }

  function startsWith(pattern) {
    return this.lastIndexOf(pattern, 0) === 0;
  }

  function endsWith(pattern) {
    var d = this.length - pattern.length;
    return d >= 0 && this.indexOf(pattern, d) === d;
  }

  function empty() {
    return this == '';
  }

  function blank() {
    return /^\s*$/.test(this);
  }

  function interpolate(object, pattern) {
    return new Template(this, pattern).evaluate(object);
  }

  return {
    gsub:           gsub,
    sub:            sub,
    scan:           scan,
    truncate:       truncate,
    strip:          String.prototype.trim || strip,
    stripTags:      stripTags,
    stripScripts:   stripScripts,
    extractScripts: extractScripts,
    evalScripts:    evalScripts,
    escapeHTML:     escapeHTML,
    unescapeHTML:   unescapeHTML,
    toQueryParams:  toQueryParams,
    parseQuery:     toQueryParams,
    toArray:        toArray,
    succ:           succ,
    times:          times,
    camelize:       camelize,
    capitalize:     capitalize,
    underscore:     underscore,
    dasherize:      dasherize,
    inspect:        inspect,
    unfilterJSON:   unfilterJSON,
    isJSON:         isJSON,
    evalJSON:       NATIVE_JSON_PARSE_SUPPORT ? parseJSON : evalJSON,
    include:        include,
    startsWith:     startsWith,
    endsWith:       endsWith,
    empty:          empty,
    blank:          blank,
    interpolate:    interpolate
  };
})());

var Template = Class.create({
  initialize: function(template, pattern) {
    this.template = template.toString();
    this.pattern = pattern || Template.Pattern;
  },

  evaluate: function(object) {
    if (object && Object.isFunction(object.toTemplateReplacements))
      object = object.toTemplateReplacements();

    return this.template.gsub(this.pattern, function(match) {
      if (object == null) return (match[1] + '');

      var before = match[1] || '';
      if (before == '\\') return match[2];

      var ctx = object, expr = match[3],
          pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;

      match = pattern.exec(expr);
      if (match == null) return before;

      while (match != null) {
        var comp = match[1].startsWith('[') ? match[2].replace(/\\\\]/g, ']') : match[1];
        ctx = ctx[comp];
        if (null == ctx || '' == match[3]) break;
        expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
        match = pattern.exec(expr);
      }

      return before + String.interpret(ctx);
    });
  }
});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;

var $break = { };

var Enumerable = (function() {
  function each(iterator, context) {
    var index = 0;
    try {
      this._each(function(value) {
        iterator.call(context, value, index++);
      });
    } catch (e) {
      if (e != $break) throw e;
    }
    return this;
  }

  function eachSlice(number, iterator, context) {
    var index = -number, slices = [], array = this.toArray();
    if (number < 1) return array;
    while ((index += number) < array.length)
      slices.push(array.slice(index, index+number));
    return slices.collect(iterator, context);
  }

  function all(iterator, context) {
    iterator = iterator || Prototype.K;
    var result = true;
    this.each(function(value, index) {
      result = result && !!iterator.call(context, value, index);
      if (!result) throw $break;
    });
    return result;
  }

  function any(iterator, context) {
    iterator = iterator || Prototype.K;
    var result = false;
    this.each(function(value, index) {
      if (result = !!iterator.call(context, value, index))
        throw $break;
    });
    return result;
  }

  function collect(iterator, context) {
    iterator = iterator || Prototype.K;
    var results = [];
    this.each(function(value, index) {
      results.push(iterator.call(context, value, index));
    });
    return results;
  }

  function detect(iterator, context) {
    var result;
    this.each(function(value, index) {
      if (iterator.call(context, value, index)) {
        result = value;
        throw $break;
      }
    });
    return result;
  }

  function findAll(iterator, context) {
    var results = [];
    this.each(function(value, index) {
      if (iterator.call(context, value, index))
        results.push(value);
    });
    return results;
  }

  function grep(filter, iterator, context) {
    iterator = iterator || Prototype.K;
    var results = [];

    if (Object.isString(filter))
      filter = new RegExp(RegExp.escape(filter));

    this.each(function(value, index) {
      if (filter.match(value))
        results.push(iterator.call(context, value, index));
    });
    return results;
  }

  function include(object) {
    if (Object.isFunction(this.indexOf))
      if (this.indexOf(object) != -1) return true;

    var found = false;
    this.each(function(value) {
      if (value == object) {
        found = true;
        throw $break;
      }
    });
    return found;
  }

  function inGroupsOf(number, fillWith) {
    fillWith = Object.isUndefined(fillWith) ? null : fillWith;
    return this.eachSlice(number, function(slice) {
      while(slice.length < number) slice.push(fillWith);
      return slice;
    });
  }

  function inject(memo, iterator, context) {
    this.each(function(value, index) {
      memo = iterator.call(context, memo, value, index);
    });
    return memo;
  }

  function invoke(method) {
    var args = $A(arguments).slice(1);
    return this.map(function(value) {
      return value[method].apply(value, args);
    });
  }

  function max(iterator, context) {
    iterator = iterator || Prototype.K;
    var result;
    this.each(function(value, index) {
      value = iterator.call(context, value, index);
      if (result == null || value >= result)
        result = value;
    });
    return result;
  }

  function min(iterator, context) {
    iterator = iterator || Prototype.K;
    var result;
    this.each(function(value, index) {
      value = iterator.call(context, value, index);
      if (result == null || value < result)
        result = value;
    });
    return result;
  }

  function partition(iterator, context) {
    iterator = iterator || Prototype.K;
    var trues = [], falses = [];
    this.each(function(value, index) {
      (iterator.call(context, value, index) ?
        trues : falses).push(value);
    });
    return [trues, falses];
  }

  function pluck(property) {
    var results = [];
    this.each(function(value) {
      results.push(value[property]);
    });
    return results;
  }

  function reject(iterator, context) {
    var results = [];
    this.each(function(value, index) {
      if (!iterator.call(context, value, index))
        results.push(value);
    });
    return results;
  }

  function sortBy(iterator, context) {
    return this.map(function(value, index) {
      return {
        value: value,
        criteria: iterator.call(context, value, index)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      return a < b ? -1 : a > b ? 1 : 0;
    }).pluck('value');
  }

  function toArray() {
    return this.map();
  }

  function zip() {
    var iterator = Prototype.K, args = $A(arguments);
    if (Object.isFunction(args.last()))
      iterator = args.pop();

    var collections = [this].concat(args).map($A);
    return this.map(function(value, index) {
      return iterator(collections.pluck(index));
    });
  }

  function size() {
    return this.toArray().length;
  }

  function inspect() {
    return '#<Enumerable:' + this.toArray().inspect() + '>';
  }

  return {
    each:       each,
    eachSlice:  eachSlice,
    all:        all,
    every:      all,
    any:        any,
    some:       any,
    collect:    collect,
    map:        collect,
    detect:     detect,
    findAll:    findAll,
    select:     findAll,
    filter:     findAll,
    grep:       grep,
    include:    include,
    member:     include,
    inGroupsOf: inGroupsOf,
    inject:     inject,
    invoke:     invoke,
    max:        max,
    min:        min,
    partition:  partition,
    pluck:      pluck,
    reject:     reject,
    sortBy:     sortBy,
    toArray:    toArray,
    entries:    toArray,
    zip:        zip,
    size:       size,
    inspect:    inspect,
    find:       detect
  };
})();

function $A(iterable) {
  if (!iterable) return [];
  if ('toArray' in Object(iterable)) return iterable.toArray();
  var length = iterable.length || 0, results = new Array(length);
  while (length--) results[length] = iterable[length];
  return results;
}


function $w(string) {
  if (!Object.isString(string)) return [];
  string = string.strip();
  return string ? string.split(/\s+/) : [];
}

Array.from = $A;


(function() {
  var arrayProto = Array.prototype,
      slice = arrayProto.slice,
      _each = arrayProto.forEach; // use native browser JS 1.6 implementation if available

  function each(iterator, context) {
    for (var i = 0, length = this.length >>> 0; i < length; i++) {
      if (i in this) iterator.call(context, this[i], i, this);
    }
  }
  if (!_each) _each = each;

  function clear() {
    this.length = 0;
    return this;
  }

  function first() {
    return this[0];
  }

  function last() {
    return this[this.length - 1];
  }

  function compact() {
    return this.select(function(value) {
      return value != null;
    });
  }

  function flatten() {
    return this.inject([], function(array, value) {
      if (Object.isArray(value))
        return array.concat(value.flatten());
      array.push(value);
      return array;
    });
  }

  function without() {
    var values = slice.call(arguments, 0);
    return this.select(function(value) {
      return !values.include(value);
    });
  }

  function reverse(inline) {
    return (inline === false ? this.toArray() : this)._reverse();
  }

  function uniq(sorted) {
    return this.inject([], function(array, value, index) {
      if (0 == index || (sorted ? array.last() != value : !array.include(value)))
        array.push(value);
      return array;
    });
  }

  function intersect(array) {
    return this.uniq().findAll(function(item) {
      return array.detect(function(value) { return item === value });
    });
  }


  function clone() {
    return slice.call(this, 0);
  }

  function size() {
    return this.length;
  }

  function inspect() {
    return '[' + this.map(Object.inspect).join(', ') + ']';
  }

  function indexOf(item, i) {
    i || (i = 0);
    var length = this.length;
    if (i < 0) i = length + i;
    for (; i < length; i++)
      if (this[i] === item) return i;
    return -1;
  }

  function lastIndexOf(item, i) {
    i = isNaN(i) ? this.length : (i < 0 ? this.length + i : i) + 1;
    var n = this.slice(0, i).reverse().indexOf(item);
    return (n < 0) ? n : i - n - 1;
  }

  function concat() {
    var array = slice.call(this, 0), item;
    for (var i = 0, length = arguments.length; i < length; i++) {
      item = arguments[i];
      if (Object.isArray(item) && !('callee' in item)) {
        for (var j = 0, arrayLength = item.length; j < arrayLength; j++)
          array.push(item[j]);
      } else {
        array.push(item);
      }
    }
    return array;
  }

  Object.extend(arrayProto, Enumerable);

  if (!arrayProto._reverse)
    arrayProto._reverse = arrayProto.reverse;

  Object.extend(arrayProto, {
    _each:     _each,
    clear:     clear,
    first:     first,
    last:      last,
    compact:   compact,
    flatten:   flatten,
    without:   without,
    reverse:   reverse,
    uniq:      uniq,
    intersect: intersect,
    clone:     clone,
    toArray:   clone,
    size:      size,
    inspect:   inspect
  });

  var CONCAT_ARGUMENTS_BUGGY = (function() {
    return [].concat(arguments)[0][0] !== 1;
  })(1,2)

  if (CONCAT_ARGUMENTS_BUGGY) arrayProto.concat = concat;

  if (!arrayProto.indexOf) arrayProto.indexOf = indexOf;
  if (!arrayProto.lastIndexOf) arrayProto.lastIndexOf = lastIndexOf;
})();
function $H(object) {
  return new Hash(object);
};

var Hash = Class.create(Enumerable, (function() {
  function initialize(object) {
    this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);
  }


  function _each(iterator) {
    for (var key in this._object) {
      var value = this._object[key], pair = [key, value];
      pair.key = key;
      pair.value = value;
      iterator(pair);
    }
  }

  function set(key, value) {
    return this._object[key] = value;
  }

  function get(key) {
    if (this._object[key] !== Object.prototype[key])
      return this._object[key];
  }

  function unset(key) {
    var value = this._object[key];
    delete this._object[key];
    return value;
  }

  function toObject() {
    return Object.clone(this._object);
  }



  function keys() {
    return this.pluck('key');
  }

  function values() {
    return this.pluck('value');
  }

  function index(value) {
    var match = this.detect(function(pair) {
      return pair.value === value;
    });
    return match && match.key;
  }

  function merge(object) {
    return this.clone().update(object);
  }

  function update(object) {
    return new Hash(object).inject(this, function(result, pair) {
      result.set(pair.key, pair.value);
      return result;
    });
  }

  function toQueryPair(key, value) {
    if (Object.isUndefined(value)) return key;
    return key + '=' + encodeURIComponent(String.interpret(value));
  }

  function toQueryString() {
    return this.inject([], function(results, pair) {
      var key = encodeURIComponent(pair.key), values = pair.value;

      if (values && typeof values == 'object') {
        if (Object.isArray(values)) {
          var queryValues = [];
          for (var i = 0, len = values.length, value; i < len; i++) {
            value = values[i];
            queryValues.push(toQueryPair(key, value));
          }
          return results.concat(queryValues);
        }
      } else results.push(toQueryPair(key, values));
      return results;
    }).join('&');
  }

  function inspect() {
    return '#<Hash:{' + this.map(function(pair) {
      return pair.map(Object.inspect).join(': ');
    }).join(', ') + '}>';
  }

  function clone() {
    return new Hash(this);
  }

  return {
    initialize:             initialize,
    _each:                  _each,
    set:                    set,
    get:                    get,
    unset:                  unset,
    toObject:               toObject,
    toTemplateReplacements: toObject,
    keys:                   keys,
    values:                 values,
    index:                  index,
    merge:                  merge,
    update:                 update,
    toQueryString:          toQueryString,
    inspect:                inspect,
    toJSON:                 toObject,
    clone:                  clone
  };
})());

Hash.from = $H;
Object.extend(Number.prototype, (function() {
  function toColorPart() {
    return this.toPaddedString(2, 16);
  }

  function succ() {
    return this + 1;
  }

  function times(iterator, context) {
    $R(0, this, true).each(iterator, context);
    return this;
  }

  function toPaddedString(length, radix) {
    var string = this.toString(radix || 10);
    return '0'.times(length - string.length) + string;
  }

  function abs() {
    return Math.abs(this);
  }

  function round() {
    return Math.round(this);
  }

  function ceil() {
    return Math.ceil(this);
  }

  function floor() {
    return Math.floor(this);
  }

  return {
    toColorPart:    toColorPart,
    succ:           succ,
    times:          times,
    toPaddedString: toPaddedString,
    abs:            abs,
    round:          round,
    ceil:           ceil,
    floor:          floor
  };
})());

function $R(start, end, exclusive) {
  return new ObjectRange(start, end, exclusive);
}

var ObjectRange = Class.create(Enumerable, (function() {
  function initialize(start, end, exclusive) {
    this.start = start;
    this.end = end;
    this.exclusive = exclusive;
  }

  function _each(iterator) {
    var value = this.start;
    while (this.include(value)) {
      iterator(value);
      value = value.succ();
    }
  }

  function include(value) {
    if (value < this.start)
      return false;
    if (this.exclusive)
      return value < this.end;
    return value <= this.end;
  }

  return {
    initialize: initialize,
    _each:      _each,
    include:    include
  };
})());



function $(element) {
  if (arguments.length > 1) {
    for (var i = 0, elements = [], length = arguments.length; i < length; i++)
      elements.push($(arguments[i]));
    return elements;
  }
  if (Object.isString(element))
    element = document.getElementById(element);
  return Element.extend(element);
}

if (Prototype.BrowserFeatures.XPath) {
  document._getElementsByXPath = function(expression, parentElement) {
    var results = [];
    var query = document.evaluate(expression, $(parentElement) || document,
      null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    for (var i = 0, length = query.snapshotLength; i < length; i++)
      results.push(Element.extend(query.snapshotItem(i)));
    return results;
  };
}

/*--------------------------------------------------------------------------*/

if (!Node) var Node = { };

if (!Node.ELEMENT_NODE) {
  Object.extend(Node, {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  });
}



(function(global) {
  function shouldUseCache(tagName, attributes) {
    if (tagName === 'select') return false;
    if ('type' in attributes) return false;
    return true;
  }

  var HAS_EXTENDED_CREATE_ELEMENT_SYNTAX = (function(){
    try {
      var el = document.createElement('<input name="x">');
      return el.tagName.toLowerCase() === 'input' && el.name === 'x';
    }
    catch(err) {
      return false;
    }
  })();

  var element = global.Element;

  global.Element = function(tagName, attributes) {
    attributes = attributes || { };
    tagName = tagName.toLowerCase();
    var cache = Element.cache;

    if (HAS_EXTENDED_CREATE_ELEMENT_SYNTAX && attributes.name) {
      tagName = '<' + tagName + ' name="' + attributes.name + '">';
      delete attributes.name;
      return Element.writeAttribute(document.createElement(tagName), attributes);
    }

    if (!cache[tagName]) cache[tagName] = Element.extend(document.createElement(tagName));

    var node = shouldUseCache(tagName, attributes) ?
     cache[tagName].cloneNode(false) : document.createElement(tagName);

    return Element.writeAttribute(node, attributes);
  };

  Object.extend(global.Element, element || { });
  if (element) global.Element.prototype = element.prototype;

})(this);

Element.idCounter = 1;
Element.cache = { };

Element._purgeElement = function(element) {
  var uid = element._prototypeUID;
  if (uid) {
    Element.stopObserving(element);
    element._prototypeUID = void 0;
    delete Element.Storage[uid];
  }
}

Element.Methods = {
  visible: function(element) {
    return $(element).style.display != 'none';
  },

  toggle: function(element) {
    element = $(element);
    Element[Element.visible(element) ? 'hide' : 'show'](element);
    return element;
  },

  hide: function(element) {
    element = $(element);
    element.style.display = 'none';
    return element;
  },

  show: function(element) {
    element = $(element);
    element.style.display = '';
    return element;
  },

  remove: function(element) {
    element = $(element);
    element.parentNode.removeChild(element);
    return element;
  },

  update: (function(){

    var SELECT_ELEMENT_INNERHTML_BUGGY = (function(){
      var el = document.createElement("select"),
          isBuggy = true;
      el.innerHTML = "<option value=\"test\">test</option>";
      if (el.options && el.options[0]) {
        isBuggy = el.options[0].nodeName.toUpperCase() !== "OPTION";
      }
      el = null;
      return isBuggy;
    })();

    var TABLE_ELEMENT_INNERHTML_BUGGY = (function(){
      try {
        var el = document.createElement("table");
        if (el && el.tBodies) {
          el.innerHTML = "<tbody><tr><td>test</td></tr></tbody>";
          var isBuggy = typeof el.tBodies[0] == "undefined";
          el = null;
          return isBuggy;
        }
      } catch (e) {
        return true;
      }
    })();

    var LINK_ELEMENT_INNERHTML_BUGGY = (function() {
      try {
        var el = document.createElement('div');
        el.innerHTML = "<link>";
        var isBuggy = (el.childNodes.length === 0);
        el = null;
        return isBuggy;
      } catch(e) {
        return true;
      }
    })();

    var ANY_INNERHTML_BUGGY = SELECT_ELEMENT_INNERHTML_BUGGY ||
     TABLE_ELEMENT_INNERHTML_BUGGY || LINK_ELEMENT_INNERHTML_BUGGY;

    var SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING = (function () {
      var s = document.createElement("script"),
          isBuggy = false;
      try {
        s.appendChild(document.createTextNode(""));
        isBuggy = !s.firstChild ||
          s.firstChild && s.firstChild.nodeType !== 3;
      } catch (e) {
        isBuggy = true;
      }
      s = null;
      return isBuggy;
    })();


    function update(element, content) {
      element = $(element);
      var purgeElement = Element._purgeElement;

      var descendants = element.getElementsByTagName('*'),
       i = descendants.length;
      while (i--) purgeElement(descendants[i]);

      if (content && content.toElement)
        content = content.toElement();

      if (Object.isElement(content))
        return element.update().insert(content);

      content = Object.toHTML(content);

      var tagName = element.tagName.toUpperCase();

      if (tagName === 'SCRIPT' && SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING) {
        element.text = content;
        return element;
      }

      if (ANY_INNERHTML_BUGGY) {
        if (tagName in Element._insertionTranslations.tags) {
          while (element.firstChild) {
            element.removeChild(element.firstChild);
          }
          Element._getContentFromAnonymousElement(tagName, content.stripScripts())
            .each(function(node) {
              element.appendChild(node)
            });
        } else if (LINK_ELEMENT_INNERHTML_BUGGY && Object.isString(content) && content.indexOf('<link') > -1) {
          while (element.firstChild) {
            element.removeChild(element.firstChild);
          }
          var nodes = Element._getContentFromAnonymousElement(tagName, content.stripScripts(), true);
          nodes.each(function(node) { element.appendChild(node) });
        }
        else {
          element.innerHTML = content.stripScripts();
        }
      }
      else {
        element.innerHTML = content.stripScripts();
      }

      content.evalScripts.bind(content).defer();
      return element;
    }

    return update;
  })(),

  replace: function(element, content) {
    element = $(element);
    if (content && content.toElement) content = content.toElement();
    else if (!Object.isElement(content)) {
      content = Object.toHTML(content);
      var range = element.ownerDocument.createRange();
      range.selectNode(element);
      content.evalScripts.bind(content).defer();
      content = range.createContextualFragment(content.stripScripts());
    }
    element.parentNode.replaceChild(content, element);
    return element;
  },

  insert: function(element, insertions) {
    element = $(element);

    if (Object.isString(insertions) || Object.isNumber(insertions) ||
        Object.isElement(insertions) || (insertions && (insertions.toElement || insertions.toHTML)))
          insertions = {bottom:insertions};

    var content, insert, tagName, childNodes;

    for (var position in insertions) {
      content  = insertions[position];
      position = position.toLowerCase();
      insert = Element._insertionTranslations[position];

      if (content && content.toElement) content = content.toElement();
      if (Object.isElement(content)) {
        insert(element, content);
        continue;
      }

      content = Object.toHTML(content);

      tagName = ((position == 'before' || position == 'after')
        ? element.parentNode : element).tagName.toUpperCase();

      childNodes = Element._getContentFromAnonymousElement(tagName, content.stripScripts());

      if (position == 'top' || position == 'after') childNodes.reverse();
      childNodes.each(insert.curry(element));

      content.evalScripts.bind(content).defer();
    }

    return element;
  },

  wrap: function(element, wrapper, attributes) {
    element = $(element);
    if (Object.isElement(wrapper))
      $(wrapper).writeAttribute(attributes || { });
    else if (Object.isString(wrapper)) wrapper = new Element(wrapper, attributes);
    else wrapper = new Element('div', wrapper);
    if (element.parentNode)
      element.parentNode.replaceChild(wrapper, element);
    wrapper.appendChild(element);
    return wrapper;
  },

  inspect: function(element) {
    element = $(element);
    var result = '<' + element.tagName.toLowerCase();
    $H({'id': 'id', 'className': 'class'}).each(function(pair) {
      var property = pair.first(),
          attribute = pair.last(),
          value = (element[property] || '').toString();
      if (value) result += ' ' + attribute + '=' + value.inspect(true);
    });
    return result + '>';
  },

  recursivelyCollect: function(element, property, maximumLength) {
    element = $(element);
    maximumLength = maximumLength || -1;
    var elements = [];

    while (element = element[property]) {
      if (element.nodeType == 1)
        elements.push(Element.extend(element));
      if (elements.length == maximumLength)
        break;
    }

    return elements;
  },

  ancestors: function(element) {
    return Element.recursivelyCollect(element, 'parentNode');
  },

  descendants: function(element) {
    return Element.select(element, "*");
  },

  firstDescendant: function(element) {
    element = $(element).firstChild;
    while (element && element.nodeType != 1) element = element.nextSibling;
    return $(element);
  },

  immediateDescendants: function(element) {
    var results = [], child = $(element).firstChild;
    while (child) {
      if (child.nodeType === 1) {
        results.push(Element.extend(child));
      }
      child = child.nextSibling;
    }
    return results;
  },

  previousSiblings: function(element, maximumLength) {
    return Element.recursivelyCollect(element, 'previousSibling');
  },

  nextSiblings: function(element) {
    return Element.recursivelyCollect(element, 'nextSibling');
  },

  siblings: function(element) {
    element = $(element);
    return Element.previousSiblings(element).reverse()
      .concat(Element.nextSiblings(element));
  },

  match: function(element, selector) {
    element = $(element);
    if (Object.isString(selector))
      return Prototype.Selector.match(element, selector);
    return selector.match(element);
  },

  up: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(element.parentNode);
    var ancestors = Element.ancestors(element);
    return Object.isNumber(expression) ? ancestors[expression] :
      Prototype.Selector.find(ancestors, expression, index);
  },

  down: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return Element.firstDescendant(element);
    return Object.isNumber(expression) ? Element.descendants(element)[expression] :
      Element.select(element, expression)[index || 0];
  },

  previous: function(element, expression, index) {
    element = $(element);
    if (Object.isNumber(expression)) index = expression, expression = false;
    if (!Object.isNumber(index)) index = 0;

    if (expression) {
      return Prototype.Selector.find(element.previousSiblings(), expression, index);
    } else {
      return element.recursivelyCollect("previousSibling", index + 1)[index];
    }
  },

  next: function(element, expression, index) {
    element = $(element);
    if (Object.isNumber(expression)) index = expression, expression = false;
    if (!Object.isNumber(index)) index = 0;

    if (expression) {
      return Prototype.Selector.find(element.nextSiblings(), expression, index);
    } else {
      var maximumLength = Object.isNumber(index) ? index + 1 : 1;
      return element.recursivelyCollect("nextSibling", index + 1)[index];
    }
  },


  select: function(element) {
    element = $(element);
    var expressions = Array.prototype.slice.call(arguments, 1).join(', ');
    return Prototype.Selector.select(expressions, element);
  },

  adjacent: function(element) {
    element = $(element);
    var expressions = Array.prototype.slice.call(arguments, 1).join(', ');
    return Prototype.Selector.select(expressions, element.parentNode).without(element);
  },

  identify: function(element) {
    element = $(element);
    var id = Element.readAttribute(element, 'id');
    if (id) return id;
    do { id = 'anonymous_element_' + Element.idCounter++ } while ($(id));
    Element.writeAttribute(element, 'id', id);
    return id;
  },

  readAttribute: function(element, name) {
    element = $(element);
    if (Prototype.Browser.IE) {
      var t = Element._attributeTranslations.read;
      if (t.values[name]) return t.values[name](element, name);
      if (t.names[name]) name = t.names[name];
      if (name.include(':')) {
        return (!element.attributes || !element.attributes[name]) ? null :
         element.attributes[name].value;
      }
    }
    return element.getAttribute(name);
  },

  writeAttribute: function(element, name, value) {
    element = $(element);
    var attributes = { }, t = Element._attributeTranslations.write;

    if (typeof name == 'object') attributes = name;
    else attributes[name] = Object.isUndefined(value) ? true : value;

    for (var attr in attributes) {
      name = t.names[attr] || attr;
      value = attributes[attr];
      if (t.values[attr]) name = t.values[attr](element, value);
      if (value === false || value === null)
        element.removeAttribute(name);
      else if (value === true)
        element.setAttribute(name, name);
      else element.setAttribute(name, value);
    }
    return element;
  },

  getHeight: function(element) {
    return Element.getDimensions(element).height;
  },

  getWidth: function(element) {
    return Element.getDimensions(element).width;
  },

  classNames: function(element) {
    return new Element.ClassNames(element);
  },

  hasClassName: function(element, className) {
    if (!(element = $(element))) return;
    var elementClassName = element.className;
    return (elementClassName.length > 0 && (elementClassName == className ||
      new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
  },

  addClassName: function(element, className) {
    if (!(element = $(element))) return;
    if (!Element.hasClassName(element, className))
      element.className += (element.className ? ' ' : '') + className;
    return element;
  },

  removeClassName: function(element, className) {
    if (!(element = $(element))) return;
    element.className = element.className.replace(
      new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' ').strip();
    return element;
  },

  toggleClassName: function(element, className) {
    if (!(element = $(element))) return;
    return Element[Element.hasClassName(element, className) ?
      'removeClassName' : 'addClassName'](element, className);
  },

  cleanWhitespace: function(element) {
    element = $(element);
    var node = element.firstChild;
    while (node) {
      var nextNode = node.nextSibling;
      if (node.nodeType == 3 && !/\S/.test(node.nodeValue))
        element.removeChild(node);
      node = nextNode;
    }
    return element;
  },

  empty: function(element) {
    return $(element).innerHTML.blank();
  },

  descendantOf: function(element, ancestor) {
    element = $(element), ancestor = $(ancestor);

    if (element.compareDocumentPosition)
      return (element.compareDocumentPosition(ancestor) & 8) === 8;

    if (ancestor.contains)
      return ancestor.contains(element) && ancestor !== element;

    while (element = element.parentNode)
      if (element == ancestor) return true;

    return false;
  },

  scrollTo: function(element) {
    element = $(element);
    var pos = Element.cumulativeOffset(element);
    window.scrollTo(pos[0], pos[1]);
    return element;
  },

  getStyle: function(element, style) {
    element = $(element);
    style = style == 'float' ? 'cssFloat' : style.camelize();
    var value = element.style[style];
    if (!value || value == 'auto') {
      var css = document.defaultView.getComputedStyle(element, null);
      value = css ? css[style] : null;
    }
    if (style == 'opacity') return value ? parseFloat(value) : 1.0;
    return value == 'auto' ? null : value;
  },

  getOpacity: function(element) {
    return Element.getStyle($(element),'opacity');
  },

  setStyle: function(element, styles) {
    element = $(element);
    var elementStyle = element.style, match;
    if (Object.isString(styles)) {
      element.style.cssText += ';' + styles;
      return styles.include('opacity') ?
        Element.setOpacity(element,styles.match(/opacity:\s*(\d?\.?\d*)/)[1]) : element;
    }
    for (var property in styles)
      if (property == 'opacity') Element.setOpacity(element, styles[property]);
      else
        elementStyle[(property == 'float' || property == 'cssFloat') ?
          (Object.isUndefined(elementStyle.styleFloat) ? 'cssFloat' : 'styleFloat') :
            property] = styles[property];

    return element;
  },

  setOpacity: function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;
    return element;
  },

  makePositioned: function(element) {
    element = $(element);
    var pos = Element.getStyle(element, 'position');
    if (pos == 'static' || !pos) {
      element._madePositioned = true;
      element.style.position = 'relative';
      if (Prototype.Browser.Opera) {
        element.style.top = 0;
        element.style.left = 0;
      }
    }
    return element;
  },

  undoPositioned: function(element) {
    element = $(element);
    if (element._madePositioned) {
      element._madePositioned = undefined;
      element.style.position =
        element.style.top =
        element.style.left =
        element.style.bottom =
        element.style.right = '';
    }
    return element;
  },

  makeClipping: function(element) {
    element = $(element);
    if (element._overflow) return element;
    element._overflow = Element.getStyle(element, 'overflow') || 'auto';
    if (element._overflow !== 'hidden')
      element.style.overflow = 'hidden';
    return element;
  },

  undoClipping: function(element) {
    element = $(element);
    if (!element._overflow) return element;
    element.style.overflow = element._overflow == 'auto' ? '' : element._overflow;
    element._overflow = null;
    return element;
  },

  clonePosition: function(element, source) {
    var options = Object.extend({
      setLeft:    true,
      setTop:     true,
      setWidth:   true,
      setHeight:  true,
      offsetTop:  0,
      offsetLeft: 0
    }, arguments[2] || { });

    source = $(source);
    var p = Element.viewportOffset(source), delta = [0, 0], parent = null;

    element = $(element);

    if (Element.getStyle(element, 'position') == 'absolute') {
      parent = Element.getOffsetParent(element);
      delta = Element.viewportOffset(parent);
    }

    if (parent == document.body) {
      delta[0] -= document.body.offsetLeft;
      delta[1] -= document.body.offsetTop;
    }

    if (options.setLeft)   element.style.left  = (p[0] - delta[0] + options.offsetLeft) + 'px';
    if (options.setTop)    element.style.top   = (p[1] - delta[1] + options.offsetTop) + 'px';
    if (options.setWidth)  element.style.width = source.offsetWidth + 'px';
    if (options.setHeight) element.style.height = source.offsetHeight + 'px';
    return element;
  }
};

Object.extend(Element.Methods, {
  getElementsBySelector: Element.Methods.select,

  childElements: Element.Methods.immediateDescendants
});

Element._attributeTranslations = {
  write: {
    names: {
      className: 'class',
      htmlFor:   'for'
    },
    values: { }
  }
};

if (Prototype.Browser.Opera) {
  Element.Methods.getStyle = Element.Methods.getStyle.wrap(
    function(proceed, element, style) {
      switch (style) {
        case 'height': case 'width':
          if (!Element.visible(element)) return null;

          var dim = parseInt(proceed(element, style), 10);

          if (dim !== element['offset' + style.capitalize()])
            return dim + 'px';

          var properties;
          if (style === 'height') {
            properties = ['border-top-width', 'padding-top',
             'padding-bottom', 'border-bottom-width'];
          }
          else {
            properties = ['border-left-width', 'padding-left',
             'padding-right', 'border-right-width'];
          }
          return properties.inject(dim, function(memo, property) {
            var val = proceed(element, property);
            return val === null ? memo : memo - parseInt(val, 10);
          }) + 'px';
        default: return proceed(element, style);
      }
    }
  );

  Element.Methods.readAttribute = Element.Methods.readAttribute.wrap(
    function(proceed, element, attribute) {
      if (attribute === 'title') return element.title;
      return proceed(element, attribute);
    }
  );
}

else if (Prototype.Browser.Gecko && /rv:1\.8\.0/.test(navigator.userAgent)) {
  Element.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1) ? 0.999999 :
      (value === '') ? '' : (value < 0.00001) ? 0 : value;
    return element;
  };
}

else if (Prototype.Browser.WebKit) {
  Element.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;

    if (value == 1)
      if (element.tagName.toUpperCase() == 'IMG' && element.width) {
        element.width++; element.width--;
      } else try {
        var n = document.createTextNode(' ');
        element.appendChild(n);
        element.removeChild(n);
      } catch (e) { }

    return element;
  };
}

if ('outerHTML' in document.documentElement) {
  Element.Methods.replace = function(element, content) {
    element = $(element);

    if (content && content.toElement) content = content.toElement();
    if (Object.isElement(content)) {
      element.parentNode.replaceChild(content, element);
      return element;
    }

    content = Object.toHTML(content);
    var parent = element.parentNode, tagName = parent.tagName.toUpperCase();

    if (Element._insertionTranslations.tags[tagName]) {
      var nextSibling = element.next(),
          fragments = Element._getContentFromAnonymousElement(tagName, content.stripScripts());
      parent.removeChild(element);
      if (nextSibling)
        fragments.each(function(node) { parent.insertBefore(node, nextSibling) });
      else
        fragments.each(function(node) { parent.appendChild(node) });
    }
    else element.outerHTML = content.stripScripts();

    content.evalScripts.bind(content).defer();
    return element;
  };
}

Element._returnOffset = function(l, t) {
  var result = [l, t];
  result.left = l;
  result.top = t;
  return result;
};

Element._getContentFromAnonymousElement = function(tagName, html, force) {
  var div = new Element('div'),
      t = Element._insertionTranslations.tags[tagName];

  var workaround = false;
  if (t) workaround = true;
  else if (force) {
    workaround = true;
    t = ['', '', 0];
  }

  if (workaround) {
    div.innerHTML = '&nbsp;' + t[0] + html + t[1];
    div.removeChild(div.firstChild);
    for (var i = t[2]; i--; ) {
      div = div.firstChild;
    }
  }
  else {
    div.innerHTML = html;
  }
  return $A(div.childNodes);
};

Element._insertionTranslations = {
  before: function(element, node) {
    element.parentNode.insertBefore(node, element);
  },
  top: function(element, node) {
    element.insertBefore(node, element.firstChild);
  },
  bottom: function(element, node) {
    element.appendChild(node);
  },
  after: function(element, node) {
    element.parentNode.insertBefore(node, element.nextSibling);
  },
  tags: {
    TABLE:  ['<table>',                '</table>',                   1],
    TBODY:  ['<table><tbody>',         '</tbody></table>',           2],
    TR:     ['<table><tbody><tr>',     '</tr></tbody></table>',      3],
    TD:     ['<table><tbody><tr><td>', '</td></tr></tbody></table>', 4],
    SELECT: ['<select>',               '</select>',                  1]
  }
};

(function() {
  var tags = Element._insertionTranslations.tags;
  Object.extend(tags, {
    THEAD: tags.TBODY,
    TFOOT: tags.TBODY,
    TH:    tags.TD
  });
})();

Element.Methods.Simulated = {
  hasAttribute: function(element, attribute) {
    attribute = Element._attributeTranslations.has[attribute] || attribute;
    var node = $(element).getAttributeNode(attribute);
    return !!(node && node.specified);
  }
};

Element.Methods.ByTag = { };

Object.extend(Element, Element.Methods);

(function(div) {

  if (!Prototype.BrowserFeatures.ElementExtensions && div['__proto__']) {
    window.HTMLElement = { };
    window.HTMLElement.prototype = div['__proto__'];
    Prototype.BrowserFeatures.ElementExtensions = true;
  }

  div = null;

})(document.createElement('div'));

Element.extend = (function() {

  function checkDeficiency(tagName) {
    if (typeof window.Element != 'undefined') {
      var proto = window.Element.prototype;
      if (proto) {
        var id = '_' + (Math.random()+'').slice(2),
            el = document.createElement(tagName);
        proto[id] = 'x';
        var isBuggy = (el[id] !== 'x');
        delete proto[id];
        el = null;
        return isBuggy;
      }
    }
    return false;
  }

  function extendElementWith(element, methods) {
    for (var property in methods) {
      var value = methods[property];
      if (Object.isFunction(value) && !(property in element))
        element[property] = value.methodize();
    }
  }

  var HTMLOBJECTELEMENT_PROTOTYPE_BUGGY = checkDeficiency('object');

  if (Prototype.BrowserFeatures.SpecificElementExtensions) {
    if (HTMLOBJECTELEMENT_PROTOTYPE_BUGGY) {
      return function(element) {
        if (element && typeof element._extendedByPrototype == 'undefined') {
          var t = element.tagName;
          if (t && (/^(?:object|applet|embed)$/i.test(t))) {
            extendElementWith(element, Element.Methods);
            extendElementWith(element, Element.Methods.Simulated);
            extendElementWith(element, Element.Methods.ByTag[t.toUpperCase()]);
          }
        }
        return element;
      }
    }
    return Prototype.K;
  }

  var Methods = { }, ByTag = Element.Methods.ByTag;

  var extend = Object.extend(function(element) {
    if (!element || typeof element._extendedByPrototype != 'undefined' ||
        element.nodeType != 1 || element == window) return element;

    var methods = Object.clone(Methods),
        tagName = element.tagName.toUpperCase();

    if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);

    extendElementWith(element, methods);

    element._extendedByPrototype = Prototype.emptyFunction;
    return element;

  }, {
    refresh: function() {
      if (!Prototype.BrowserFeatures.ElementExtensions) {
        Object.extend(Methods, Element.Methods);
        Object.extend(Methods, Element.Methods.Simulated);
      }
    }
  });

  extend.refresh();
  return extend;
})();

if (document.documentElement.hasAttribute) {
  Element.hasAttribute = function(element, attribute) {
    return element.hasAttribute(attribute);
  };
}
else {
  Element.hasAttribute = Element.Methods.Simulated.hasAttribute;
}

Element.addMethods = function(methods) {
  var F = Prototype.BrowserFeatures, T = Element.Methods.ByTag;

  /*
  if (!methods) {
    Object.extend(Form, Form.Methods);
    Object.extend(Form.Element, Form.Element.Methods);
    Object.extend(Element.Methods.ByTag, {
      "FORM":     Object.clone(Form.Methods),
      "INPUT":    Object.clone(Form.Element.Methods),
      "SELECT":   Object.clone(Form.Element.Methods),
      "TEXTAREA": Object.clone(Form.Element.Methods),
      "BUTTON":   Object.clone(Form.Element.Methods)
    });
  }
  */

  if (arguments.length == 2) {
    var tagName = methods;
    methods = arguments[1];
  }

  if (!tagName) Object.extend(Element.Methods, methods || { });
  else {
    if (Object.isArray(tagName)) tagName.each(extend);
    else extend(tagName);
  }

  function extend(tagName) {
    tagName = tagName.toUpperCase();
    if (!Element.Methods.ByTag[tagName])
      Element.Methods.ByTag[tagName] = { };
    Object.extend(Element.Methods.ByTag[tagName], methods);
  }

  function copy(methods, destination, onlyIfAbsent) {
    onlyIfAbsent = onlyIfAbsent || false;
    for (var property in methods) {
      var value = methods[property];
      if (!Object.isFunction(value)) continue;
      if (!onlyIfAbsent || !(property in destination))
        destination[property] = value.methodize();
    }
  }

  function findDOMClass(tagName) {
    var klass;
    var trans = {
      "OPTGROUP": "OptGroup", "TEXTAREA": "TextArea", "P": "Paragraph",
      "FIELDSET": "FieldSet", "UL": "UList", "OL": "OList", "DL": "DList",
      "DIR": "Directory", "H1": "Heading", "H2": "Heading", "H3": "Heading",
      "H4": "Heading", "H5": "Heading", "H6": "Heading", "Q": "Quote",
      "INS": "Mod", "DEL": "Mod", "A": "Anchor", "IMG": "Image", "CAPTION":
      "TableCaption", "COL": "TableCol", "COLGROUP": "TableCol", "THEAD":
      "TableSection", "TFOOT": "TableSection", "TBODY": "TableSection", "TR":
      "TableRow", "TH": "TableCell", "TD": "TableCell", "FRAMESET":
      "FrameSet", "IFRAME": "IFrame"
    };
    if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
    if (window[klass]) return window[klass];
    klass = 'HTML' + tagName + 'Element';
    if (window[klass]) return window[klass];
    klass = 'HTML' + tagName.capitalize() + 'Element';
    if (window[klass]) return window[klass];

    var element = document.createElement(tagName),
        proto = element['__proto__'] || element.constructor.prototype;

    element = null;
    return proto;
  }

  var elementPrototype = window.HTMLElement ? HTMLElement.prototype :
   Element.prototype;

  if (F.ElementExtensions) {
    copy(Element.Methods, elementPrototype);
    copy(Element.Methods.Simulated, elementPrototype, true);
  }

  if (F.SpecificElementExtensions) {
    for (var tag in Element.Methods.ByTag) {
      var klass = findDOMClass(tag);
      if (Object.isUndefined(klass)||klass.prototype==undefined) continue;
      copy(T[tag], klass.prototype);
    }
  }

  Object.extend(Element, Element.Methods);
  delete Element.ByTag;

  if (Element.extend.refresh) Element.extend.refresh();
  Element.cache = { };
};


document.viewport = {

  getDimensions: function() {
    return { width: this.getWidth(), height: this.getHeight() };
  },

  getScrollOffsets: function() {
    return Element._returnOffset(
      window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,
      window.pageYOffset || document.documentElement.scrollTop  || document.body.scrollTop);
  }
};

(function(viewport) {
  var B = Prototype.Browser, doc = document, element, property = {};

  function getRootElement() {
    if (B.WebKit && !doc.evaluate)
      return document;

    if (B.Opera && parseFloat(window.opera.version()) < 9.5)
      return document.body;

    return document.documentElement;
  }

  function define(D) {
    if (!element) element = getRootElement();

    property[D] = 'client' + D;

    viewport['get' + D] = function() { return element[property[D]] };
    return viewport['get' + D]();
  }

  viewport.getWidth  = define.curry('Width');

  viewport.getHeight = define.curry('Height');
})(document.viewport);


Element.Storage = {
  UID: 1
};

Element.addMethods({
  getStorage: function(element) {
    if (!(element = $(element))) return;

    var uid;
    if (element === window) {
      uid = 0;
    } else {
      if (typeof element._prototypeUID === "undefined")
        element._prototypeUID = Element.Storage.UID++;
      uid = element._prototypeUID;
    }

    if (!Element.Storage[uid])
      Element.Storage[uid] = $H();

    return Element.Storage[uid];
  },

  store: function(element, key, value) {
    if (!(element = $(element))) return;

    if (arguments.length === 2) {
      Element.getStorage(element).update(key);
    } else {
      Element.getStorage(element).set(key, value);
    }

    return element;
  },

  retrieve: function(element, key, defaultValue) {
    if (!(element = $(element))) return;
    var hash = Element.getStorage(element), value = hash.get(key);

    if (Object.isUndefined(value)) {
      hash.set(key, defaultValue);
      value = defaultValue;
    }

    return value;
  },

  clone: function(element, deep) {
    if (!(element = $(element))) return;
    var clone = element.cloneNode(deep);
    clone._prototypeUID = void 0;
    if (deep) {
      var descendants = Element.select(clone, '*'),
          i = descendants.length;
      while (i--) {
        descendants[i]._prototypeUID = void 0;
      }
    }
    return Element.extend(clone);
  },

  purge: function(element) {
    if (!(element = $(element))) return;
    var purgeElement = Element._purgeElement;

    purgeElement(element);

    var descendants = element.getElementsByTagName('*'),
     i = descendants.length;

    while (i--) purgeElement(descendants[i]);

    return null;
  }
});

(function() {

  function toDecimal(pctString) {
    var match = pctString.match(/^(\d+)%?$/i);
    if (!match) return null;
    return (Number(match[1]) / 100);
  }

  function getPixelValue(value, property, context) {
    var element = null;
    if (Object.isElement(value)) {
      element = value;
	  value = Element.getStyle(element, property);
    }

    if (value === null) {
      return null;
    }

    if ((/^(?:-)?\d+(\.\d+)?(px)?$/i).test(value)) {
      return parseFloat(value);
    }

    var isPercentage = value.include('%'), isViewport = (context === document.viewport);

    if (/\d/.test(value) && element && element.runtimeStyle && !(isPercentage && isViewport)) {
      var style = element.style.left, rStyle = element.runtimeStyle.left;
      element.runtimeStyle.left = element.currentStyle.left;
      element.style.left = value || 0;
      value = element.style.pixelLeft;
      element.style.left = style;
      element.runtimeStyle.left = rStyle;

      return value;
    }

    if (element && isPercentage) {
      context = context || element.parentNode;
      var decimal = toDecimal(value);
      var whole = null;
      var position = Element.getStyle(element,'position');

      var isHorizontal = property.include('left') || property.include('right') ||
       property.include('width');

      var isVertical =  property.include('top') || property.include('bottom') ||
        property.include('height');

      if (context === document.viewport) {
        if (isHorizontal) {
          whole = document.viewport.getWidth();
        } else if (isVertical) {
          whole = document.viewport.getHeight();
        }
      } else {
        if (isHorizontal) {
          whole = $(context).measure('width');
        } else if (isVertical) {
          whole = $(context).measure('height');
        }
      }

      return (whole === null) ? 0 : whole * decimal;
    }

    return 0;
  }

  function toCSSPixels(number) {
    if (Object.isString(number) && number.endsWith('px')) {
      return number;
    }
    return number + 'px';
  }

  function isDisplayed(element) {
    var originalElement = element;
    while (element && element.parentNode) {
      var display = Element.getStyle(element,'display');
      if (display === 'none') {
        return false;
      }
      element = $(element.parentNode);
    }
    return true;
  }

  var hasLayout = Prototype.K;
  if ('currentStyle' in document.documentElement) {
    hasLayout = function(element) {
      if (!element.currentStyle.hasLayout) {
        element.style.zoom = 1;
      }
      return element;
    };
  }

  function cssNameFor(key) {
    if (key.include('border')) key = key + '-width';
    return key.camelize();
  }

  Element.Layout = Class.create(Hash, {
    initialize: function($super, element, preCompute) {
      $super();
      this.element = $(element);

      Element.Layout.PROPERTIES.each( function(property) {
        this._set(property, null);
      }, this);

      if (preCompute) {
        this._preComputing = true;
        this._begin();
        Element.Layout.PROPERTIES.each( this._compute, this );
        this._end();
        this._preComputing = false;
      }
    },

    _set: function(property, value) {
      return Hash.prototype.set.call(this, property, value);
    },

    set: function(property, value) {
      throw "Properties of Element.Layout are read-only.";
    },

    get: function($super, property) {
      var value = $super(property);
      return value === null ? this._compute(property) : value;
    },

    _begin: function() {
      if (this._prepared) return;

      var element = this.element;
      if (isDisplayed(element)) {
        this._prepared = true;
        return;
      }

      var originalStyles = {
        position:   element.style.position   || '',
        width:      element.style.width      || '',
        visibility: element.style.visibility || '',
        display:    element.style.display    || ''
      };

      Element.store(element,'prototype_original_styles', originalStyles);

      var position = Element.getStyle(element,'position'),
       width = Element.getStyle(element,'width');

      if (width === "0px" || width === null) {
        element.style.display = 'block';
        width = Element.getStyle(element,'width');
      }

      var context = (position === 'fixed') ? document.viewport :
       element.parentNode;

      Element.setStyle(element,{
        position:   'absolute',
        visibility: 'hidden',
        display:    'block'
      });

      var positionedWidth = Element.getStyle(element,'width');

      var newWidth;
      if (width && (positionedWidth === width)) {
        newWidth = getPixelValue(element, 'width', context);
      } else if (position === 'absolute' || position === 'fixed') {
        newWidth = getPixelValue(element, 'width', context);
      } else {
        var parent = element.parentNode, pLayout = Element.getLayout($(parent));

        newWidth = pLayout.get('width') -
         this.get('margin-left') -
         this.get('border-left') -
         this.get('padding-left') -
         this.get('padding-right') -
         this.get('border-right') -
         this.get('margin-right');
      }

      Element.setStyle(element,{ width: newWidth + 'px' });

      this._prepared = true;
    },

    _end: function() {
      var element = this.element;
      var originalStyles = Element.retrieve(element,'prototype_original_styles');
      Element.store(element,'prototype_original_styles', null);
      Element.setStyle(element,originalStyles);
      this._prepared = false;
    },

    _compute: function(property) {
      var COMPUTATIONS = Element.Layout.COMPUTATIONS;
      if (!(property in COMPUTATIONS)) {
        throw "Property not found.";
      }

      return this._set(property, COMPUTATIONS[property].call(this, this.element));
    },

    toObject: function() {
      var args = $A(arguments);
      var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
       args.join(' ').split(' ');
      var obj = {};
      keys.each( function(key) {
        if (!Element.Layout.PROPERTIES.include(key)) return;
        var value = this.get(key);
        if (value != null) obj[key] = value;
      }, this);
      return obj;
    },

    toHash: function() {
      var obj = this.toObject.apply(this, arguments);
      return new Hash(obj);
    },

    toCSS: function() {
      var args = $A(arguments);
      var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
       args.join(' ').split(' ');
      var css = {};

      keys.each( function(key) {
        if (!Element.Layout.PROPERTIES.include(key)) return;
        if (Element.Layout.COMPOSITE_PROPERTIES.include(key)) return;

        var value = this.get(key);
        if (value != null) css[cssNameFor(key)] = value + 'px';
      }, this);
      return css;
    },

    inspect: function() {
      return "#<Element.Layout>";
    }
  });
  
    Element.Offset = Class.create({
    initialize: function(left, top) {
      this.left = left.round();
      this.top  = top.round();

      this[0] = this.left;
      this[1] = this.top;
    },

    relativeTo: function(offset) {
      return new Element.Offset(
        this.left - offset.left,
        this.top  - offset.top
      );
    },

    inspect: function() {
      return "#<Element.Offset left: #{left} top: #{top}>".interpolate(this);
    },

    toString: function() {
      return "[#{left}, #{top}]".interpolate(this);
    },

    toArray: function() {
      return [this.left, this.top];
    }
  });

      
  Element.addMethods({
    getLayout: function(element, preCompute) {
		return new Element.Layout(element, preCompute);
	},
	measure: function(element, property) {
		return Element.getLayout($(element)).get(property);
	},
    getDimensions: function(element) {
		element = $(element);
		var display = Element.getStyle(element, 'display');

		if (display && display !== 'none') {
		  return { width: element.offsetWidth, height: element.offsetHeight };
		}

		var style = element.style;
		var originalStyles = {
		  visibility: style.visibility,
		  position:   style.position,
		  display:    style.display
		};

		var newStyles = {
		  visibility: 'hidden',
		  display:    'block'
		};

		if (originalStyles.position !== 'fixed')
		  newStyles.position = 'absolute';

		Element.setStyle(element, newStyles);

		var dimensions = {
		  width:  element.offsetWidth,
		  height: element.offsetHeight
		};

		Element.setStyle(element, originalStyles);

		return dimensions;
	},
    getOffsetParent: function(element) {
		element = $(element);

		if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
		  return $(document.body);

		var isInline = (Element.getStyle(element, 'display') === 'inline');
		if (!isInline && element.offsetParent) return $(element.offsetParent);

		while ((element = element.parentNode) && element !== document.body) {
		  if (Element.getStyle(element, 'position') !== 'static') {
			return isHtml(element) ? $(document.body) : $(element);
		  }
		}

		return $(document.body);
	},
    positionedOffset: function(element) {
		element = $(element);

		var layout = Element.getLayout(element);

		var valueT = 0, valueL = 0;
		do {
		  valueT += element.offsetTop  || 0;
		  valueL += element.offsetLeft || 0;
		  element = element.offsetParent;
		  if (element) {
			if (isBody(element)) break;
			var p = Element.getStyle(element, 'position');
			if (p !== 'static') break;
		  }
		} while (element);

		valueL -= layout.get('margin-top');
		valueT -= layout.get('margin-left');

		return new Element.Offset(valueL, valueT);
	},
    cumulativeScrollOffset: function(element) {
		var valueT = 0, valueL = 0;
		do {
		  valueT += element.scrollTop  || 0;
		  valueL += element.scrollLeft || 0;
		  element = element.parentNode;
		} while (element);
		return new Element.Offset(valueL, valueT);
	},
    viewportOffset: function(forElement) {
		element = $(element);
		var valueT = 0, valueL = 0, docBody = document.body;

		var element = forElement;
		do {
		  valueT += element.offsetTop  || 0;
		  valueL += element.offsetLeft || 0;
		  if (element.offsetParent == docBody &&
			Element.getStyle(element, 'position') == 'absolute') break;
		} while (element = element.offsetParent);

		element = forElement;
		do {
		  if (element != docBody) {
			valueT -= element.scrollTop  || 0;
			valueL -= element.scrollLeft || 0;
		  }
		} while (element = element.parentNode);
		return new Element.Offset(valueL, valueT);
	},
    absolutize: function(element) {
		element = $(element);

		if (Element.getStyle(element, 'position') === 'absolute') {
		  return element;
		}

		var offsetParent = getOffsetParent(element);
		var eOffset = Element.viewportOffset(element),
		 pOffset = Element.viewportOffset(offsetParent);

		var offset = eOffset.relativeTo(pOffset);
		var layout = Element.getLayout(element);

		Element.store(element,'prototype_absolutize_original_styles', {
		  left:   Element.getStyle(element,'left'),
		  top:    Element.getStyle(element,'top'),
		  width:  Element.getStyle(element,'width'),
		  height: Element.getStyle(element,'height')
		});

		Element.setStyle(element,{
		  position: 'absolute',
		  top:    offset.top + 'px',
		  left:   offset.left + 'px',
		  width:  layout.get('width') + 'px',
		  height: layout.get('height') + 'px'
		});

		return element;
	},
    relativize: function(element) {
			element = $(element);
			if (Element.getStyle(element, 'position') === 'relative') {
			  return element;
			}

			var originalStyles =
			 Element.retrieve(element,'prototype_absolutize_original_styles');

			if (originalStyles) Element.setStyle(element,originalStyles);
			return element;
	},
	cumulativeOffset: (Prototype.Browser.Webkit ? function(element) {
		  element = $(element);
		  var valueT = 0, valueL = 0;
		  do {
			valueT += element.offsetTop  || 0;
			valueL += element.offsetLeft || 0;
			if (element.offsetParent == document.body)
			  if (Element.getStyle(element, 'position') == 'absolute') break;

			element = element.offsetParent;
		  } while (element);

		  return new Element.Offset(valueL, valueT);
		} : function(element) {
			element = $(element);
			var valueT = 0, valueL = 0;
			if (element.parentNode) {
			  do {
				valueT += element.offsetTop  || 0;
				valueL += element.offsetLeft || 0;
				element = element.offsetParent;
			  } while (element);
			}
			return new Element.Offset(valueL, valueT);
		})
  });

  Object.extend(Element.Layout, {
    PROPERTIES: $w('height width top left right bottom border-left border-right border-top border-bottom padding-left padding-right padding-top padding-bottom margin-top margin-bottom margin-left margin-right padding-box-width padding-box-height border-box-width border-box-height margin-box-width margin-box-height'),

    COMPOSITE_PROPERTIES: $w('padding-box-width padding-box-height margin-box-width margin-box-height border-box-width border-box-height'),

    COMPUTATIONS: {
      'height': function(element) {
        if (!this._preComputing) this._begin();

        var bHeight = this.get('border-box-height');
        if (bHeight <= 0) {
          if (!this._preComputing) this._end();
          return 0;
        }

        var bTop = this.get('border-top'),
         bBottom = this.get('border-bottom');

        var pTop = this.get('padding-top'),
         pBottom = this.get('padding-bottom');

        if (!this._preComputing) this._end();

        return bHeight - bTop - bBottom - pTop - pBottom;
      },

      'width': function(element) {
        if (!this._preComputing) this._begin();

        var bWidth = this.get('border-box-width');
        if (bWidth <= 0) {
          if (!this._preComputing) this._end();
          return 0;
        }

        var bLeft = this.get('border-left'),
         bRight = this.get('border-right');

        var pLeft = this.get('padding-left'),
         pRight = this.get('padding-right');

        if (!this._preComputing) this._end();

        return bWidth - bLeft - bRight - pLeft - pRight;
      },

      'padding-box-height': function(element) {
        var height = this.get('height'),
         pTop = this.get('padding-top'),
         pBottom = this.get('padding-bottom');

        return height + pTop + pBottom;
      },

      'padding-box-width': function(element) {
        var width = this.get('width'),
         pLeft = this.get('padding-left'),
         pRight = this.get('padding-right');

        return width + pLeft + pRight;
      },

      'border-box-height': function(element) {
        if (!this._preComputing) this._begin();
        var height = element.offsetHeight;
        if (!this._preComputing) this._end();
        return height;
      },

      'border-box-width': function(element) {
        if (!this._preComputing) this._begin();
        var width = element.offsetWidth;
        if (!this._preComputing) this._end();
        return width;
      },

      'margin-box-height': function(element) {
        var bHeight = this.get('border-box-height'),
         mTop = this.get('margin-top'),
         mBottom = this.get('margin-bottom');

        if (bHeight <= 0) return 0;

        return bHeight + mTop + mBottom;
      },

      'margin-box-width': function(element) {
        var bWidth = this.get('border-box-width'),
         mLeft = this.get('margin-left'),
         mRight = this.get('margin-right');

        if (bWidth <= 0) return 0;

        return bWidth + mLeft + mRight;
      },

      'top': function(element) {
        var offset = Element.positionedOffset(element);
        return offset.top;
      },

      'bottom': function(element) {
        var offset = Element.positionedOffset(element),
         parent = Element.getOffsetParent(element),
         pHeight = parent.measure('height');

        var mHeight = this.get('border-box-height');

        return pHeight - mHeight - offset.top;
      },

      'left': function(element) {
        var offset = Element.positionedOffset(element);
        return offset.left;
      },

      'right': function(element) {
        var offset = Element.positionedOffset(element),
         parent = Element.getOffsetParent(element),
         pWidth = parent.measure('width');

        var mWidth = this.get('border-box-width');

        return pWidth - mWidth - offset.left;
      },

      'padding-top': function(element) {
        return getPixelValue(element, 'paddingTop');
      },

      'padding-bottom': function(element) {
        return getPixelValue(element, 'paddingBottom');
      },

      'padding-left': function(element) {
        return getPixelValue(element, 'paddingLeft');
      },

      'padding-right': function(element) {
        return getPixelValue(element, 'paddingRight');
      },

      'border-top': function(element) {
        return getPixelValue(element, 'borderTopWidth');
      },

      'border-bottom': function(element) {
        return getPixelValue(element, 'borderBottomWidth');
      },

      'border-left': function(element) {
        return getPixelValue(element, 'borderLeftWidth');
      },

      'border-right': function(element) {
        return getPixelValue(element, 'borderRightWidth');
      },

      'margin-top': function(element) {
        return getPixelValue(element, 'marginTop');
      },

      'margin-bottom': function(element) {
        return getPixelValue(element, 'marginBottom');
      },

      'margin-left': function(element) {
        return getPixelValue(element, 'marginLeft');
      },

      'margin-right': function(element) {
        return getPixelValue(element, 'marginRight');
      }
    }
  });

  if ('getBoundingClientRect' in document.documentElement) {
    Object.extend(Element.Layout.COMPUTATIONS, {
      'right': function(element) {
        var parent = hasLayout(Element.getOffsetParent(element));
        var rect = Element.getBoundingClientRect(element),
         pRect = Element.getBoundingClientRect(parent);

        return (pRect.right - rect.right).round();
      },

      'bottom': function(element) {
        var parent = hasLayout(Element.getOffsetParent(element));
        var rect = Element.getBoundingClientRect(element),
         pRect = Element.getBoundingClientRect(parent);

        return (pRect.bottom - rect.bottom).round();
      }
    });
  }


  function isBody(element) {
    return element.nodeName.toUpperCase() === 'BODY';
  }

  function isHtml(element) {
    return element.nodeName.toUpperCase() === 'HTML';
  }

  function isDocument(element) {
    return element.nodeType === Node.DOCUMENT_NODE;
  }

  function isDetached(element) {
    return element !== document.body &&
     !Element.descendantOf(element, document.body);
  }

  if ('getBoundingClientRect' in document.documentElement) {
    Element.addMethods({
      viewportOffset: function(element) {
        element = $(element);
        if (isDetached(element)) return new Element.Offset(0, 0);

        var rect = Element.getBoundingClientRect(element),
         docEl = document.documentElement;
        return new Element.Offset(rect.left - docEl.clientLeft,
         rect.top - docEl.clientTop);
      }
    });
  }
})();


window.$$ = function() {
  var expression = $A(arguments).join(', ');
  return Prototype.Selector.select(expression, document);
};

Prototype.Selector = (function() {

  function select() {
    throw new Error('Method "Prototype.Selector.select" must be defined.');
  }

  function match() {
    throw new Error('Method "Prototype.Selector.match" must be defined.');
  }

  function find(elements, expression, index) {
    index = index || 0;
    var match = Prototype.Selector.match, length = elements.length, matchIndex = 0, i;

    for (i = 0; i < length; i++) {
      if (match(elements[i], expression) && index == matchIndex++) {
        return Element.extend(elements[i]);
      }
    }
  }

  function extendElements(elements) {
    for (var i = 0, length = elements.length; i < length; i++) {
      Element.extend(elements[i]);
    }
    return elements;
  }


  var K = Prototype.K;

  return {
    select: select,
    match: match,
    find: find,
    extendElements: (Element.extend === K) ? K : extendElements,
    extendElement: Element.extend
  };
})();

Prototype._original_property = window.Sizzle;
/*!
 * Sizzle CSS Selector Engine - v1.0
 *  Copyright 2009, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true;

[0, 0].sort(function(){
	baseHasDuplicate = false;
	return 0;
});

Sizzle = function(selector, context, results, seed) {
	results = results || [];
	var origContext = context = context || document;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var parts = [], m, set, checkSet, check, mode, extra, prune = true, contextXML = isXML(context),
		soFar = selector;

	while ( (chunker.exec(""), m = chunker.exec(soFar)) !== null ) {
		soFar = m[3];

		parts.push( m[1] );

		if ( m[2] ) {
			extra = m[3];
			break;
		}
	}

	if ( parts.length > 1 && origPOS.exec( selector ) ) {
		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );
		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] )
					selector += parts.shift();

				set = posProcess( selector, set );
			}
		}
	} else {
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
			var ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];
		}

		if ( context ) {
			var ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
			set = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray(set);
			} else {
				prune = false;
			}

			while ( parts.length ) {
				var cur = parts.pop(), pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}
		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		throw "Syntax error, unrecognized expression: " + (cur || selector);
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );
		} else if ( context && context.nodeType === 1 ) {
			for ( var i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}
		} else {
			for ( var i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}
	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function(results){
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort(sortOrder);

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[i-1] ) {
					results.splice(i--, 1);
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function(expr, set){
	return Sizzle(expr, null, null, set);
};

Sizzle.find = function(expr, context, isXML){
	var set, match;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var type = Expr.order[i], match;

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice(1,1);

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace(/\\/g, "");
				set = Expr.find[ type ]( match, context, isXML );
				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = context.getElementsByTagName("*");
	}

	return {set: set, expr: expr};
};

Sizzle.filter = function(expr, set, inplace, not){
	var old = expr, result = [], curLoop = set, match, anyFound,
		isXMLFilter = set && set[0] && isXML(set[0]);

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.match[ type ].exec( expr )) != null ) {
				var filter = Expr.filter[ type ], found, item;
				anyFound = false;

				if ( curLoop == result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;
					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;
								} else {
									curLoop[i] = false;
								}
							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		if ( expr == old ) {
			if ( anyFound == null ) {
				throw "Syntax error, unrecognized expression: " + expr;
			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],
	match: {
		ID: /#((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF-]|\\.)+)(?:\((['"]*)((?:\([^\)]+\)|[^\2\(\)]*)+)\2\))?/
	},
	leftMatch: {},
	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},
	attrHandle: {
		href: function(elem){
			return elem.getAttribute("href");
		}
	},
	relative: {
		"+": function(checkSet, part, isXML){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !/\W/.test(part),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag && !isXML ) {
				part = part.toUpperCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},
		">": function(checkSet, part, isXML){
			var isPartStr = typeof part === "string";

			if ( isPartStr && !/\W/.test(part) ) {
				part = isXML ? part : part.toUpperCase();

				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
					var elem = checkSet[i];
					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName === part ? parent : false;
					}
				}
			} else {
				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
					var elem = checkSet[i];
					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},
		"": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck;

			if ( !/\W/.test(part) ) {
				var nodeCheck = part = isXML ? part : part.toUpperCase();
				checkFn = dirNodeCheck;
			}

			checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
		},
		"~": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck;

			if ( typeof part === "string" && !/\W/.test(part) ) {
				var nodeCheck = part = isXML ? part : part.toUpperCase();
				checkFn = dirNodeCheck;
			}

			checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
		}
	},
	find: {
		ID: function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ? [m] : [];
			}
		},
		NAME: function(match, context, isXML){
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [], results = context.getElementsByName(match[1]);

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},
		TAG: function(match, context){
			return context.getElementsByTagName(match[1]);
		}
	},
	preFilter: {
		CLASS: function(match, curLoop, inplace, result, not, isXML){
			match = " " + match[1].replace(/\\/g, "") + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").indexOf(match) >= 0) ) {
						if ( !inplace )
							result.push( elem );
					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},
		ID: function(match){
			return match[1].replace(/\\/g, "");
		},
		TAG: function(match, curLoop){
			for ( var i = 0; curLoop[i] === false; i++ ){}
			return curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();
		},
		CHILD: function(match){
			if ( match[1] == "nth" ) {
				var test = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(
					match[2] == "even" && "2n" || match[2] == "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}

			match[0] = done++;

			return match;
		},
		ATTR: function(match, curLoop, inplace, result, not, isXML){
			var name = match[1].replace(/\\/g, "");

			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},
		PSEUDO: function(match, curLoop, inplace, result, not){
			if ( match[1] === "not" ) {
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);
				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
					if ( !inplace ) {
						result.push.apply( result, ret );
					}
					return false;
				}
			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},
		POS: function(match){
			match.unshift( true );
			return match;
		}
	},
	filters: {
		enabled: function(elem){
			return elem.disabled === false && elem.type !== "hidden";
		},
		disabled: function(elem){
			return elem.disabled === true;
		},
		checked: function(elem){
			return elem.checked === true;
		},
		selected: function(elem){
			elem.parentNode.selectedIndex;
			return elem.selected === true;
		},
		parent: function(elem){
			return !!elem.firstChild;
		},
		empty: function(elem){
			return !elem.firstChild;
		},
		has: function(elem, i, match){
			return !!Sizzle( match[3], elem ).length;
		},
		header: function(elem){
			return /h\d/i.test( elem.nodeName );
		},
		text: function(elem){
			return "text" === elem.type;
		},
		radio: function(elem){
			return "radio" === elem.type;
		},
		checkbox: function(elem){
			return "checkbox" === elem.type;
		},
		file: function(elem){
			return "file" === elem.type;
		},
		password: function(elem){
			return "password" === elem.type;
		},
		submit: function(elem){
			return "submit" === elem.type;
		},
		image: function(elem){
			return "image" === elem.type;
		},
		reset: function(elem){
			return "reset" === elem.type;
		},
		button: function(elem){
			return "button" === elem.type || elem.nodeName.toUpperCase() === "BUTTON";
		},
		input: function(elem){
			return /input|select|textarea|button/i.test(elem.nodeName);
		}
	},
	setFilters: {
		first: function(elem, i){
			return i === 0;
		},
		last: function(elem, i, match, array){
			return i === array.length - 1;
		},
		even: function(elem, i){
			return i % 2 === 0;
		},
		odd: function(elem, i){
			return i % 2 === 1;
		},
		lt: function(elem, i, match){
			return i < match[3] - 0;
		},
		gt: function(elem, i, match){
			return i > match[3] - 0;
		},
		nth: function(elem, i, match){
			return match[3] - 0 == i;
		},
		eq: function(elem, i, match){
			return match[3] - 0 == i;
		}
	},
	filter: {
		PSEUDO: function(elem, match, i, array){
			var name = match[1], filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || "").indexOf(match[3]) >= 0;
			} else if ( name === "not" ) {
				var not = match[3];

				for ( var i = 0, l = not.length; i < l; i++ ) {
					if ( not[i] === elem ) {
						return false;
					}
				}

				return true;
			}
		},
		CHILD: function(elem, match){
			var type = match[1], node = elem;
			switch (type) {
				case 'only':
				case 'first':
					while ( (node = node.previousSibling) )  {
						if ( node.nodeType === 1 ) return false;
					}
					if ( type == 'first') return true;
					node = elem;
				case 'last':
					while ( (node = node.nextSibling) )  {
						if ( node.nodeType === 1 ) return false;
					}
					return true;
				case 'nth':
					var first = match[2], last = match[3];

					if ( first == 1 && last == 0 ) {
						return true;
					}

					var doneName = match[0],
						parent = elem.parentNode;

					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}
						parent.sizcache = doneName;
					}

					var diff = elem.nodeIndex - last;
					if ( first == 0 ) {
						return diff == 0;
					} else {
						return ( diff % first == 0 && diff / first >= 0 );
					}
			}
		},
		ID: function(elem, match){
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},
		TAG: function(elem, match){
			return (match === "*" && elem.nodeType === 1) || elem.nodeName === match;
		},
		CLASS: function(elem, match){
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},
		ATTR: function(elem, match){
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value != check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},
		POS: function(elem, match, i, array){
			var name = match[2], filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS;

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\[]*\])(?![^\(]*\))/.source );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source );
}

var makeArray = function(array, results) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}

	return array;
};

try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 );

} catch(e){
	makeArray = function(array, results) {
		var ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );
		} else {
			if ( typeof array.length === "number" ) {
				for ( var i = 0, l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}
			} else {
				for ( var i = 0; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			if ( a == b ) {
				hasDuplicate = true;
			}
			return 0;
		}

		var ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
} else if ( "sourceIndex" in document.documentElement ) {
	sortOrder = function( a, b ) {
		if ( !a.sourceIndex || !b.sourceIndex ) {
			if ( a == b ) {
				hasDuplicate = true;
			}
			return 0;
		}

		var ret = a.sourceIndex - b.sourceIndex;
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
} else if ( document.createRange ) {
	sortOrder = function( a, b ) {
		if ( !a.ownerDocument || !b.ownerDocument ) {
			if ( a == b ) {
				hasDuplicate = true;
			}
			return 0;
		}

		var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();
		aRange.setStart(a, 0);
		aRange.setEnd(a, 0);
		bRange.setStart(b, 0);
		bRange.setEnd(b, 0);
		var ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);
		if ( ret === 0 ) {
			hasDuplicate = true;
		}
		return ret;
	};
}

(function(){
	var form = document.createElement("div"),
		id = "script" + (new Date).getTime();
	form.innerHTML = "<a name='" + id + "'/>";

	var root = document.documentElement;
	root.insertBefore( form, root.firstChild );

	if ( !!document.getElementById( id ) ) {
		Expr.find.ID = function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];
			}
		};

		Expr.filter.ID = function(elem, match){
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );
	root = form = null; // release memory in IE
})();

(function(){

	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function(match, context){
			var results = context.getElementsByTagName(match[1]);

			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	div.innerHTML = "<a href='#'></a>";
	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {
		Expr.attrHandle.href = function(elem){
			return elem.getAttribute("href", 2);
		};
	}

	div = null; // release memory in IE
})();

if ( document.querySelectorAll ) (function(){
	var oldSizzle = Sizzle, div = document.createElement("div");
	div.innerHTML = "<p class='TEST'></p>";

	if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
		return;
	}

	Sizzle = function(query, context, extra, seed){
		context = context || document;

		if ( !seed && context.nodeType === 9 && !isXML(context) ) {
			try {
				return makeArray( context.querySelectorAll(query), extra );
			} catch(e){}
		}

		return oldSizzle(query, context, extra, seed);
	};

	for ( var prop in oldSizzle ) {
		Sizzle[ prop ] = oldSizzle[ prop ];
	}

	div = null; // release memory in IE
})();

if ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) (function(){
	var div = document.createElement("div");
	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	if ( div.getElementsByClassName("e").length === 0 )
		return;

	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 )
		return;

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function(match, context, isXML) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	div = null; // release memory in IE
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	var sibDir = dir == "previousSibling" && !isXML;
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			if ( sibDir && elem.nodeType === 1 ){
				elem.sizcache = doneName;
				elem.sizset = i;
			}
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	var sibDir = dir == "previousSibling" && !isXML;
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			if ( sibDir && elem.nodeType === 1 ) {
				elem.sizcache = doneName;
				elem.sizset = i;
			}
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}
					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

var contains = document.compareDocumentPosition ?  function(a, b){
	return a.compareDocumentPosition(b) & 16;
} : function(a, b){
	return a !== b && (a.contains ? a.contains(b) : true);
};

var isXML = function(elem){
	return elem.nodeType === 9 && elem.documentElement.nodeName !== "HTML" ||
		!!elem.ownerDocument && elem.ownerDocument.documentElement.nodeName !== "HTML";
};

var posProcess = function(selector, context){
	var tmpSet = [], later = "", match,
		root = context.nodeType ? [context] : context;

	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};


window.Sizzle = Sizzle;

})();

(function(engine) {
  var extendElements = Prototype.Selector.extendElements;

  function select(selector, scope) {
    return extendElements(engine(selector, scope || document));
  }

  function match(element, selector) {
    return engine.matches(selector, [element]).length == 1;
  }

  Prototype.Selector.engine = engine;
  Prototype.Selector.select = select;
  Prototype.Selector.match = match;
})(Sizzle);

window.Sizzle = Prototype._original_property;
delete Prototype._original_property;


/*--------------------------------------------------------------------------*/


(function() {

  Event = {
    KEY_BACKSPACE: 8,
    KEY_TAB:       9,
    KEY_RETURN:   13,
    KEY_ESC:      27,
    KEY_LEFT:     37,
    KEY_UP:       38,
    KEY_RIGHT:    39,
    KEY_DOWN:     40,
    KEY_DELETE:   46,
    KEY_HOME:     36,
    KEY_END:      35,
    KEY_PAGEUP:   33,
    KEY_PAGEDOWN: 34,
    KEY_INSERT:   45,

    cache: {}
  };

  var docEl = document.documentElement;
  var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl
    && 'onmouseleave' in docEl;



  var isIELegacyEvent = function(event) { return false; };

  if (window.attachEvent) {
    if (window.addEventListener) {
      isIELegacyEvent = function(event) {
        return !(event instanceof window.Event);
      };
    } else {
      isIELegacyEvent = function(event) { return true; };
    }
  }

  var _isButton;

  function _isButtonForDOMEvents(event, code) {
    return event.which ? (event.which === code + 1) : (event.button === code);
  }

  var legacyButtonMap = { 0: 1, 1: 4, 2: 2 };
  function _isButtonForLegacyEvents(event, code) {
    return event.button === legacyButtonMap[code];
  }

  function _isButtonForWebKit(event, code) {
    switch (code) {
      case 0: return event.which == 1 && !event.metaKey;
      case 1: return event.which == 2 || (event.which == 1 && event.metaKey);
      case 2: return event.which == 3;
      default: return false;
    }
  }

  if (window.attachEvent) {
    if (!window.addEventListener) {
      _isButton = _isButtonForLegacyEvents;
    } else {
      _isButton = function(event, code) {
        return isIELegacyEvent(event) ? _isButtonForLegacyEvents(event, code) :
         _isButtonForDOMEvents(event, code);
      }
    }
  } else if (Prototype.Browser.WebKit) {
    _isButton = _isButtonForWebKit;
  } else {
    _isButton = _isButtonForDOMEvents;
  }

  function isLeftClick(event)   { return _isButton(event, 0) }

  function isMiddleClick(event) { return _isButton(event, 1) }

  function isRightClick(event)  { return _isButton(event, 2) }

  function element(event) {
    event = Event.extend(event);

    var node = event.target, type = event.type,
     currentTarget = event.currentTarget;

    if (currentTarget && currentTarget.tagName) {
      if (type === 'load' || type === 'error' ||
        (type === 'click' && currentTarget.tagName.toLowerCase() === 'input'
          && currentTarget.type === 'radio'))
            node = currentTarget;
    }

    if (node.nodeType == Node.TEXT_NODE)
      node = node.parentNode;

    return Element.extend(node);
  }

  function findElement(event, expression) {
    var element = Event.element(event);

    if (!expression) return element;
    while (element) {
      if (Object.isElement(element) && Prototype.Selector.match(element, expression)) {
        return Element.extend(element);
      }
      element = element.parentNode;
    }
  }

  function pointer(event) {
    return { x: pointerX(event), y: pointerY(event) };
  }

  function pointerX(event) {
    var docElement = document.documentElement,
     body = document.body || { scrollLeft: 0 };

    return event.pageX || (event.clientX +
      (docElement.scrollLeft || body.scrollLeft) -
      (docElement.clientLeft || 0));
  }

  function pointerY(event) {
    var docElement = document.documentElement,
     body = document.body || { scrollTop: 0 };

    return  event.pageY || (event.clientY +
       (docElement.scrollTop || body.scrollTop) -
       (docElement.clientTop || 0));
  }


  function stop(event) {
    Event.extend(event);
    event.preventDefault();
    event.stopPropagation();

    event.stopped = true;
  }


  Event.Methods = {
    isLeftClick:   isLeftClick,
    isMiddleClick: isMiddleClick,
    isRightClick:  isRightClick,

    element:     element,
    findElement: findElement,

    pointer:  pointer,
    pointerX: pointerX,
    pointerY: pointerY,

    stop: stop
  };

  var methods = Object.keys(Event.Methods).inject({ }, function(m, name) {
    m[name] = Event.Methods[name].methodize();
    return m;
  });

  if (window.attachEvent) {
    function _relatedTarget(event) {
      var element;
      switch (event.type) {
        case 'mouseover':
        case 'mouseenter':
          element = event.fromElement;
          break;
        case 'mouseout':
        case 'mouseleave':
          element = event.toElement;
          break;
        default:
          return null;
      }
      return Element.extend(element);
    }

    var additionalMethods = {
      stopPropagation: function() { this.cancelBubble = true },
      preventDefault:  function() { this.returnValue = false },
      inspect: function() { return '[object Event]' }
    };

    Event.extend = function(event, element) {
      if (!event) return false;

      if (!isIELegacyEvent(event)) return event;

      if (event._extendedByPrototype) return event;
      event._extendedByPrototype = Prototype.emptyFunction;

      var pointer = Event.pointer(event);

      Object.extend(event, {
        target: event.srcElement || element,
        relatedTarget: _relatedTarget(event),
        pageX:  pointer.x,
        pageY:  pointer.y
      });

      Object.extend(event, methods);
      Object.extend(event, additionalMethods);

      return event;
    };
  } else {
    Event.extend = Prototype.K;
  }

  if (window.addEventListener) {
    Event.prototype = window.Event.prototype || document.createEvent('HTMLEvents').__proto__;
    Object.extend(Event.prototype, methods);
  }

  function _createResponder(element, eventName, handler) {
    var registry = Element.retrieve(element, 'prototype_event_registry');

    if (Object.isUndefined(registry)) {
      CACHE.push(element);
      registry = Element.retrieve(element, 'prototype_event_registry', $H());
    }

    var respondersForEvent = registry.get(eventName);
    if (Object.isUndefined(respondersForEvent)) {
      respondersForEvent = [];
      registry.set(eventName, respondersForEvent);
    }

    if (respondersForEvent.pluck('handler').include(handler)) return false;

    var responder;
    if (eventName.include(":")) {
      responder = function(event) {
        if (Object.isUndefined(event.eventName))
          return false;

        if (event.eventName !== eventName)
          return false;

        Event.extend(event, element);
        handler.call(element, event);
      };
    } else {
      if (!MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED &&
       (eventName === "mouseenter" || eventName === "mouseleave")) {
        if (eventName === "mouseenter" || eventName === "mouseleave") {
          responder = function(event) {
            Event.extend(event, element);

            var parent = event.relatedTarget;
            while (parent && parent !== element) {
              try { parent = parent.parentNode; }
              catch(e) { parent = element; }
            }

            if (parent === element) return;

            handler.call(element, event);
          };
        }
      } else {
        responder = function(event) {
          Event.extend(event, element);
          handler.call(element, event);
        };
      }
    }

    responder.handler = handler;
    respondersForEvent.push(responder);
    return responder;
  }

  function _destroyCache() {
    for (var i = 0, length = CACHE.length; i < length; i++) {
      Event.stopObserving(CACHE[i]);
      CACHE[i] = null;
    }
  }

  var CACHE = [];

  if (Prototype.Browser.IE)
    window.attachEvent('onunload', _destroyCache);

  if (Prototype.Browser.WebKit)
    window.addEventListener('unload', Prototype.emptyFunction, false);


  var _getDOMEventName = Prototype.K,
      translations = { mouseenter: "mouseover", mouseleave: "mouseout" };

  if (!MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED) {
    _getDOMEventName = function(eventName) {
      return (translations[eventName] || eventName);
    };
  }

  function observe(element, eventName, handler) {
    element = $(element);

    var responder = _createResponder(element, eventName, handler);

    if (!responder) return element;

    if (eventName.include(':')) {
      if (element.addEventListener)
        element.addEventListener("dataavailable", responder, false);
      else {
        element.attachEvent("ondataavailable", responder);
        element.attachEvent("onlosecapture", responder);
      }
    } else {
      var actualEventName = _getDOMEventName(eventName);

      if (element.addEventListener)
        element.addEventListener(actualEventName, responder, false);
      else
        element.attachEvent("on" + actualEventName, responder);
    }

    return element;
  }

  function stopObserving(element, eventName, handler) {
    element = $(element);

    var registry = Element.retrieve(element, 'prototype_event_registry');
    if (!registry) return element;

    if (!eventName) {
      registry.each( function(pair) {
        var eventName = pair.key;
        stopObserving(element, eventName);
      });
      return element;
    }

    var responders = registry.get(eventName);
    if (!responders) return element;

    if (!handler) {
      responders.each(function(r) {
        stopObserving(element, eventName, r.handler);
      });
      return element;
    }

    var i = responders.length, responder;
    while (i--) {
      if (responders[i].handler === handler) {
        responder = responders[i];
        break;
      }
    }
    if (!responder) return element;

    if (eventName.include(':')) {
      if (element.removeEventListener)
        element.removeEventListener("dataavailable", responder, false);
      else {
        element.detachEvent("ondataavailable", responder);
        element.detachEvent("onlosecapture", responder);
      }
    } else {
      var actualEventName = _getDOMEventName(eventName);
      if (element.removeEventListener)
        element.removeEventListener(actualEventName, responder, false);
      else
        element.detachEvent('on' + actualEventName, responder);
    }

    registry.set(eventName, responders.without(responder));

    return element;
  }

  function fire(element, eventName, memo, bubble) {
    element = $(element);

    if (Object.isUndefined(bubble))
      bubble = true;

    if (element == document && document.createEvent && !element.dispatchEvent)
      element = document.documentElement;

    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent('dataavailable', bubble, true);
    } else {
      event = document.createEventObject();
      event.eventType = bubble ? 'ondataavailable' : 'onlosecapture';
    }

    event.eventName = eventName;
    event.memo = memo || { };

    if (document.createEvent)
      element.dispatchEvent(event);
    else
      element.fireEvent(event.eventType, event);

    return Event.extend(event);
  }

  Event.Handler = Class.create({
    initialize: function(element, eventName, selector, callback) {
      this.element   = $(element);
      this.eventName = eventName;
      this.selector  = selector;
      this.callback  = callback;
      this.handler   = this.handleEvent.bind(this);
    },

    start: function() {
      Event.observe(this.element, this.eventName, this.handler);
      return this;
    },

    stop: function() {
      Event.stopObserving(this.element, this.eventName, this.handler);
      return this;
    },

    handleEvent: function(event) {
      var element = Event.findElement(event, this.selector);
      if (element) this.callback.call(this.element, event, element);
    }
  });

  function on(element, eventName, selector, callback) {
    element = $(element);
    if (Object.isFunction(selector) && Object.isUndefined(callback)) {
      callback = selector, selector = null;
    }

    return new Event.Handler(element, eventName, selector, callback).start();
  }

  Object.extend(Event, Event.Methods);

  Object.extend(Event, {
    fire:          fire,
    observe:       observe,
    stopObserving: stopObserving,
    on:            on
  });

  Element.addMethods({
    fire:          fire,

    observe:       observe,

    stopObserving: stopObserving,

    on:            on
  });

  Object.extend(document, {
    fire:          fire.methodize(),

    observe:       observe.methodize(),

    stopObserving: stopObserving.methodize(),

    on:            on.methodize(),

    loaded:        false
  });

  if (window.Event) Object.extend(window.Event, Event);
  else window.Event = Event;
})();

(function() {
  /* Support for the DOMContentLoaded event is based on work by Dan Webb,
     Matthias Miller, Dean Edwards, John Resig, and Diego Perini. */

  var timer;

  function fireContentLoadedEvent() {
    if (document.loaded) return;
    if (timer) window.clearTimeout(timer);
    document.loaded = true;
    document.fire('dom:loaded');
  }

  function checkReadyState() {
    if (document.readyState === 'complete') {
      document.stopObserving('readystatechange', checkReadyState);
      fireContentLoadedEvent();
    }
  }

  function pollDoScroll() {
    try { document.documentElement.doScroll('left'); }
    catch(e) {
      timer = pollDoScroll.defer();
      return;
    }
    fireContentLoadedEvent();
  }

  if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
  } else {
    document.observe('readystatechange', checkReadyState);
    if (window == top)
      timer = pollDoScroll.defer();
  }

  Event.observe(window, 'load', fireContentLoadedEvent);
})();


/*
  Add Form Methods in FORM window classes
  Dont Work in GreaseMonkey (Firefox)
*/
Element.addMethods(); 


// script.aculo.us scriptaculous.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010

// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
//
// INCLUDE: builder, effects, dragdrop, controls, slider, sound

var Builder = {
  NODEMAP: {
    AREA: 'map',
    CAPTION: 'table',
    COL: 'table',
    COLGROUP: 'table',
    LEGEND: 'fieldset',
    OPTGROUP: 'select',
    OPTION: 'select',
    PARAM: 'object',
    TBODY: 'table',
    TD: 'table',
    TFOOT: 'table',
    TH: 'table',
    THEAD: 'table',
    TR: 'table'
  },
  // note: For Firefox < 1.5, OPTION and OPTGROUP tags are currently broken,
  //       due to a Firefox bug
  node: function(elementName) {
    elementName = elementName.toUpperCase();

    // try innerHTML approach
    var parentTag = this.NODEMAP[elementName] || 'div';
    var parentElement = document.createElement(parentTag);
    try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707
      parentElement.innerHTML = "<" + elementName + "></" + elementName + ">";
    } catch(e) {}
    var element = parentElement.firstChild || null;

    // see if browser added wrapping tags
    if(element && (element.tagName.toUpperCase() != elementName))
      element = element.getElementsByTagName(elementName)[0];

    // fallback to createElement approach
    if(!element) element = document.createElement(elementName);

    // abort if nothing could be created
    if(!element) return;

    // attributes (or text)
    if(arguments[1])
      if(this._isStringOrNumber(arguments[1]) ||
        (arguments[1] instanceof Array) ||
        arguments[1].tagName) {
          this._children(element, arguments[1]);
        } else {
          var attrs = this._attributes(arguments[1]);
          if(attrs.length) {
            try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707
              parentElement.innerHTML = "<" +elementName + " " +
                attrs + "></" + elementName + ">";
            } catch(e) {}
            element = parentElement.firstChild || null;
            // workaround firefox 1.0.X bug
            if(!element) {
              element = document.createElement(elementName);
              for(attr in arguments[1])
                element[attr == 'class' ? 'className' : attr] = arguments[1][attr];
            }
            if(element.tagName.toUpperCase() != elementName)
              element = parentElement.getElementsByTagName(elementName)[0];
          }
        }

    // text, or array of children
    if(arguments[2])
      this._children(element, arguments[2]);

     return $(element);
  },
  _text: function(text) {
     return document.createTextNode(text);
  },

  ATTR_MAP: {
    'className': 'class',
    'htmlFor': 'for'
  },

  _attributes: function(attributes) {
    var attrs = [];
    for(attribute in attributes)
      attrs.push((attribute in this.ATTR_MAP ? this.ATTR_MAP[attribute] : attribute) +
          '="' + attributes[attribute].toString().escapeHTML().gsub(/"/,'&quot;') + '"');
    return attrs.join(" ");
  },
  _children: function(element, children) {
    if(children.tagName) {
      element.appendChild(children);
      return;
    }
    if(typeof children=='object') { // array can hold nodes and text
      children.flatten().each( function(e) {
        if(typeof e=='object')
          element.appendChild(e);
        else
          if(Builder._isStringOrNumber(e))
            element.appendChild(Builder._text(e));
      });
    } else
      if(Builder._isStringOrNumber(children))
        element.appendChild(Builder._text(children));
  },
  _isStringOrNumber: function(param) {
    return(typeof param=='string' || typeof param=='number');
  },
  build: function(html) {
    var element = this.node('div');
    Element.update($(element),html.strip());
    return Element.down(element);
  },
  dump: function(scope) {
    if(typeof scope != 'object' && typeof scope != 'function') scope = window; //global scope

    var tags = ("A ABBR ACRONYM ADDRESS APPLET AREA B BASE BASEFONT BDO BIG BLOCKQUOTE BODY " +
      "BR BUTTON CAPTION CENTER CITE CODE COL COLGROUP DD DEL DFN DIR DIV DL DT EM FIELDSET " +
      "FONT FORM FRAME FRAMESET H1 H2 H3 H4 H5 H6 HEAD HR HTML I IFRAME IMG INPUT INS ISINDEX "+
      "KBD LABEL LEGEND LI LINK MAP MENU META NOFRAMES NOSCRIPT OBJECT OL OPTGROUP OPTION P "+
      "PARAM PRE Q S SAMP SCRIPT SELECT SMALL SPAN STRIKE STRONG STYLE SUB SUP TABLE TBODY TD "+
      "TEXTAREA TFOOT TH THEAD TITLE TR TT U UL VAR").split(/\s+/);

    tags.each( function(tag){
      scope[tag] = function() {
        return Builder.node.apply(Builder, [tag].concat($A(arguments)));
      };
    });
  }
};

String.prototype.parseColor = function() {
  var color = '#';
  if (this.slice(0,4) == 'rgb(') {
    var cols = this.slice(4,this.length-1).split(',');
    var i=0; do { color += parseInt(cols[i]).toColorPart() } while (++i<3);
  } else {
    if (this.slice(0,1) == '#') {
      if (this.length==4) for(var i=1;i<4;i++) color += (this.charAt(i) + this.charAt(i)).toLowerCase();
      if (this.length==7) color = this.toLowerCase();
    }
  }
  return (color.length==7 ? color : (arguments[0] || this));
};

/*--------------------------------------------------------------------------*/

Element.collectTextNodes = function(element) {
  return $A($(element).childNodes).collect( function(node) {
    return (node.nodeType==3 ? node.nodeValue :
      (node.hasChildNodes() ? Element.collectTextNodes(node) : ''));
  }).flatten().join('');
};

Element.collectTextNodesIgnoreClass = function(element, className) {
  return $A($(element).childNodes).collect( function(node) {
    return (node.nodeType==3 ? node.nodeValue :
      ((node.hasChildNodes() && !Element.hasClassName(node,className)) ?
        Element.collectTextNodesIgnoreClass(node, className) : ''));
  }).flatten().join('');
};

Element.setContentZoom = function(element, percent) {
  element = $(element);
  Element.setStyle(element,{fontSize: (percent/100) + 'em'});
  if (Prototype.Browser.WebKit) window.scrollBy(0,0);
  return element;
};

Element.getInlineOpacity = function(element){
  return $(element).style.opacity || '';
};

Element.forceRerendering = function(element) {
  try {
    element = $(element);
    var n = document.createTextNode(' ');
    element.appendChild(n);
    element.removeChild(n);
  } catch(e) { }
};

/*--------------------------------------------------------------------------*/

var Effect = {
  _elementDoesNotExistError: {
    name: 'ElementDoesNotExistError',
    message: 'The specified DOM element does not exist, but is required for this effect to operate'
  },
  Transitions: {
    linear: Prototype.K,
    sinoidal: function(pos) {
      return (-Math.cos(pos*Math.PI)/2) + .5;
    },
    reverse: function(pos) {
      return 1-pos;
    },
    flicker: function(pos) {
      var pos = ((-Math.cos(pos*Math.PI)/4) + .75) + Math.random()/4;
      return pos > 1 ? 1 : pos;
    },
    wobble: function(pos) {
      return (-Math.cos(pos*Math.PI*(9*pos))/2) + .5;
    },
    pulse: function(pos, pulses) {
      return (-Math.cos((pos*((pulses||5)-.5)*2)*Math.PI)/2) + .5;
    },
    spring: function(pos) {
      return 1 - (Math.cos(pos * 4.5 * Math.PI) * Math.exp(-pos * 6));
    },
    none: function(pos) {
      return 0;
    },
    full: function(pos) {
      return 1;
    }
  },
  DefaultOptions: {
    duration:   1.0,   // seconds
    fps:        100,   // 100= assume 66fps max.
    sync:       false, // true for combining
    from:       0.0,
    to:         1.0,
    delay:      0.0,
    queue:      'parallel'
  },
  tagifyText: function(element) {
    var tagifyStyle = 'position:relative';
    if (Prototype.Browser.IE) tagifyStyle += ';zoom:1';

    element = $(element);
    $A(element.childNodes).each( function(child) {
      if (child.nodeType==3) {
        child.nodeValue.toArray().each( function(character) {
          element.insertBefore(
            new Element('span', {style: tagifyStyle}).update(
              character == ' ' ? String.fromCharCode(160) : character),
              child);
        });
        Element.remove(child);
      }
    });
  },
  multiple: function(element, effect) {
    var elements;
    if (((typeof element == 'object') ||
        Object.isFunction(element)) &&
       (element.length))
      elements = element;
    else
      elements = $(element).childNodes;

    var options = Object.extend({
      speed: 0.1,
      delay: 0.0
    }, arguments[2] || { });
    var masterDelay = options.delay;

    $A(elements).each( function(element, index) {
      new effect(element, Object.extend(options, { delay: index * options.speed + masterDelay }));
    });
  },
  PAIRS: {
    'slide':  ['SlideDown','SlideUp'],
    'blind':  ['BlindDown','BlindUp'],
    'appear': ['Appear','Fade']
  },
  toggle: function(element, effect, options) {
    element = $(element);
    effect  = (effect || 'appear').toLowerCase();
    
    return Effect[ Effect.PAIRS[ effect ][ element.visible() ? 1 : 0 ] ](element, Object.extend({
      queue: { position:'end', scope:(element.id || 'global'), limit: 1 }
    }, options || {}));
  }
};

Effect.DefaultOptions.transition = Effect.Transitions.sinoidal;

/* ------------- core effects ------------- */

Effect.ScopedQueue = Class.create(Enumerable, {
  initialize: function() {
    this.effects  = [];
    this.interval = null;
  },
  _each: function(iterator) {
    this.effects._each(iterator);
  },
  add: function(effect) {
    var timestamp = new Date().getTime();

    var position = Object.isString(effect.options.queue) ?
      effect.options.queue : effect.options.queue.position;

    switch(position) {
      case 'front':
        // move unstarted effects after this effect
        this.effects.findAll(function(e){ return e.state=='idle' }).each( function(e) {
            e.startOn  += effect.finishOn;
            e.finishOn += effect.finishOn;
          });
        break;
      case 'with-last':
        timestamp = this.effects.pluck('startOn').max() || timestamp;
        break;
      case 'end':
        // start effect after last queued effect has finished
        timestamp = this.effects.pluck('finishOn').max() || timestamp;
        break;
    }

    effect.startOn  += timestamp;
    effect.finishOn += timestamp;

    if (!effect.options.queue.limit || (this.effects.length < effect.options.queue.limit))
      this.effects.push(effect);

    if (!this.interval)
      this.interval = setInterval(this.loop.bind(this), 15);
  },
  remove: function(effect) {
    this.effects = this.effects.reject(function(e) { return e==effect });
    if (this.effects.length == 0) {
      clearInterval(this.interval);
      this.interval = null;
    }
  },
  loop: function() {
    var timePos = new Date().getTime();
    for(var i=0, len=this.effects.length;i<len;i++)
      this.effects[i] && this.effects[i].loop(timePos);
  }
});

Effect.Queues = {
  instances: $H(),
  get: function(queueName) {
    if (!Object.isString(queueName)) return queueName;

    return this.instances.get(queueName) ||
      this.instances.set(queueName, new Effect.ScopedQueue());
  }
};
Effect.Queue = Effect.Queues.get('global');

Effect.Base = Class.create({
  position: null,
  start: function(options) {
    if (options && options.transition === false) options.transition = Effect.Transitions.linear;
    this.options      = Object.extend(Object.extend({ },Effect.DefaultOptions), options || { });
    this.currentFrame = 0;
    this.state        = 'idle';
    this.startOn      = this.options.delay*1000;
    this.finishOn     = this.startOn+(this.options.duration*1000);
    this.fromToDelta  = this.options.to-this.options.from;
    this.totalTime    = this.finishOn-this.startOn;
    this.totalFrames  = this.options.fps*this.options.duration;

    this.render = (function() {
      function dispatch(effect, eventName) {
        if (effect.options[eventName + 'Internal'])
          effect.options[eventName + 'Internal'](effect);
        if (effect.options[eventName])
          effect.options[eventName](effect);
      }

      return function(pos) {
        if (this.state === "idle") {
          this.state = "running";
          dispatch(this, 'beforeSetup');
          if (this.setup) this.setup();
          dispatch(this, 'afterSetup');
        }
        if (this.state === "running") {
          pos = (this.options.transition(pos) * this.fromToDelta) + this.options.from;
          this.position = pos;
          dispatch(this, 'beforeUpdate');
          if (this.update) this.update(pos);
          dispatch(this, 'afterUpdate');
        }
      };
    })();

    this.event('beforeStart');
    if (!this.options.sync)
      Effect.Queues.get(Object.isString(this.options.queue) ?
        'global' : this.options.queue.scope).add(this);
  },
  loop: function(timePos) {
    if (timePos >= this.startOn) {
      if (timePos >= this.finishOn) {
        this.render(1.0);
        this.cancel();
        this.event('beforeFinish');
        if (this.finish) this.finish();
        this.event('afterFinish');
        return;
      }
      var pos   = (timePos - this.startOn) / this.totalTime,
          frame = (pos * this.totalFrames).round();
      if (frame > this.currentFrame) {
        this.render(pos);
        this.currentFrame = frame;
      }
    }
  },
  cancel: function() {
    if (!this.options.sync)
      Effect.Queues.get(Object.isString(this.options.queue) ?
        'global' : this.options.queue.scope).remove(this);
    this.state = 'finished';
  },
  event: function(eventName) {
    if (this.options[eventName + 'Internal']) this.options[eventName + 'Internal'](this);
    if (this.options[eventName]) this.options[eventName](this);
  },
  inspect: function() {
    var data = $H();
    for(property in this)
      if (!Object.isFunction(this[property])) data.set(property, this[property]);
    return '#<Effect:' + data.inspect() + ',options:' + $H(this.options).inspect() + '>';
  }
});

Effect.Parallel = Class.create(Effect.Base, {
  initialize: function(effects) {
    this.effects = effects || [];
    this.start(arguments[1]);
  },
  update: function(position) {
    this.effects.invoke('render', position);
  },
  finish: function(position) {
    this.effects.each( function(effect) {
      effect.render(1.0);
      effect.cancel();
      effect.event('beforeFinish');
      if (effect.finish) effect.finish(position);
      effect.event('afterFinish');
    });
  }
});

Effect.Tween = Class.create(Effect.Base, {
  initialize: function(object, from, to) {
    object = Object.isString(object) ? $(object) : object;
    var args = $A(arguments), method = args.last(),
      options = args.length == 5 ? args[3] : null;
    this.method = Object.isFunction(method) ? method.bind(object) :
      Object.isFunction(object[method]) ? object[method].bind(object) :
      function(value) { object[method] = value };
    this.start(Object.extend({ from: from, to: to }, options || { }));
  },
  update: function(position) {
    this.method(position);
  }
});

Effect.Event = Class.create(Effect.Base, {
  initialize: function() {
    this.start(Object.extend({ duration: 0 }, arguments[0] || { }));
  },
  update: Prototype.emptyFunction
});

Effect.Opacity = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    // make this work on IE on elements without 'layout'
    if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
      Element.setStyle(this.element,{zoom: 1});
    var options = Object.extend({
      from: Element.getOpacity(this.element) || 0.0,
      to:   1.0
    }, arguments[1] || { });
    this.start(options);
  },
  update: function(position) {
    Element.setOpacity(this.element,position);
  }
});

Effect.Move = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      x:    0,
      y:    0,
      mode: 'relative'
    }, arguments[1] || { });
    this.start(options);
  },
  setup: function() {
    Element.makePositioned(this.element);
    this.originalLeft = parseFloat(Element.getStyle(this.element,'left') || '0');
    this.originalTop  = parseFloat(Element.getStyle(this.element,'top')  || '0');
    if (this.options.mode == 'absolute') {
      this.options.x = this.options.x - this.originalLeft;
      this.options.y = this.options.y - this.originalTop;
    }
  },
  update: function(position) {
    Element.setStyle(this.element,{
      left: (this.options.x  * position + this.originalLeft).round() + 'px',
      top:  (this.options.y  * position + this.originalTop).round()  + 'px'
    });
  }
});

// for backwards compatibility
Effect.MoveBy = function(element, toTop, toLeft) {
  return new Effect.Move(element,
    Object.extend({ x: toLeft, y: toTop }, arguments[3] || { }));
};

Effect.Scale = Class.create(Effect.Base, {
  initialize: function(element, percent) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      scaleX: true,
      scaleY: true,
      scaleContent: true,
      scaleFromCenter: false,
      scaleMode: 'box',        // 'box' or 'contents' or { } with provided values
      scaleFrom: 100.0,
      scaleTo:   percent
    }, arguments[2] || { });
    this.start(options);
  },
  setup: function() {
    this.restoreAfterFinish = this.options.restoreAfterFinish || false;
    this.elementPositioning = Element.getStyle(this.element,'position');

    this.originalStyle = { };
    ['top','left','width','height','fontSize'].each( function(k) {
      this.originalStyle[k] = this.element.style[k];
    }.bind(this));

    this.originalTop  = this.element.offsetTop;
    this.originalLeft = this.element.offsetLeft;

    var fontSize = Element.getStyle(this.element,'font-size') || '100%';
    ['em','px','%','pt'].each( function(fontSizeType) {
      if (fontSize.indexOf(fontSizeType)>0) {
        this.fontSize     = parseFloat(fontSize);
        this.fontSizeType = fontSizeType;
      }
    }.bind(this));

    this.factor = (this.options.scaleTo - this.options.scaleFrom)/100;

    this.dims = null;
    if (this.options.scaleMode=='box')
      this.dims = [this.element.offsetHeight, this.element.offsetWidth];
    if (/^content/.test(this.options.scaleMode))
      this.dims = [this.element.scrollHeight, this.element.scrollWidth];
    if (!this.dims)
      this.dims = [this.options.scaleMode.originalHeight,
                   this.options.scaleMode.originalWidth];
  },
  update: function(position) {
    var currentScale = (this.options.scaleFrom/100.0) + (this.factor * position);
    if (this.options.scaleContent && this.fontSize)
      Element.setStyle(this.element,{fontSize: this.fontSize * currentScale + this.fontSizeType });
    this.setDimensions(this.dims[0] * currentScale, this.dims[1] * currentScale);
  },
  finish: function(position) {
    if (this.restoreAfterFinish) Element.setStyle(this.element,this.originalStyle);
  },
  setDimensions: function(height, width) {
    var d = { };
    if (this.options.scaleX) d.width = width.round() + 'px';
    if (this.options.scaleY) d.height = height.round() + 'px';
    if (this.options.scaleFromCenter) {
      var topd  = (height - this.dims[0])/2;
      var leftd = (width  - this.dims[1])/2;
      if (this.elementPositioning == 'absolute') {
        if (this.options.scaleY) d.top = this.originalTop-topd + 'px';
        if (this.options.scaleX) d.left = this.originalLeft-leftd + 'px';
      } else {
        if (this.options.scaleY) d.top = -topd + 'px';
        if (this.options.scaleX) d.left = -leftd + 'px';
      }
    }
    Element.setStyle(this.element,d);
  }
});

Effect.Highlight = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({ startcolor: '#ffff99' }, arguments[1] || { });
    this.start(options);
  },
  setup: function() {
    // Prevent executing on elements not in the layout flow
    if (Element.getStyle(this.element,'display')=='none') { this.cancel(); return; }
    // Disable background image during the effect
    this.oldStyle = { };
    if (!this.options.keepBackgroundImage) {
      this.oldStyle.backgroundImage = Element.getStyle(this.element,'background-image');
      Element.setStyle(this.element,{backgroundImage: 'none'});
    }
    if (!this.options.endcolor)
      this.options.endcolor = Element.getStyle(this.element,'background-color').parseColor('#ffffff');
    if (!this.options.restorecolor)
      this.options.restorecolor = Element.getStyle(this.element,'background-color');
    // init color calculations
    this._base  = $R(0,2).map(function(i){ return parseInt(this.options.startcolor.slice(i*2+1,i*2+3),16) }.bind(this));
    this._delta = $R(0,2).map(function(i){ return parseInt(this.options.endcolor.slice(i*2+1,i*2+3),16)-this._base[i] }.bind(this));
  },
  update: function(position) {
    Element.setStyle(this.element,{backgroundColor: $R(0,2).inject('#',function(m,v,i){
      return m+((this._base[i]+(this._delta[i]*position)).round().toColorPart()); }.bind(this)) });
  },
  finish: function() {
    Element.setStyle(this.element,Object.extend(this.oldStyle, {
      backgroundColor: this.options.restorecolor
    }));
  }
});

Effect.ScrollTo = function(element) {
  var options = arguments[1] || { },
  scrollOffsets = document.viewport.getScrollOffsets(),
  elementOffsets = Element.cumulativeOffset($(element));

  if (options.offset) elementOffsets[1] += options.offset;

  return new Effect.Tween(null,
    scrollOffsets.top,
    elementOffsets[1],
    options,
    function(p){ scrollTo(scrollOffsets.left, p.round()); }
  );
};

/* ------------- combination effects ------------- */

Effect.Fade = function(element) {
  element = $(element);
  var oldOpacity = Element.getInlineOpacity(element);
  var options = Object.extend({
    from: Element.getOpacity(element) || 1.0,
    to:   0.0,
    afterFinishInternal: function(effect) {
      if (effect.options.to!=0) return;
      Element.setStyle(Element.hide(effect.element),{opacity: oldOpacity});
    }
  }, arguments[1] || { });
  return new Effect.Opacity(element,options);
};

Effect.Appear = function(element) {
  element = $(element);
  var options = Object.extend({
  from: (Element.getStyle(element,'display') == 'none' ? 0.0 : Element.getOpacity(element) || 0.0),
  to:   1.0,
  // force Safari to render floated elements properly
  afterFinishInternal: function(effect) {
    effect.element.forceRerendering();
  },
  beforeSetup: function(effect) {
    Element.show(Element.setOpacity(effect.element, effect.options.from));
  }}, arguments[1] || { });
  return new Effect.Opacity(element,options);
};

Effect.Puff = function(element) {
  element = $(element);
  var oldStyle = {
    opacity: Element.getInlineOpacity(element),
    position: Element.getStyle(element,'position'),
    top:  element.style.top,
    left: element.style.left,
    width: element.style.width,
    height: element.style.height
  };
  return new Effect.Parallel(
   [ new Effect.Scale(element, 200,
      { sync: true, scaleFromCenter: true, scaleContent: true, restoreAfterFinish: true }),
     new Effect.Opacity(element, { sync: true, to: 0.0 } ) ],
     Object.extend({ duration: 1.0,
      beforeSetupInternal: function(effect) {
        Element.absolutize(effect.effects[0].element);
      },
      afterFinishInternal: function(effect) {
         Element.setStyle(Element.hide(effect.effects[0].element),oldStyle); }
     }, arguments[1] || { })
   );
};

Effect.BlindUp = function(element) {
  element = $(element);
  Element.makeClipping(element);
  return new Effect.Scale(element, 0,
    Object.extend({ scaleContent: false,
      scaleX: false,
      restoreAfterFinish: true,
      afterFinishInternal: function(effect) {
        Element.undoClipping(Element.hide(effect.element));
      }
    }, arguments[1] || { })
  );
};

Effect.BlindDown = function(element) {
  element = $(element);
  var elementDimensions = Element.getDimensions(element);
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleX: false,
    scaleFrom: 0,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      Element.show(Element.setStyle(Element.makeClipping(effect.element),{height: '0px'}));
    },
    afterFinishInternal: function(effect) {
      Element.undoClipping(effect.element);
    }
  }, arguments[1] || { }));
};

Effect.SwitchOff = function(element) {
  element = $(element);
  var oldOpacity = Element.getInlineOpacity(element);
  return new Effect.Appear(element, Object.extend({
    duration: 0.4,
    from: 0,
    transition: Effect.Transitions.flicker,
    afterFinishInternal: function(effect) {
      new Effect.Scale(effect.element, 1, {
        duration: 0.3, scaleFromCenter: true,
        scaleX: false, scaleContent: false, restoreAfterFinish: true,
        beforeSetup: function(effect) {
          Element.makeClipping(Element.makePositioned(effect.element));
        },
        afterFinishInternal: function(effect) {
          Element.setStyle(Element.undoPositioned(Element.undoClipping(Element.hide(effect.element))),{opacity: oldOpacity});
        }
      });
    }
  }, arguments[1] || { }));
};

Effect.DropOut = function(element) {
  element = $(element);
  var oldStyle = {
    top: Element.getStyle(element,'top'),
    left: Element.getStyle(element,'left'),
    opacity: Element.getInlineOpacity(element) };
  return new Effect.Parallel(
    [ new Effect.Move(element, {x: 0, y: 100, sync: true }),
      new Effect.Opacity(element, { sync: true, to: 0.0 }) ],
    Object.extend(
      { duration: 0.5,
        beforeSetup: function(effect) {
          Element.makePositioned(effect.effects[0].element);
        },
        afterFinishInternal: function(effect) {
          Element.setStyle(Element.undoPositioned(Element.hide(effect.effects[0].element)),oldStyle);
        }
      }, arguments[1] || { }));
};

Effect.Shake = function(element) {
  element = $(element);
  var options = Object.extend({
    distance: 20,
    duration: 0.5
  }, arguments[1] || {});
  var distance = parseFloat(options.distance);
  var split = parseFloat(options.duration) / 10.0;
  var oldStyle = {
    top: Element.getStyle(element,'top'),
    left: Element.getStyle(element,'left') };
    return new Effect.Move(element,
      { x:  distance, y: 0, duration: split, afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x: -distance, y: 0, duration: split, afterFinishInternal: function(effect) {
        Element.setStyle(Element.undoPositioned(effect.element),oldStyle);
  }}); }}); }}); }}); }}); }});
};

Effect.SlideDown = function(element) {
  element = Element.cleanWhitespace($(element));
  // SlideDown need to have the content of the element wrapped in a container element with fixed height!
  var oldInnerBottom = Element.getStyle(Element.down(element),'bottom');
  var elementDimensions = Element.getDimensions(element);
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleX: false,
    scaleFrom: window.opera ? 0 : 1,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      Element.makePositioned(effect.element);
      Element.makePositioned(Element.down(effect.element));
      if (window.opera) Element.setStyle(effect.element,{top: ''});
      Element.show(Element.setStyle(Element.makeClipping(effect.element),{height: '0px'}));
    },
    afterUpdateInternal: function(effect) {
      Element.setStyle(Element.down(effect.element),{bottom:
        (effect.dims[0] - effect.element.clientHeight) + 'px' });
    },
    afterFinishInternal: function(effect) {
      Element.undoPositioned(Element.undoClipping(effect.element));
      Element.setStyle(Element.undoPositioned(Element.down(effect.element)),{bottom: oldInnerBottom}); }
    }, arguments[1] || { })
  );
};

Effect.SlideUp = function(element) {
  element = Element.cleanWhitespace($(element));
  var oldInnerBottom = Element.getStyle(Element.down(element),'bottom');
  var elementDimensions = Element.getDimensions(element);
  return new Effect.Scale(element, window.opera ? 0 : 1,
   Object.extend({ scaleContent: false,
    scaleX: false,
    scaleMode: 'box',
    scaleFrom: 100,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      Element.makePositioned(effect.element);
      Element.makePositioned(Element.down(effect.element));
      if (window.opera) Element.setStyle(effect.element,{top: ''});
      Element.show(Element.makeClipping(effect.element));
    },
    afterUpdateInternal: function(effect) {
      Element.setStyle(Element.down(effect.element),{bottom:
        (effect.dims[0] - effect.element.clientHeight) + 'px' });
    },
    afterFinishInternal: function(effect) {
      Element.undoPositioned(Element.undoClipping(Element.hide(effect.element)));
      Element.setStyle(Element.undoPositioned(Element.down(effect.element)),{bottom: oldInnerBottom});
    }
   }, arguments[1] || { })
  );
};

// Bug in opera makes the TD containing this element expand for a instance after finish
Effect.Squish = function(element) {
  return new Effect.Scale(element, window.opera ? 1 : 0, {
    restoreAfterFinish: true,
    beforeSetup: function(effect) {
      Element.makeClipping(effect.element);
    },
    afterFinishInternal: function(effect) {
      Element.undoClipping(Element.hide(effect.element));
    }
  });
};

Effect.Grow = function(element) {
  element = $(element);
  var options = Object.extend({
    direction: 'center',
    moveTransition: Effect.Transitions.sinoidal,
    scaleTransition: Effect.Transitions.sinoidal,
    opacityTransition: Effect.Transitions.full
  }, arguments[1] || { });
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    height: element.style.height,
    width: element.style.width,
    opacity: Element.getInlineOpacity(element) };

  var dims = Element.getDimensions(element);
  var initialMoveX, initialMoveY;
  var moveX, moveY;

  switch (options.direction) {
    case 'top-left':
      initialMoveX = initialMoveY = moveX = moveY = 0;
      break;
    case 'top-right':
      initialMoveX = dims.width;
      initialMoveY = moveY = 0;
      moveX = -dims.width;
      break;
    case 'bottom-left':
      initialMoveX = moveX = 0;
      initialMoveY = dims.height;
      moveY = -dims.height;
      break;
    case 'bottom-right':
      initialMoveX = dims.width;
      initialMoveY = dims.height;
      moveX = -dims.width;
      moveY = -dims.height;
      break;
    case 'center':
      initialMoveX = dims.width / 2;
      initialMoveY = dims.height / 2;
      moveX = -dims.width / 2;
      moveY = -dims.height / 2;
      break;
  }

  return new Effect.Move(element, {
    x: initialMoveX,
    y: initialMoveY,
    duration: 0.01,
    beforeSetup: function(effect) {
      Element.makePositioned(Element.makeClipping(Element.hide(effect.element)));
    },
    afterFinishInternal: function(effect) {
      new Effect.Parallel(
        [ new Effect.Opacity(effect.element, { sync: true, to: 1.0, from: 0.0, transition: options.opacityTransition }),
          new Effect.Move(effect.element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition }),
          new Effect.Scale(effect.element, 100, {
            scaleMode: { originalHeight: dims.height, originalWidth: dims.width },
            sync: true, scaleFrom: window.opera ? 1 : 0, transition: options.scaleTransition, restoreAfterFinish: true})
        ], Object.extend({
             beforeSetup: function(effect) {
               Element.show(Element.setStyle(effect.effects[0].element,{height: '0px'}));
             },
             afterFinishInternal: function(effect) {
               Element.setStyle(Element.undoPositioned(Element.undoClipping(effect.effects[0].element)),oldStyle);
             }
           }, options)
      );
    }
  });
};

Effect.Shrink = function(element) {
  element = $(element);
  var options = Object.extend({
    direction: 'center',
    moveTransition: Effect.Transitions.sinoidal,
    scaleTransition: Effect.Transitions.sinoidal,
    opacityTransition: Effect.Transitions.none
  }, arguments[1] || { });
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    height: element.style.height,
    width: element.style.width,
    opacity: Element.getInlineOpacity(element) };

  var dims = Element.getDimensions(element);
  var moveX, moveY;

  switch (options.direction) {
    case 'top-left':
      moveX = moveY = 0;
      break;
    case 'top-right':
      moveX = dims.width;
      moveY = 0;
      break;
    case 'bottom-left':
      moveX = 0;
      moveY = dims.height;
      break;
    case 'bottom-right':
      moveX = dims.width;
      moveY = dims.height;
      break;
    case 'center':
      moveX = dims.width / 2;
      moveY = dims.height / 2;
      break;
  }

  return new Effect.Parallel(
    [ new Effect.Opacity(element, { sync: true, to: 0.0, from: 1.0, transition: options.opacityTransition }),
      new Effect.Scale(element, window.opera ? 1 : 0, { sync: true, transition: options.scaleTransition, restoreAfterFinish: true}),
      new Effect.Move(element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition })
    ], Object.extend({
         beforeStartInternal: function(effect) {
           Element.makeClipping(Element.makePositioned(effect.effects[0].element));
         },
         afterFinishInternal: function(effect) {
           Element.setStyle(Element.undoPositioned(Element.undoClipping(Element.hide(effect.effects[0].element))),oldStyle); }
       }, options)
  );
};

Effect.Pulsate = function(element) {
  element = $(element);
  var options    = arguments[1] || { },
    oldOpacity = Element.getInlineOpacity(element),
    transition = options.transition || Effect.Transitions.linear,
    reverser   = function(pos){
      return 1 - transition((-Math.cos((pos*(options.pulses||5)*2)*Math.PI)/2) + .5);
    };

  return new Effect.Opacity(element,
    Object.extend(Object.extend({  duration: 2.0, from: 0,
      afterFinishInternal: function(effect) { Element.setStyle(effect.element,{opacity: oldOpacity}); }
    }, options), {transition: reverser}));
};

Effect.Fold = function(element) {
  element = $(element);
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    width: element.style.width,
    height: element.style.height };
  Element.makeClipping(element);
  return new Effect.Scale(element, 5, Object.extend({
    scaleContent: false,
    scaleX: false,
    afterFinishInternal: function(effect) {
    new Effect.Scale(element, 1, {
      scaleContent: false,
      scaleY: false,
      afterFinishInternal: function(effect) {
        Element.setStyle(Element.undoClipping(Element.hide(effect.element)),oldStyle);
      } });
  }}, arguments[1] || { }));
};

Effect.Morph = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      style: { }
    }, arguments[1] || { });

    if (!Object.isString(options.style)) this.style = $H(options.style);
    else {
      if (options.style.include(':'))
        this.style = options.style.parseStyle();
      else {
        Element.addClassName(this.element,options.style);
        this.style = $H(Element.getStyles(this.element));
        Element.removeClassName(this.element,options.style);
        var css = Element.getStyles(this.element);
        this.style = this.style.reject(function(style) {
          return style.value == css[style.key];
        });
        options.afterFinishInternal = function(effect) {
          Element.addClassName(effect.element,effect.options.style);
          effect.transforms.each(function(transform) {
            effect.element.style[transform.style] = '';
          });
        };
      }
    }
    this.start(options);
  },

  setup: function(){
    function parseColor(color){
      if (!color || ['rgba(0, 0, 0, 0)','transparent'].include(color)) color = '#ffffff';
      color = color.parseColor();
      return $R(0,2).map(function(i){
        return parseInt( color.slice(i*2+1,i*2+3), 16 );
      });
    }
    this.transforms = this.style.map(function(pair){
      var property = pair[0], value = pair[1], unit = null;

      if (value.parseColor('#zzzzzz') != '#zzzzzz') {
        value = value.parseColor();
        unit  = 'color';
      } else if (property == 'opacity') {
        value = parseFloat(value);
        if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
          Element.setStyle(this.element,{zoom: 1});
      } else if (Element.CSS_LENGTH.test(value)) {
          var components = value.match(/^([\+\-]?[0-9\.]+)(.*)$/);
          value = parseFloat(components[1]);
          unit = (components.length == 3) ? components[2] : null;
      }

      var originalValue = Element.getStyle(this.element,property);
      return {
        style: property.camelize(),
        originalValue: unit=='color' ? parseColor(originalValue) : parseFloat(originalValue || 0),
        targetValue: unit=='color' ? parseColor(value) : value,
        unit: unit
      };
    }.bind(this)).reject(function(transform){
      return (
        (transform.originalValue == transform.targetValue) ||
        (
          transform.unit != 'color' &&
          (isNaN(transform.originalValue) || isNaN(transform.targetValue))
        )
      );
    });
  },
  update: function(position) {
    var style = { }, transform, i = this.transforms.length;
    while(i--)
      style[(transform = this.transforms[i]).style] =
        transform.unit=='color' ? '#'+
          (Math.round(transform.originalValue[0]+
            (transform.targetValue[0]-transform.originalValue[0])*position)).toColorPart() +
          (Math.round(transform.originalValue[1]+
            (transform.targetValue[1]-transform.originalValue[1])*position)).toColorPart() +
          (Math.round(transform.originalValue[2]+
            (transform.targetValue[2]-transform.originalValue[2])*position)).toColorPart() :
        (transform.originalValue +
          (transform.targetValue - transform.originalValue) * position).toFixed(3) +
            (transform.unit === null ? '' : transform.unit);
    Element.setStyle(this.element,style, true);
  }
});

Effect.Transform = Class.create({
  initialize: function(tracks){
    this.tracks  = [];
    this.options = arguments[1] || { };
    this.addTracks(tracks);
  },
  addTracks: function(tracks){
    tracks.each(function(track){
      track = $H(track);
      var data = track.values().first();
      this.tracks.push($H({
        ids:     track.keys().first(),
        effect:  Effect.Morph,
        options: { style: data }
      }));
    }.bind(this));
    return this;
  },
  play: function(){
    return new Effect.Parallel(
      this.tracks.map(function(track){
        var ids = track.get('ids'), effect = track.get('effect'), options = track.get('options');
        var elements = [$(ids) || $$(ids)].flatten();
        return elements.map(function(e){ return new effect(e, Object.extend({ sync:true }, options)) });
      }).flatten(),
      this.options
    );
  }
});

Element.CSS_PROPERTIES = $w(
  'backgroundColor backgroundPosition borderBottomColor borderBottomStyle ' +
  'borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth ' +
  'borderRightColor borderRightStyle borderRightWidth borderSpacing ' +
  'borderTopColor borderTopStyle borderTopWidth bottom clip color ' +
  'fontSize fontWeight height left letterSpacing lineHeight ' +
  'marginBottom marginLeft marginRight marginTop markerOffset maxHeight '+
  'maxWidth minHeight minWidth opacity outlineColor outlineOffset ' +
  'outlineWidth paddingBottom paddingLeft paddingRight paddingTop ' +
  'right textIndent top width wordSpacing zIndex');

Element.CSS_LENGTH = /^(([\+\-]?[0-9\.]+)(em|ex|px|in|cm|mm|pt|pc|\%))|0$/;

String.__parseStyleElement = document.createElement('div');
String.prototype.parseStyle = function(){
  var style, styleRules = $H();
  if (Prototype.Browser.WebKit)
    style = new Element('div',{style:this}).style;
  else {
    String.__parseStyleElement.innerHTML = '<div style="' + this + '"></div>';
    style = String.__parseStyleElement.childNodes[0].style;
  }

  Element.CSS_PROPERTIES.each(function(property){
    if (style[property]) styleRules.set(property, style[property]);
  });

  if (Prototype.Browser.IE && this.include('opacity'))
    styleRules.set('opacity', this.match(/opacity:\s*((?:0|1)?(?:\.\d*)?)/)[1]);

  return styleRules;
};

if (document.defaultView && document.defaultView.getComputedStyle) {
  Element.getStyles = function(element) {
    var css = document.defaultView.getComputedStyle($(element), null);
    return Element.CSS_PROPERTIES.inject({ }, function(styles, property) {
      styles[property] = css[property];
      return styles;
    });
  };
} else {
  Element.getStyles = function(element) {
    element = $(element);
    var css = element.currentStyle, styles;
    styles = Element.CSS_PROPERTIES.inject({ }, function(results, property) {
      results[property] = css[property];
      return results;
    });
    if (!styles.opacity) styles.opacity = Element.getOpacity(element);
    return styles;
  };
}

Effect.Methods = {
  morph: function(element, style) {
    element = $(element);
    new Effect.Morph(element, Object.extend({ style: style }, arguments[2] || { }));
    return element;
  },
  visualEffect: function(element, effect, options) {
    element = $(element);
    var s = effect.dasherize().camelize(), klass = s.charAt(0).toUpperCase() + s.substring(1);
    new Effect[klass](element, options);
    return element;
  },
  highlight: function(element, options) {
    element = $(element);
    new Effect.Highlight(element, options);
    return element;
  }
};

$w('fade appear grow shrink fold blindUp blindDown slideUp slideDown '+
  'pulsate shake puff squish switchOff dropOut').each(
  function(effect) {
    Effect.Methods[effect] = function(element, options){
      element = $(element);
      Effect[effect.charAt(0).toUpperCase() + effect.substring(1)](element, options);
      return element;
    };
  }
);

$w('getInlineOpacity forceRerendering setContentZoom collectTextNodes collectTextNodesIgnoreClass getStyles').each(
  function(f) { Effect.Methods[f] = Element[f]; }
);

Element.addMethods(Effect.Methods);

if(Object.isUndefined(Effect))
  throw("dragdrop.js requires including script.aculo.us' effects.js library");

  
  
var Droppables = {
  drops: [],

  remove: function(element) {
    this.drops = this.drops.reject(function(d) { return d.element==$(element) });
  },

  add: function(element) {
    element = $(element);
    var options = Object.extend({
      greedy:     true,
      hoverclass: null,
      tree:       false
    }, arguments[1] || { });

    // cache containers
    if(options.containment) {
      options._containers = [];
      var containment = options.containment;
      if(Object.isArray(containment)) {
        containment.each( function(c) { options._containers.push($(c)) });
      } else {
        options._containers.push($(containment));
      }
    }

    if(options.accept) options.accept = [options.accept].flatten();

    Element.makePositioned(element); // fix IE
    options.element = element;

    this.drops.push(options);
  },

  findDeepestChild: function(drops) {
    deepest = drops[0];

    for (i = 1; i < drops.length; ++i)
      if (Element.isParent(drops[i].element, deepest.element))
        deepest = drops[i];

    return deepest;
  },

  isContained: function(element, drop) {
    var containmentNode;
    if(drop.tree) {
      containmentNode = element.treeNode;
    } else {
      containmentNode = element.parentNode;
    }
    return drop._containers.detect(function(c) { return containmentNode == c });
  },

  isAffected: function(point, element, drop) {
    return (
      (drop.element!=element) &&
      ((!drop._containers) ||
        this.isContained(element, drop)) &&
      ((!drop.accept) ||
        (Element.classNames(element).detect(
          function(v) { return drop.accept.include(v) } ) )) &&
      Element.within(drop.element, point[0], point[1]) );
  },

  deactivate: function(drop) {
    if(drop.hoverclass)
      Element.removeClassName(drop.element, drop.hoverclass);
    this.last_active = null;
  },

  activate: function(drop) {
    if(drop.hoverclass)
      Element.addClassName(drop.element, drop.hoverclass);
    this.last_active = drop;
  },

  show: function(point, element) {
    if(!this.drops.length) return;
    var drop, affected = [];

    this.drops.each( function(drop) {
      if(Droppables.isAffected(point, element, drop))
        affected.push(drop);
    });

    if(affected.length>0)
      drop = Droppables.findDeepestChild(affected);

    if(this.last_active && this.last_active != drop) this.deactivate(this.last_active);
    if (drop) {
      Element.within(drop.element, point[0], point[1]);
      if(drop.onHover)
        drop.onHover(element, drop.element, Element.overlap(drop.overlap, drop.element));

      if (drop != this.last_active) Droppables.activate(drop);
    }
  },

  fire: function(event, element) {
    if(!this.last_active) return;
    
    if (this.isAffected([Event.pointerX(event), Event.pointerY(event)], element, this.last_active))
      if (this.last_active.onDrop) {
        this.last_active.onDrop(element, this.last_active.element, event);
        return true;
      }
  },

  reset: function() {
    if(this.last_active)
      this.deactivate(this.last_active);
  }
};

var Draggables = {
  drags: [],
  observers: [],

  register: function(draggable) {
    if(this.drags.length == 0) {
      this.eventMouseUp   = this.endDrag.bindAsEventListener(this);
      this.eventMouseMove = this.updateDrag.bindAsEventListener(this);
      this.eventKeypress  = this.keyPress.bindAsEventListener(this);

      Event.observe(document, "mouseup", this.eventMouseUp);
      Event.observe(document, "mousemove", this.eventMouseMove);
      Event.observe(document, "keypress", this.eventKeypress);
    }
    this.drags.push(draggable);
  },

  unregister: function(draggable) {
    this.drags = this.drags.reject(function(d) { return d==draggable });
    if(this.drags.length == 0) {
      Event.stopObserving(document, "mouseup", this.eventMouseUp);
      Event.stopObserving(document, "mousemove", this.eventMouseMove);
      Event.stopObserving(document, "keypress", this.eventKeypress);
    }
  },

  activate: function(draggable) {
    if(draggable.options.delay) {
      this._timeout = setTimeout(function() {
        Draggables._timeout = null;
        window.focus();
        Draggables.activeDraggable = draggable;
      }.bind(this), draggable.options.delay);
    } else {
      window.focus(); // allows keypress events if window isn't currently focused, fails for Safari
      this.activeDraggable = draggable;
    }
  },

  deactivate: function() {
    this.activeDraggable = null;
  },

  updateDrag: function(event) {
    if(!this.activeDraggable) return;
    var pointer = [Event.pointerX(event), Event.pointerY(event)];
    // Mozilla-based browsers fire successive mousemove events with
    // the same coordinates, prevent needless redrawing (moz bug?)
    if(this._lastPointer && (this._lastPointer.inspect() == pointer.inspect())) return;
    this._lastPointer = pointer;

    this.activeDraggable.updateDrag(event, pointer);
  },

  endDrag: function(event) {
    if(this._timeout) {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    if(!this.activeDraggable) return;
    this._lastPointer = null;
    this.activeDraggable.endDrag(event);
    this.activeDraggable = null;
  },

  keyPress: function(event) {
    if(this.activeDraggable)
      this.activeDraggable.keyPress(event);
  },

  addObserver: function(observer) {
    this.observers.push(observer);
    this._cacheObserverCallbacks();
  },

  removeObserver: function(element) {  // element instead of observer fixes mem leaks
    this.observers = this.observers.reject( function(o) { return o.element==element });
    this._cacheObserverCallbacks();
  },

  notify: function(eventName, draggable, event) {  // 'onStart', 'onEnd', 'onDrag'
    if(this[eventName+'Count'] > 0)
      this.observers.each( function(o) {
        if(o[eventName]) o[eventName](eventName, draggable, event);
      });
    if(draggable.options[eventName]) draggable.options[eventName](draggable, event);
  },

  _cacheObserverCallbacks: function() {
    ['onStart','onEnd','onDrag'].each( function(eventName) {
      Draggables[eventName+'Count'] = Draggables.observers.select(
        function(o) { return o[eventName]; }
      ).length;
    });
  }
};

/*--------------------------------------------------------------------------*/

var Draggable = Class.create({
  initialize: function(element) {
    var defaults = {
      handle: false,
      reverteffect: function(element, top_offset, left_offset) {
        var dur = Math.sqrt(Math.abs(top_offset^2)+Math.abs(left_offset^2))*0.02;
        new Effect.Move(element, { x: -left_offset, y: -top_offset, duration: dur,
          queue: {scope:'_draggable', position:'end'}
        });
      },
      endeffect: function(element) {
        var toOpacity = Object.isNumber(element._opacity) ? element._opacity : 1.0;
        new Effect.Opacity(element, {duration:0.2, from:0.7, to:toOpacity,
          queue: {scope:'_draggable', position:'end'},
          afterFinish: function(){
            Draggable._dragging[element] = false
          }
        });
      },
      zindex: 1000,
      revert: false,
      quiet: false,
      scroll: false,
      scrollSensitivity: 20,
      scrollSpeed: 15,
      snap: false,  // false, or xy or [x,y] or function(x,y){ return [x,y] }
      delay: 0
    };

    if(!arguments[1] || Object.isUndefined(arguments[1].endeffect))
      Object.extend(defaults, {
        starteffect: function(element) {
          element._opacity = Element.getOpacity(element);
          Draggable._dragging[element] = true;
          new Effect.Opacity(element, {duration:0.2, from:element._opacity, to:0.7});
        }
      });

    var options = Object.extend(defaults, arguments[1] || { });

    this.element = $(element);

    if(options.handle && Object.isString(options.handle))
      this.handle = Element.down(this.element,'.'+options.handle, 0);

    if(!this.handle) this.handle = $(options.handle);
    if(!this.handle) this.handle = this.element;

    if(options.scroll && !options.scroll.scrollTo && !options.scroll.outerHTML) {
      options.scroll = $(options.scroll);
      this._isScrollChild = Element.childOf(this.element, options.scroll);
    }

    Element.makePositioned(this.element); // fix IE

    this.options  = options;
    this.dragging = false;

    this.eventMouseDown = this.initDrag.bindAsEventListener(this);
    Event.observe(this.handle, "mousedown", this.eventMouseDown);

    Draggables.register(this);
  },

  destroy: function() {
    Event.stopObserving(this.handle, "mousedown", this.eventMouseDown);
    Draggables.unregister(this);
  },

  currentDelta: function() {
	var offset = Element.cumulativeOffset(this.element);
	return([offset.left,offset.top]);
	/*
    return([
      parseInt(Element.getStyle(this.element,'left') || offset.left),
      parseInt(Element.getStyle(this.element,'top') || offset.top)]);
	 */
  },

  initDrag: function(event) {
    if(!Object.isUndefined(Draggable._dragging[this.element]) &&
      Draggable._dragging[this.element]) return;
    if(Event.isLeftClick(event)) {
      // abort on form elements, fixes a Firefox issue
      var src = Event.element(event);
      if((tag_name = src.tagName.toUpperCase()) && (
        tag_name=='INPUT' ||
        tag_name=='SELECT' ||
        tag_name=='OPTION' ||
        tag_name=='BUTTON' ||
        tag_name=='TEXTAREA')) return;

      var pointer = [Event.pointerX(event), Event.pointerY(event)];
      var pos     = Element.cumulativeOffset(this.element);
      this.offset = [0,1].map( function(i) { return (pointer[i] - pos[i]) });

      Draggables.activate(this);
      Event.stop(event);
    }
  },

  startDrag: function(event) {
    this.dragging = true;
    if(!this.delta)
      this.delta = this.currentDelta();

    if(this.options.zindex) {
      this.originalZ = parseInt(Element.getStyle(this.element,'z-index') || 0);
      this.element.style.zIndex = this.options.zindex;
    }

    if(this.options.ghosting) {
      this._clone = this.element.cloneNode(true);
      this._originallyAbsolute = (Element.getStyle(this.element,'position') == 'absolute');
      if (!this._originallyAbsolute)
        Element.absolutize(this.element);
      this.element.parentNode.insertBefore(this._clone, this.element);
    }

    if(this.options.scroll) {
      if (this.options.scroll == window) {
        var where = this._getWindowScroll(this.options.scroll);
        this.originalScrollLeft = where.left;
        this.originalScrollTop = where.top;
      } else {
        this.originalScrollLeft = this.options.scroll.scrollLeft;
        this.originalScrollTop = this.options.scroll.scrollTop;
      }
    }

    Draggables.notify('onStart', this, event);

    if(this.options.starteffect) this.options.starteffect(this.element);
  },

  updateDrag: function(event, pointer) {
    if(!this.dragging) this.startDrag(event);

    if(!this.options.quiet){
      Droppables.show(pointer, this.element);
    }

    Draggables.notify('onDrag', this, event);

    this.draw(pointer);
    if(this.options.change) this.options.change(this);

    if(this.options.scroll) {
      this.stopScrolling();

      var p;
      if (this.options.scroll == window) {
        with(this._getWindowScroll(this.options.scroll)) { p = [ left, top, left+width, top+height ]; }
      } else {
        p = Element.page(this.options.scroll).toArray();
        p[0] += this.options.scroll.scrollLeft + Element.deltaX;
        p[1] += this.options.scroll.scrollTop + Element.deltaY;
        p.push(p[0]+this.options.scroll.offsetWidth);
        p.push(p[1]+this.options.scroll.offsetHeight);
      }
      var speed = [0,0];
      if(pointer[0] < (p[0]+this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[0]+this.options.scrollSensitivity);
      if(pointer[1] < (p[1]+this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[1]+this.options.scrollSensitivity);
      if(pointer[0] > (p[2]-this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[2]-this.options.scrollSensitivity);
      if(pointer[1] > (p[3]-this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[3]-this.options.scrollSensitivity);
      this.startScrolling(speed);
    }

    // fix AppleWebKit rendering
    if(Prototype.Browser.WebKit) window.scrollBy(0,0);

    Event.stop(event);
  },

  finishDrag: function(event, success) {
    this.dragging = false;

    if(this.options.quiet){
      var pointer = [Event.pointerX(event), Event.pointerY(event)];
      Droppables.show(pointer, this.element);
    }

    if(this.options.ghosting) {
      if (!this._originallyAbsolute)
        Element.relativize(this.element);
      delete this._originallyAbsolute;
      Element.remove(this._clone);
      this._clone = null;
    }

    var dropped = false;
    if(success) {
      dropped = Droppables.fire(event, this.element);
      if (!dropped) dropped = false;
    }
    if(dropped && this.options.onDropped) this.options.onDropped(this.element);
    Draggables.notify('onEnd', this, event);

    var revert = this.options.revert;
    if(revert && Object.isFunction(revert)) revert = revert(this.element);

    var d = this.currentDelta();
    if(revert && this.options.reverteffect) {
      if (dropped == 0 || revert != 'failure')
        this.options.reverteffect(this.element,
          d[1]-this.delta[1], d[0]-this.delta[0]);
    } else {
      this.delta = d;
    }

    if(this.options.zindex)
      this.element.style.zIndex = this.originalZ;

    if(this.options.endeffect)
      this.options.endeffect(this.element);

    Draggables.deactivate(this);
    Droppables.reset();
  },

  keyPress: function(event) {
    if(event.keyCode!=Event.KEY_ESC) return;
    this.finishDrag(event, false);
    Event.stop(event);
  },

  endDrag: function(event) {
    if(!this.dragging) return;
    this.stopScrolling();
    this.finishDrag(event, true);
    Event.stop(event);
  },

  draw: function(point) {
    var pos = Element.cumulativeOffset(this.element);
    if(this.options.ghosting) {
      var r   = Element.realOffset(this.element);
      pos[0] += r[0] - Element.deltaX; pos[1] += r[1] - Element.deltaY;
    }

    var d = this.currentDelta();
    pos[0] -= d[0]; pos[1] -= d[1];

    if(this.options.scroll && (this.options.scroll != window && this._isScrollChild)) {
      pos[0] -= this.options.scroll.scrollLeft-this.originalScrollLeft;
      pos[1] -= this.options.scroll.scrollTop-this.originalScrollTop;
    }

    var p = [0,1].map(function(i){
      return (point[i]-pos[i]-this.offset[i])
    }.bind(this));

    if(this.options.snap) {
      if(Object.isFunction(this.options.snap)) {
        p = this.options.snap(p[0],p[1],this);
      } else {
      if(Object.isArray(this.options.snap)) {
        p = p.map( function(v, i) {
          return (v/this.options.snap[i]).round()*this.options.snap[i] }.bind(this));
      } else {
        p = p.map( function(v) {
          return (v/this.options.snap).round()*this.options.snap }.bind(this));
      }
    }}

    var style = this.element.style;
    if((!this.options.constraint) || (this.options.constraint=='horizontal'))
      style.left = p[0] + "px";
    if((!this.options.constraint) || (this.options.constraint=='vertical'))
      style.top  = p[1] + "px";

    if(style.visibility=="hidden") style.visibility = ""; // fix gecko rendering
  },

  stopScrolling: function() {
    if(this.scrollInterval) {
      clearInterval(this.scrollInterval);
      this.scrollInterval = null;
      Draggables._lastScrollPointer = null;
    }
  },

  startScrolling: function(speed) {
    if(!(speed[0] || speed[1])) return;
    this.scrollSpeed = [speed[0]*this.options.scrollSpeed,speed[1]*this.options.scrollSpeed];
    this.lastScrolled = new Date();
    this.scrollInterval = setInterval(this.scroll.bind(this), 10);
  },

  scroll: function() {
    var current = new Date();
    var delta = current - this.lastScrolled;
    this.lastScrolled = current;
    if(this.options.scroll == window) {
      with (this._getWindowScroll(this.options.scroll)) {
        if (this.scrollSpeed[0] || this.scrollSpeed[1]) {
          var d = delta / 1000;
          this.options.scroll.scrollTo( left + d*this.scrollSpeed[0], top + d*this.scrollSpeed[1] );
        }
      }
    } else {
      this.options.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1000;
      this.options.scroll.scrollTop  += this.scrollSpeed[1] * delta / 1000;
    }

    Droppables.show(Draggables._lastPointer, this.element);
    Draggables.notify('onDrag', this);
    if (this._isScrollChild) {
      Draggables._lastScrollPointer = Draggables._lastScrollPointer || $A(Draggables._lastPointer);
      Draggables._lastScrollPointer[0] += this.scrollSpeed[0] * delta / 1000;
      Draggables._lastScrollPointer[1] += this.scrollSpeed[1] * delta / 1000;
      if (Draggables._lastScrollPointer[0] < 0)
        Draggables._lastScrollPointer[0] = 0;
      if (Draggables._lastScrollPointer[1] < 0)
        Draggables._lastScrollPointer[1] = 0;
      this.draw(Draggables._lastScrollPointer);
    }

    if(this.options.change) this.options.change(this);
  },

  _getWindowScroll: function(w) {
    var T, L, W, H;
    with (w.document) {
      if (w.document.documentElement && documentElement.scrollTop) {
        T = documentElement.scrollTop;
        L = documentElement.scrollLeft;
      } else if (w.document.body) {
        T = body.scrollTop;
        L = body.scrollLeft;
      }
      if (w.innerWidth) {
        W = w.innerWidth;
        H = w.innerHeight;
      } else if (w.document.documentElement && documentElement.clientWidth) {
        W = documentElement.clientWidth;
        H = documentElement.clientHeight;
      } else {
        W = body.offsetWidth;
        H = body.offsetHeight;
      }
    }
    return { top: T, left: L, width: W, height: H };
  }
});

Draggable._dragging = { };

/*--------------------------------------------------------------------------*/

var SortableObserver = Class.create({
  initialize: function(element, observer) {
    this.element   = $(element);
    this.observer  = observer;
    this.lastValue = Sortable.serialize(this.element);
  },

  onStart: function() {
    this.lastValue = Sortable.serialize(this.element);
  },

  onEnd: function() {
    Sortable.unmark();
    if(this.lastValue != Sortable.serialize(this.element))
      this.observer(this.element)
  }
});

var Sortable = {
  SERIALIZE_RULE: /^[^_\-](?:[A-Za-z0-9\-\_]*)[_](.*)$/,

  sortables: { },

  _findRootElement: function(element) {
    while (element.tagName.toUpperCase() != "BODY") {
      if(element.id && Sortable.sortables[element.id]) return element;
      element = element.parentNode;
    }
  },

  options: function(element) {
    element = Sortable._findRootElement($(element));
    if(!element) return;
    return Sortable.sortables[element.id];
  },

  destroy: function(element){
    element = $(element);
    var s = Sortable.sortables[element.id];

    if(s) {
      Draggables.removeObserver(s.element);
      s.droppables.each(function(d){ Droppables.remove(d) });
      s.draggables.invoke('destroy');

      delete Sortable.sortables[s.element.id];
    }
  },

  create: function(element) {
    element = $(element);
    var options = Object.extend({
      element:     element,
      tag:         'li',       // assumes li children, override with tag: 'tagname'
      dropOnEmpty: false,
      tree:        false,
      treeTag:     'ul',
      overlap:     'vertical', // one of 'vertical', 'horizontal'
      constraint:  'vertical', // one of 'vertical', 'horizontal', false
      containment: element,    // also takes array of elements (or id's); or false
      handle:      false,      // or a CSS class
      only:        false,
      delay:       0,
      hoverclass:  null,
      ghosting:    false,
      quiet:       false,
      scroll:      false,
      scrollSensitivity: 20,
      scrollSpeed: 15,
      format:      this.SERIALIZE_RULE,

      // these take arrays of elements or ids and can be
      // used for better initialization performance
      elements:    false,
      handles:     false,

      onChange:    Prototype.emptyFunction,
      onUpdate:    Prototype.emptyFunction
    }, arguments[1] || { });

    // clear any old sortable with same element
    this.destroy(element);

    // build options for the draggables
    var options_for_draggable = {
      revert:      true,
      quiet:       options.quiet,
      scroll:      options.scroll,
      scrollSpeed: options.scrollSpeed,
      scrollSensitivity: options.scrollSensitivity,
      delay:       options.delay,
      ghosting:    options.ghosting,
      constraint:  options.constraint,
      handle:      options.handle };

    if(options.starteffect)
      options_for_draggable.starteffect = options.starteffect;

    if(options.reverteffect)
      options_for_draggable.reverteffect = options.reverteffect;
    else
      if(options.ghosting) options_for_draggable.reverteffect = function(element) {
        element.style.top  = 0;
        element.style.left = 0;
      };

    if(options.endeffect)
      options_for_draggable.endeffect = options.endeffect;

    if(options.zindex)
      options_for_draggable.zindex = options.zindex;

    // build options for the droppables
    var options_for_droppable = {
      overlap:     options.overlap,
      containment: options.containment,
      tree:        options.tree,
      hoverclass:  options.hoverclass,
      onHover:     Sortable.onHover
    };

    var options_for_tree = {
      onHover:      Sortable.onEmptyHover,
      overlap:      options.overlap,
      containment:  options.containment,
      hoverclass:   options.hoverclass
    };

    // fix for gecko engine
    Element.cleanWhitespace(element);

    options.draggables = [];
    options.droppables = [];

    // drop on empty handling
    if(options.dropOnEmpty || options.tree) {
      Droppables.add(element, options_for_tree);
      options.droppables.push(element);
    }

    (options.elements || this.findElements(element, options) || []).each( function(e,i) {
      var handle = options.handles ? $(options.handles[i]) :
        (options.handle ? $(e).select('.' + options.handle)[0] : e);
      options.draggables.push(
        new Draggable(e, Object.extend(options_for_draggable, { handle: handle })));
      Droppables.add(e, options_for_droppable);
      if(options.tree) e.treeNode = element;
      options.droppables.push(e);
    });

    if(options.tree) {
      (Sortable.findTreeElements(element, options) || []).each( function(e) {
        Droppables.add(e, options_for_tree);
        e.treeNode = element;
        options.droppables.push(e);
      });
    }

    // keep reference
    this.sortables[Element.identify(element)] = options;

    // for onupdate
    Draggables.addObserver(new SortableObserver(element, options.onUpdate));

  },

  // return all suitable-for-sortable elements in a guaranteed order
  findElements: function(element, options) {
    return Element.findChildren(
      element, options.only, options.tree ? true : false, options.tag);
  },

  findTreeElements: function(element, options) {
    return Element.findChildren(
      element, options.only, options.tree ? true : false, options.treeTag);
  },

  onHover: function(element, dropon, overlap) {
    if(Element.isParent(dropon, element)) return;

    if(overlap > .33 && overlap < .66 && Sortable.options(dropon).tree) {
      return;
    } else if(overlap>0.5) {
      Sortable.mark(dropon, 'before');
      if(dropon.previousSibling != element) {
        var oldParentNode = element.parentNode;
        element.style.visibility = "hidden"; // fix gecko rendering
        dropon.parentNode.insertBefore(element, dropon);
        if(dropon.parentNode!=oldParentNode)
          Sortable.options(oldParentNode).onChange(element);
        Sortable.options(dropon.parentNode).onChange(element);
      }
    } else {
      Sortable.mark(dropon, 'after');
      var nextElement = dropon.nextSibling || null;
      if(nextElement != element) {
        var oldParentNode = element.parentNode;
        element.style.visibility = "hidden"; // fix gecko rendering
        dropon.parentNode.insertBefore(element, nextElement);
        if(dropon.parentNode!=oldParentNode)
          Sortable.options(oldParentNode).onChange(element);
        Sortable.options(dropon.parentNode).onChange(element);
      }
    }
  },

  onEmptyHover: function(element, dropon, overlap) {
    var oldParentNode = element.parentNode;
    var droponOptions = Sortable.options(dropon);

    if(!Element.isParent(dropon, element)) {
      var index;

      var children = Sortable.findElements(dropon, {tag: droponOptions.tag, only: droponOptions.only});
      var child = null;

      if(children) {
        var offset = Element.offsetSize(dropon, droponOptions.overlap) * (1.0 - overlap);

        for (index = 0; index < children.length; index += 1) {
          if (offset - Element.offsetSize (children[index], droponOptions.overlap) >= 0) {
            offset -= Element.offsetSize (children[index], droponOptions.overlap);
          } else if (offset - (Element.offsetSize (children[index], droponOptions.overlap) / 2) >= 0) {
            child = index + 1 < children.length ? children[index + 1] : null;
            break;
          } else {
            child = children[index];
            break;
          }
        }
      }

      dropon.insertBefore(element, child);

      Sortable.options(oldParentNode).onChange(element);
      droponOptions.onChange(element);
    }
  },

  unmark: function() {
    if(Sortable._marker) Sortable._marker.hide();
  },

  mark: function(dropon, position) {
    // mark on ghosting only
    var sortable = Sortable.options(dropon.parentNode);
    if(sortable && !sortable.ghosting) return;

    if(!Sortable._marker) {
      Sortable._marker =
        ($('dropmarker') || Element.extend(document.createElement('DIV'))).
          hide().addClassName('dropmarker').setStyle({position:'absolute'});
      document.getElementsByTagName("body").item(0).appendChild(Sortable._marker);
    }
    var offsets = Element.cumulativeOffset(dropon);
    Sortable._marker.setStyle({left: offsets[0]+'px', top: offsets[1] + 'px'});

    if(position=='after')
      if(sortable.overlap == 'horizontal')
        Sortable._marker.setStyle({left: (offsets[0]+dropon.clientWidth) + 'px'});
      else
        Sortable._marker.setStyle({top: (offsets[1]+dropon.clientHeight) + 'px'});

    Sortable._marker.show();
  },

  _tree: function(element, options, parent) {
    var children = Sortable.findElements(element, options) || [];

    for (var i = 0; i < children.length; ++i) {
      var match = children[i].id.match(options.format);

      if (!match) continue;

      var child = {
        id: encodeURIComponent(match ? match[1] : null),
        element: element,
        parent: parent,
        children: [],
        position: parent.children.length,
        container: $(children[i]).down(options.treeTag)
      };

      /* Get the element containing the children and recurse over it */
      if (child.container)
        this._tree(child.container, options, child);

      parent.children.push (child);
    }

    return parent;
  },

  tree: function(element) {
    element = $(element);
    var sortableOptions = this.options(element);
    var options = Object.extend({
      tag: sortableOptions.tag,
      treeTag: sortableOptions.treeTag,
      only: sortableOptions.only,
      name: element.id,
      format: sortableOptions.format
    }, arguments[1] || { });

    var root = {
      id: null,
      parent: null,
      children: [],
      container: element,
      position: 0
    };

    return Sortable._tree(element, options, root);
  },

  /* Construct a [i] index for a particular node */
  _constructIndex: function(node) {
    var index = '';
    do {
      if (node.id) index = '[' + node.position + ']' + index;
    } while ((node = node.parent) != null);
    return index;
  },

  sequence: function(element) {
    element = $(element);
    var options = Object.extend(this.options(element), arguments[1] || { });

    return $(this.findElements(element, options) || []).map( function(item) {
      return item.id.match(options.format) ? item.id.match(options.format)[1] : '';
    });
  },

  setSequence: function(element, new_sequence) {
    element = $(element);
    var options = Object.extend(this.options(element), arguments[2] || { });

    var nodeMap = { };
    this.findElements(element, options).each( function(n) {
        if (n.id.match(options.format))
            nodeMap[n.id.match(options.format)[1]] = [n, n.parentNode];
        n.parentNode.removeChild(n);
    });

    new_sequence.each(function(ident) {
      var n = nodeMap[ident];
      if (n) {
        n[1].appendChild(n[0]);
        delete nodeMap[ident];
      }
    });
  },

  serialize: function(element) {
    element = $(element);
    var options = Object.extend(Sortable.options(element), arguments[1] || { });
    var name = encodeURIComponent(
      (arguments[1] && arguments[1].name) ? arguments[1].name : element.id);

    if (options.tree) {
      return Sortable.tree(element, arguments[1]).children.map( function (item) {
        return [name + Sortable._constructIndex(item) + "[id]=" +
                encodeURIComponent(item.id)].concat(item.children.map(arguments.callee));
      }).flatten().join('&');
    } else {
      return Sortable.sequence(element, arguments[1]).map( function(item) {
        return name + "[]=" + encodeURIComponent(item);
      }).join('&');
    }
  }
};

// Returns true if child is contained within element
Element.isParent = function(child, element) {
  if (!child.parentNode || child == element) return false;
  if (child.parentNode == element) return true;
  return Element.isParent(child.parentNode, element);
};

Element.findChildren = function(element, only, recursive, tagName) {
  if(!element.hasChildNodes()) return null;
  tagName = tagName.toUpperCase();
  if(only) only = [only].flatten();
  var elements = [];
  $A(element.childNodes).each( function(e) {
    if(e.tagName && e.tagName.toUpperCase()==tagName &&
      (!only || (Element.classNames(e).detect(function(v) { return only.include(v) }))))
        elements.push(e);
    if(recursive) {
      var grandchildren = Element.findChildren(e, only, recursive, tagName);
      if(grandchildren) elements.push(grandchildren);
    }
  });

  return (elements.length>0 ? elements.flatten() : []);
};

Element.offsetSize = function (element, type) {
  return element['offset' + ((type=='vertical' || type=='height') ? 'Height' : 'Width')];
};

if(typeof Effect == 'undefined')
  throw("controls.js requires including script.aculo.us' effects.js library");


// options:
//  axis: 'vertical', or 'horizontal' (default)
//
// callbacks:
//  onChange(value)
//  onSlide(value)
if (!Control) var Control = { };
Control.Slider = Class.create({
  initialize: function(handle, track, options) {
    var slider = this;

    if (Object.isArray(handle)) {
      this.handles = handle.collect( function(e) { return $(e) });
    } else {
      this.handles = [$(handle)];
    }

    this.track   = $(track);
    this.options = options || { };

    this.axis      = this.options.axis || 'horizontal';
    this.increment = this.options.increment || 1;
    this.step      = parseInt(this.options.step || '1');
    this.range     = this.options.range || $R(0,1);

    this.value     = 0; // assure backwards compat
    this.values    = this.handles.map( function() { return 0 });
    this.spans     = this.options.spans ? this.options.spans.map(function(s){ return $(s) }) : false;
    this.options.startSpan = $(this.options.startSpan || null);
    this.options.endSpan   = $(this.options.endSpan || null);

    this.restricted = this.options.restricted || false;

    this.maximum   = this.options.maximum || this.range.end;
    this.minimum   = this.options.minimum || this.range.start;

    // Will be used to align the handle onto the track, if necessary
    this.alignX = parseInt(this.options.alignX || '0');
    this.alignY = parseInt(this.options.alignY || '0');

    this.trackLength = this.maximumOffset() - this.minimumOffset();

    this.handleLength = this.isVertical() ?
      (this.handles[0].offsetHeight != 0 ?
        this.handles[0].offsetHeight : this.handles[0].style.height.replace(/px$/,"")) :
      (this.handles[0].offsetWidth != 0 ? this.handles[0].offsetWidth :
        this.handles[0].style.width.replace(/px$/,""));

    this.active   = false;
    this.dragging = false;
    this.disabled = false;

    if (this.options.disabled) this.setDisabled();

    // Allowed values array
    this.allowedValues = this.options.values ? this.options.values.sortBy(Prototype.K) : false;
    if (this.allowedValues) {
      this.minimum = this.allowedValues.min();
      this.maximum = this.allowedValues.max();
    }

    this.eventMouseDown = this.startDrag.bindAsEventListener(this);
    this.eventMouseUp   = this.endDrag.bindAsEventListener(this);
    this.eventMouseMove = this.update.bindAsEventListener(this);

    // Initialize handles in reverse (make sure first handle is active)
    this.handles.each( function(h,i) {
      i = slider.handles.length-1-i;
      slider.setValue(parseFloat(
        (Object.isArray(slider.options.sliderValue) ?
          slider.options.sliderValue[i] : slider.options.sliderValue) ||
         slider.range.start), i);
      h.makePositioned().observe("mousedown", slider.eventMouseDown);
    });

    this.track.observe("mousedown", this.eventMouseDown);
    document.observe("mouseup", this.eventMouseUp);
    document.observe("mousemove", this.eventMouseMove);

    this.initialized = true;
  },
  dispose: function() {
    var slider = this;
    Event.stopObserving(this.track, "mousedown", this.eventMouseDown);
    Event.stopObserving(document, "mouseup", this.eventMouseUp);
    Event.stopObserving(document, "mousemove", this.eventMouseMove);
    this.handles.each( function(h) {
      Event.stopObserving(h, "mousedown", slider.eventMouseDown);
    });
  },
  setDisabled: function(){
    this.disabled = true;
  },
  setEnabled: function(){
    this.disabled = false;
  },
  getNearestValue: function(value){
    if (this.allowedValues){
      if (value >= this.allowedValues.max()) return(this.allowedValues.max());
      if (value <= this.allowedValues.min()) return(this.allowedValues.min());

      var offset = Math.abs(this.allowedValues[0] - value);
      var newValue = this.allowedValues[0];
      this.allowedValues.each( function(v) {
        var currentOffset = Math.abs(v - value);
        if (currentOffset <= offset){
          newValue = v;
          offset = currentOffset;
        }
      });
      return newValue;
    }
    if (value > this.range.end) return this.range.end;
    if (value < this.range.start) return this.range.start;
    return value;
  },
  setValue: function(sliderValue, handleIdx){
    if (!this.active) {
      this.activeHandleIdx = handleIdx || 0;
      this.activeHandle    = this.handles[this.activeHandleIdx];
      this.updateStyles();
    }
    handleIdx = handleIdx || this.activeHandleIdx || 0;
    if (this.initialized && this.restricted) {
      if ((handleIdx>0) && (sliderValue<this.values[handleIdx-1]))
        sliderValue = this.values[handleIdx-1];
      if ((handleIdx < (this.handles.length-1)) && (sliderValue>this.values[handleIdx+1]))
        sliderValue = this.values[handleIdx+1];
    }
    sliderValue = this.getNearestValue(sliderValue);
    this.values[handleIdx] = sliderValue;
    this.value = this.values[0]; // assure backwards compat

    this.handles[handleIdx].style[this.isVertical() ? 'top' : 'left'] =
      this.translateToPx(sliderValue);

    this.drawSpans();
    if (!this.dragging || !this.event) this.updateFinished();
  },
  setValueBy: function(delta, handleIdx) {
    this.setValue(this.values[handleIdx || this.activeHandleIdx || 0] + delta,
      handleIdx || this.activeHandleIdx || 0);
  },
  translateToPx: function(value) {
    return Math.round(
      ((this.trackLength-this.handleLength)/(this.range.end-this.range.start)) *
      (value - this.range.start)) + "px";
  },
  translateToValue: function(offset) {
    return ((offset/(this.trackLength-this.handleLength) *
      (this.range.end-this.range.start)) + this.range.start);
  },
  getRange: function(range) {
    var v = this.values.sortBy(Prototype.K);
    range = range || 0;
    return $R(v[range],v[range+1]);
  },
  minimumOffset: function(){
    return(this.isVertical() ? this.alignY : this.alignX);
  },
  maximumOffset: function(){
    return(this.isVertical() ?
      (this.track.offsetHeight != 0 ? this.track.offsetHeight :
        this.track.style.height.replace(/px$/,"")) - this.alignY :
      (this.track.offsetWidth != 0 ? this.track.offsetWidth :
        this.track.style.width.replace(/px$/,"")) - this.alignX);
  },
  isVertical:  function(){
    return (this.axis == 'vertical');
  },
  drawSpans: function() {
    var slider = this;
    if (this.spans)
      $R(0, this.spans.length-1).each(function(r) { slider.setSpan(slider.spans[r], slider.getRange(r)) });
    if (this.options.startSpan)
      this.setSpan(this.options.startSpan,
        $R(0, this.values.length>1 ? this.getRange(0).min() : this.value ));
    if (this.options.endSpan)
      this.setSpan(this.options.endSpan,
        $R(this.values.length>1 ? this.getRange(this.spans.length-1).max() : this.value, this.maximum));
  },
  setSpan: function(span, range) {
    if (this.isVertical()) {
      span.style.top = this.translateToPx(range.start);
      span.style.height = this.translateToPx(range.end - range.start + this.range.start);
    } else {
      span.style.left = this.translateToPx(range.start);
      span.style.width = this.translateToPx(range.end - range.start + this.range.start);
    }
  },
  updateStyles: function() {
    this.handles.each( function(h){ Element.removeClassName(h, 'selected') });
    Element.addClassName(this.activeHandle, 'selected');
  },
  startDrag: function(event) {
    if (Event.isLeftClick(event)) {
      if (!this.disabled){
        this.active = true;

        var handle = Event.element(event);
        var pointer  = [Event.pointerX(event), Event.pointerY(event)];
        var track = handle;
        if (track==this.track) {
          var offsets  = Element.cumulativeOffset(this.track);
          this.event = event;
          this.setValue(this.translateToValue(
           (this.isVertical() ? pointer[1]-offsets[1] : pointer[0]-offsets[0])-(this.handleLength/2)
          ));
          var offsets  = Element.cumulativeOffset(this.activeHandle);
          this.offsetX = (pointer[0] - offsets[0]);
          this.offsetY = (pointer[1] - offsets[1]);
        } else {
          // find the handle (prevents issues with Safari)
          while((this.handles.indexOf(handle) == -1) && handle.parentNode)
            handle = handle.parentNode;

          if (this.handles.indexOf(handle)!=-1) {
            this.activeHandle    = handle;
            this.activeHandleIdx = this.handles.indexOf(this.activeHandle);
            this.updateStyles();

            var offsets  = Element.cumulativeOffset(this.activeHandle);
            this.offsetX = (pointer[0] - offsets[0]);
            this.offsetY = (pointer[1] - offsets[1]);
          }
        }
      }
      Event.stop(event);
    }
  },
  update: function(event) {
   if (this.active) {
      if (!this.dragging) this.dragging = true;
      this.draw(event);
      if (Prototype.Browser.WebKit) window.scrollBy(0,0);
      Event.stop(event);
   }
  },
  draw: function(event) {
    var pointer = [Event.pointerX(event), Event.pointerY(event)];
    var offsets = Element.cumulativeOffset(this.track);
    pointer[0] -= this.offsetX + offsets[0];
    pointer[1] -= this.offsetY + offsets[1];
    this.event = event;
    this.setValue(this.translateToValue( this.isVertical() ? pointer[1] : pointer[0] ));
    if (this.initialized && this.options.onSlide)
      this.options.onSlide(this.values.length>1 ? this.values : this.value, this);
  },
  endDrag: function(event) {
    if (this.active && this.dragging) {
      this.finishDrag(event, true);
      Event.stop(event);
    }
    this.active = false;
    this.dragging = false;
  },
  finishDrag: function(event, success) {
    this.active = false;
    this.dragging = false;
    this.updateFinished();
  },
  updateFinished: function() {
    if (this.initialized && this.options.onChange)
      this.options.onChange(this.values.length>1 ? this.values : this.value, this);
    this.event = null;
  }
});



// *** END Prototype ******************************************************************************



var AutoUpdater = {
	days	: 1,
	name	: "KabaListics (DoA Power Tools Plus II modded by Jawz)",
	shortname	: scriptName,
	version	: scriptVersion,
	time	: new Date().getTime(),
	call	: function(response, secure) {
				GM_xmlhttpRequest({
					method	: 'GET',
					url		: 'http'+(secure ? 's' : '')+'://userscripts.org/scripts/source/'+scriptId+'.meta.js',
					onload	: function(xpr) {AutoUpdater.compare(xpr, response);},
					onerror	: function(xpr) {if (secure) AutoUpdater.call(response, false);}
				});
			  },

	enable : function() {
		console.log ('Enable '+this.shortname+' updates');
		localStorage.setItem( '118446_updater', new Date().getTime()+'');
		AutoUpdater.call(true, true);
	},

	compareVersion: function(r_version, l_version) {
		var r_parts = r_version.split('.'),
			l_parts = l_version.split('.'),
			r_len = r_parts.length,
			l_len = l_parts.length,
			r = l = 0;
		for (var i = 0, len = (r_len > l_len ? r_len : l_len); i < len && r == l; ++i) {
			r = +(r_parts[i] || '0');
			l = +(l_parts[i] || '0');
		}
		return (r !== l) ? r > l : false;
	},

	compare: function(xpr,response) {
		this.xversion=/\/\/\s*@version\s+(.+)\s*\n/i.exec(xpr.responseText);
		this.xname=/\/\/\s*@name\s+(.+)\s*\n/i.exec(xpr.responseText);
		if ( (this.xversion) && (this.xname[1] == this.name) ) {
			this.xversion = this.xversion[1];
			this.xname = this.xname[1];
		} else {
			if ( (xpr.responseText.match("the page you requested doesn't exist")) || (this.xname[1] != this.name) ) {
				localStorage.setItem( '118446_updater', 'off');
			}
			return false;
		}
		var updated = this.compareVersion(this.xversion, this.version);
		if ( updated ) {
			updaterConfirm(translate('A new version of') + ' ' + this.shortname + ' ' + translate('is available.\nDo you wish to install the latest version ?'),
                function(){
					try {
						location.href = 'http://userscripts.org/scripts/source/'+scriptId+'.user.js'; 
					} catch(e) {}
				},
				// Cancel
				function(){}, true
			);
		} else {
			updaterConfirm(translate('No new version of') + ' ' + this.shortname + ' ' + translate('available.'), function(){}, null, false);
		}
	},
	manualCheck: function() {
		localStorage.setItem( '118446_updater', new Date().getTime()+'');
		AutoUpdater.call(true, true);
	},
	check: function() {
		if (localStorage.getItem( '118446_updater' ) == "off"){
			this.enable();
		} else {
			if (+this.time > (+localStorage.getItem( '118446_updater' ) + 1000*86400*this.days )){
				localStorage.setItem( '118446_updater', this.time+'');
				this.call(false, true);
			}
			console.log('Check '+this.shortname+' for updates');
			localStorage.setItem( '118446_updater', new Date().getTime()+'');
			AutoUpdater.call(true, true);
		}
	}
};

var progressBar = {
	steps		: 0,
	step		: 0,
	delay		: 10000,
	totalTime	: 0,
	currentTime	: 0,
	timer		: 0,
	title		: '',
	stepText	: '',
	displayed	: false,
	by_count	: false,

	init : function (x, y, width, height, title, bar_width, modal, container){
		var t = progressBar;
		if (modal)
			progressBarPop = new ModalDialog (container, width, height, '', false);
		else
			progressBarPop = new PopUp ('progress_bar', x, y, width, height, function () { tabManager.hideTab(); });
		progressBarPop.getTopDiv().innerHTML = '<div class=' + UID['title'] + '><center><b>KabaListics : ' + title + '</b></center></div>';
		var layoutDiv = document.createElement('div');
		layoutDiv.className = 'container';
		layoutDiv.style.backgroundColor = 'rgb(245,245,228)';
 		layoutDiv.style.color = '#000';
		layoutDiv.style.height = '100%';
		var layout = '<center><BR><B><div id='+setUID('initTitle')+'></div></B>'
					+'<br><div id='+setUID('initProgressBar')+' style="width:'+bar_width+'px"></div>'   //padding:5px 5px 5px 5px;border:1px solid #898989;
					+'<br><div class=jewel id='+setUID('initStepText')+'></div></center>';
		if (modal)
			progressBarPop.getContentDiv().appendChild(layoutDiv);
		else
			progressBarPop.getMainDiv().appendChild(layoutDiv);
		t.hideshow(true);
		t.displayed = true;
		layoutDiv.innerHTML = layout;
	},
	hideshow : function (onOff){
		var t = progressBar;
		if (!onOff && t.displayed) {
			progressBarPop.show(false);
			t.displayed = false;
			if (t.timer)
				clearInterval(t.timer);
		}
		if (onOff && !t.displayed) {
			progressBarPop.show(true);
			t.displayed = true;
		}
	},
	start : function (options){
		var t = progressBar;
		t.hideshow(true);
		t.steps = options.steps;
		t.delay = options.delay||t.delay;
		t.title = options.title||t.title;
		t.stepText = options.stepText||t.stepText;
		t.by_count = options.byCount||t.by_count;
		t.totalTime = t.steps * t.delay;
		t.step = 0;
		t.currentTime = 0;
		document.getElementById(UID['initTitle']).innerHTML = t.title;
		document.getElementById(UID['initStepText']).innerHTML = t.stepText;
		if (!t.by_count) {
			clearInterval(t.timer);
			t.timer = setInterval(t._progress, 500);
		}
	},
	stop : function(){
		var t = progressBar;
		t.delay = 10000;
		if (t.timer)
			clearInterval(t.timer);
	},
	pause : function(){
		var t = progressBar;
		if (t.timer)
			clearInterval(t.timer);
	},
	resume : function(){
		var t = progressBar;
		if (!t.timer)
			t.timer = setInterval(t._progress, 250);
	},
	update : function(options){
		var t = progressBar;
		t.hideshow(true);
		t.step = options.step;
		t.title = options.title||t.title;
		t.stepText = options.stepText||t.stepText;
		t.currentTime = t.delay * t.step;
		//t.delay = parseInt((t.delay+t.currentTime)/step);
		//t.totalTime = t.delay * t.steps;
		if (document.getElementById(UID['initTitle'])) document.getElementById(UID['initTitle']).innerHTML = t.title;
		if (document.getElementById(UID['initStepText'])) document.getElementById(UID['initStepText']).innerHTML = t.stepText;
		if (t.by_count) t._progress ();
	},
	
	_progress : function(){
		var t = progressBar;
		if (!t.by_count)
			t.currentTime += 500;
		var perc = parseInt((t.currentTime/t.totalTime)*200);
		if (perc > 200) perc = 200;
		var _progressBar = '<table class=progress_bar><tr>';
		for (var n=0; n<perc; n++)
			_progressBar += '<td class=progress_on></td>';
		for (var n=perc; n<200; n++)
			_progressBar += '<td class=progress_off></td>';
		_progressBar += '</tr></table>';
		if (document.getElementById(UID['initProgressBar'])) document.getElementById(UID['initProgressBar']).innerHTML = _progressBar;
		if (perc >= 200) {
			t.stop();
		}
	}
}

setMainStyles();
var initialDelay = Math.randRange(6000, 13000);
progressBar.init (800+Math.randRange(1,50), 100, 450, 150, translate('Initialization'), 400, false);
progressBar.start({ steps:1, delay:initialDelay, title:translate('Starting...'), stepText:translate('Delay before script startup') });
setTimeout (scriptStartup, initialDelay);
}
})();