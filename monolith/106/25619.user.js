/*
LIMITATIONS: USA locations only.
*/

// ==UserScript==
// @name          Craigslist Driving Time
// @namespace     http://dbooth.org
// @include       file://*sample*
// @description   Display the driving time and distance to each item listed on craigslist.org.  DO NOT INSTALL THIS SCRIPT unless you are intending to help me finish writing it.  It is UNFINISHED and NOT YET WORKING.
// @source        http://userscripts.org/scripts/show/25619
// @identifier    http://userscripts.org/scripts/show/25619.user.js
// @version       0.1
// @date          2009-03-19
// @creator       David Booth <david_AT_dbooth_DOT_org>
// ==/UserScript==
// // @include       http://*.craigslist.org/*

// License: GPL http://creativecommons.org/licenses/GPL/2.0/


(function() {  // BEGIN UNNAMED FUNCTION

// ###############################################################
// ################# BEGIN USER CUSTOMIZATION ####################
// ###############################################################
//
// For the moment, each user should customize this section as described.
//
// STEP 1:  Specify your start address here:
var startAddress = "257 Elm St, Somerville, MA 02144";
// Be sure to test your start address 
// at http://maps.google.com to ensure that google maps will find it
// properly without asking for disambiguation.
//
// STEP 2:  Specify a |-separated list of default states here,
// with the most likely state listed first:
var defaultStates = "MA|RI";
// The defaultStates are used to help google maps find the
// town specified in a craigslist listing, since most craigslist 
// posters omit the state, and the town alone would otherwise
// be ambiguous. For example, I live outside of Boston, MA and 
// typically use boston.craigslist.org, so a reasonable list
// of defaultStates for my location would be:
// var defaultStates = "MA|RI|NH";
// I have listed "MA" first, because most postings are likely
// to be in MA, but a few may be in RI or NH, and they will
// be tried in sequence.  Please use
// standard USPS state abbreviations, as specified here:
// http://www.usps.com/ncsc/lookups/abbreviations.html#states
// Do not list more state abbreviations than you need, as
// doing so will merely slow down the script.
//
// That's all!
//
// ###############################################################
// #################### END user customization ###################
// ###############################################################

// ################# Globals #################
var SCRIPT_NAME = "GreaseMonkey script 'Craigslist Driving Time'";
var gmapsURLTemplate = 'http://maps.google.com/maps?f=d&hl=en&geocode=&saddr=START&daddr=DESTINATION';
// TODO: Prompt for the startAddress, and then save it in 
// a cookie, rather than being hard coded as it currently is.  
// This page shows how to prompt for input:
// http://www.kourbatov.com/faq/prompt.htm
//
// Ensure that startAddress does not contain "|", because that
// will be used as a separator in caching.
// TODO: Be sure this is done again if the user is prompted for startAddress.
startAddress = startAddress.replace(/\|/g, " "); 
startAddress = startAddress.toLowerCase(); // Is this needed?
startAddress = startAddress.replace(/^\s+/, ""); // Leading spaces
startAddress = startAddress.replace(/\s+$/, ""); // Trailing spaces
if (!startAddress.length)
	{
	alert(SCRIPT_NAME+": startAddress must be specified!");
	return;
	}
var gStart = startAddress.replace(/\s+/g, "+");
gmapsURLTemplate = gmapsURLTemplate.replace("START", gStart);

// TODO: Sniff the craigslist URL to figure out the defaultStates
// and default startAddress
defaultStates = defaultStates.replace(/^[\s\|]+/, ""); // Leading spaces or |
defaultStates = defaultStates.replace(/[\s\|]+$/, ""); // Trailing spaces or |
defaultStates = defaultStates.toLowerCase();
// defaultStatesPattern will be like: ma|nh|ri|me
var defaultStatesPattern = defaultStates.replace(/\s*\|\s*/g, "|");
var anchoredDefaultStatesPattern = "\\b("+defaultStatesPattern+")$";
// alert("anchoredDefaultStatesPattern: "+anchoredDefaultStatesPattern);
var defaultStatesListEmptyLast = (defaultStates+"|").split("|");
var defaultStatesListEmptyFirst = ("|"+defaultStates).split("|");
// alert("defaultStatesListEmptyLast.length:"+defaultStatesListEmptyLast.length); // TESTING
// alert("defaultStatesListEmptyLast:"+defaultStatesListEmptyLast.join("#")+":"); // TESTING
// alert("defaultStatesListEmptyFirst:"+defaultStatesListEmptyFirst.join("#")+":"); // TESTING

// DO NOT MANUALLY EDIT the following state matching pattern!  It is 
// generated by a perl script genstates.perl available at
// http://userscripts.org/scripts/show/25923
// Instead, modify genstates.perl as needed and re-run it to generate
// a new pattern.
var statePattern = "(((a[ .]*r)|(a[ .]*s)|(ak)|(al)|(ala)|(alabama)|(alas)|(alaska)|(american[ .]*samoa)|(ar)|(ariz)|(arizona)|(ark)|(arkansas)|(az)|(c[ .]*z)|(ca)|(cal)|(calif)|(california)|(canal[ .]*zone)|(co)|(col)|(colo)|(colorado)|(conn)|(connecticut)|(ct)|(d[ .]*c)|(de)|(del)|(delaware)|(district[ .]*of[ .]*columbia)|(fl)|(fla)|(flor)|(florida)|(ga)|(georgia)|(guam)|(h[ .]*i)|(hawaii)|(hi)|(ia)|(id)|(ida)|(idaho)|(il)|(ill)|(illinois)|(ills)|(in)|(ind)|(indiana)|(iowa)|(kan)|(kans)|(kansas)|(ken)|(kent)|(kentucky)|(ks)|(ky)|(la)|(louisiana)|(m[ .]*p)|(ma)|(maine)|(maryland)|(mass)|(massachusetts)|(md)|(me)|(mi)|(mich)|(michigan)|(minn)|(minnesota)|(miss)|(mississippi)|(missouri)|(mn)|(mo)|(mont)|(montana)|(ms)|(mt)|(n[ .]*c)|(n[ .]*car)|(n[ .]*d)|(n[ .]*dak)|(n[ .]*h)|(n[ .]*j)|(n[ .]*m)|(n[ .]*mex)|(n[ .]*y)|(n[ .]*york)|(nc)|(nd)|(ne)|(neb)|(nebr)|(nebraska)|(nev)|(nevada)|(new[ .]*hampshire)|(new[ .]*jersey)|(new[ .]*m)|(new[ .]*mexico)|(new[ .]*york)|(nh)|(nj)|(nm)|(north[ .]*carolina)|(north[ .]*dakota)|(northern[ .]*mariana[ .]*islands)|(nv)|(ny)|(o)|(oh)|(ohio)|(ok)|(okla)|(oklahoma)|(or)|(ore)|(oreg)|(oregon)|(p[ .]*r)|(pa)|(penn)|(penna)|(pennsylvania)|(puerto[ .]*rico)|(r[ .]*i)|(rhode[ .]*island)|(ri)|(s[ .]*c)|(s[ .]*car)|(s[ .]*d)|(s[ .]*dak)|(sc)|(sd)|(south[ .]*carolina)|(south[ .]*dakota)|(tenn)|(tennessee)|(tex)|(texas)|(tn)|(tx)|(u[ .]*s[ .]*v[ .]*i)|(ut)|(utah)|(v[ .]*i)|(va)|(vermont)|(virgin[ .]*islands)|(virginia)|(vt)|(w[ .]*v)|(w[ .]*va)|(wa)|(wash)|(washington)|(west[ .]*virginia)|(wi)|(wis)|(wisc)|(wisconsin)|(wv)|(wy)|(wyo)|(wyoming))[.]*)";
var anchoredStatePattern = "\\b" + statePattern + "$";

// Return code for ParseDrivingTime:
var FAILED_PREFIX = "Failed: ";

// alert("before hash class");
// ################ Hash Class #################
// Based on the hash class given at
// http://www.mojavelinux.com/articles/javascript_hashes.html
// but modified slightly to: (a) make setItem return the old value instead 
// of the new value; and (b) add error checking.
function Hash()
{
	// Member variables:
	this.length = 0;
	this.items = new Array();

	this.removeItem = function(in_key)
	{
		var tmp_value;
		if (typeof(this.items[in_key]) != 'ftp://ftp.') {
			this.length--;
			var tmp_value = this.items[in_key];
			delete this.items[in_key];
		}
		return tmp_value;
	}

	this.getItem = function(in_key) {
		return this.items[in_key];
	}

	this.setItem = function(in_key, in_value)
	{
		var old_value;
		if (typeof(in_key) == 'ftp://ftp.') {
			alert("ERROR: Hash.setItem was called with an undefined key.");
		} else if (typeof(in_value) == 'undefined') {
			alert("ERROR: Hash.setItem was called with an undefined value.");
		} else {
			old_value = this.items[in_key];
			if (typeof(this.items[in_key]) == 'undefined') {
				this.length++;
			}
			this.items[in_key] = in_value;
		}
		return old_value;
	}

	this.hasItem = function(in_key)
	{
		return typeof(this.items[in_key]) != 'undefined';
	}

	// Constructor:
	while(arguments.length>0 
		&& ( typeof(arguments[arguments.length-1]) == 'ftp://ftp.'))
		{ arguments.length--; } // Strip undefined args
	// alert("arguments.length: "+arguments.length);
	for (var i = 0; i+1 < arguments.length; i += 2) {
		this.setItem(arguments[i], arguments[i+1]);
	}
	if (arguments.length != this.length+this.length) {
		alert("ERROR: Odd number of arguments passed to Hash(...)");
	}

}

// Test the hash class (DONE):
// alert("before hash test");
// var th1 = new Hash();
// alert("th1.length:" + th1.length);
// var th2 = new Hash("a");
// alert("th2.length:" + th2.length);
// var th3 = new Hash("a", "b");
// alert("th3.length:" + th3.length + "[a]: "+th3.getItem("a"));
// var th4 = new Hash("a", "b", "c", "d");
// alert("th4.length:" + th4.length);
// var th5 = new Hash("a", "b", "c");
// alert("th5.length:" + th5.length);
// var u;
// var th6 = new Hash("a", "b", "c", "d", u);
// alert("th6.length:" + th6.length);
// var myHash = th6;
// for (var i in myHash.items) {
	// alert('key is: ' + i + ', value is: ' + myHash.items[i]);
// }
// alert("th6 hasItem a: "+th6.hasItem("a"));
// alert("th6 hasItem b: "+th6.hasItem("b"));
// alert("th6 hasItem c: "+th6.hasItem("c"));
// alert("th6 hasItem z: "+th6.hasItem("z"));
// return;

// ################ CleanLocation ###############
// Returns cleaned location, lower case.
// Depends on globals: anchoredDefaultStatesPattern
function CleanLocation(location)
{
location = location.toLowerCase();
location = location.replace(/\&nbsp\;/g, " ");
// 		lincoln area --> lincoln
location = location.replace(/\barea\b/g, " ");
// When more than one location is given, it seems better to keep the 
// last one, in case it is followed by the state:
// 	lincoln/waltham --> waltham
// 	lexington or wareham ma --> wareham ma
// 	lexington | wareham -- wareham
location = location.replace(/^.*(\/|\||or)\b\s*/g, "");
// 		any --> ""
// 		anywhere --> ""
location = location.replace(/\b(any|every)(\s*(where|place|location|town|city|state))?\b/g, "");
location = location.replace(/\s*\,\s*/g, ", "); // Single space after comma
location = location.replace(/\s*\.\s*/g, ". "); // Single space after period
location = location.replace(/^[^a-z0-9]+/, ""); // Leading junk
location = location.replace(/[^a-z0-9.]+$/, ""); // Trailing junk
// Handle special cases:
// 	LA could mean Los Angeles or Louisiana, so if "ca" is
// 	in the defaultStates, then change LA to "los angeles, ca".
if ("ca".match(anchoredDefaultStatesPattern))
	{ location = location.replace(/\bl[ .]*a[ .]*$/, "los angeles, ca"); }
location = location.replace(/\s+/g, " "); // Collapse multiple spaces to single
// alert("Cleaned location: "+location);
return(location);
}

// ################### NeedsState ####################
// Return true if the location seems to need a state.
// This function assumes that CleanLocation has already been called.
// Depends on globals: anchoredDefaultStatesPattern anchoredStatePattern
function NeedsState(location)
{
// Already has the state at the end?
// alert("Entering NeedsState");
if (location =="") { return(false); }
if (location.match(anchoredDefaultStatesPattern)) { return(false); }
if (location.match(anchoredStatePattern)) { return(false); }
// 5-digit US zip code:
if (location.match(/\b\d\d\d\d\d$/)) { return(false); }
return(true);
}

// ################## ParseDrivingTime ###################
// Returns distanceAndTime or an error code:
//	FAILED_PREFIX+failedPattern
// 	"" (which is some other match failure)
function ParseDrivingTime(page) 
{
var debug = false;
var distanceAndTime = "";
var failedPatterns = [	// A list of gmaps failure patterns
	"We could not understand the location",
	"Did you mean\\:",
	"We could not calculate" ];
for (var i=0; i<failedPatterns.length; i++) {
	if (page.match(failedPatterns[i])) { 
		distanceAndTime = FAILED_PREFIX+failedPatterns[i];
		if (debug) { alert(distanceAndTime); }
		return distanceAndTime; 
		}
	}
// For the following google maps URL
// http://maps.google.com/maps?f=d&hl=en&geocode=&saddr=boston&daddr=new+york,+ny';
// the returned page contains the distance and driving time
// in a CDATA section that contains (among other things):
// timedist ul\"\x3e\x3cdiv class=noprint\x3e\x3cdiv\x3e215\x26#160;mi \x26#8211; about 3 hours 58 mins\x3c/div\x3e\x3c/div\x3e\x3cdiv class=pw
// The driving distance is 215 miles in this example.
// TODO: Change these from using split to using regular pattern matching?
var a1 = page.split(/timedist /);
if (!a1.length) { return ""; } // Default parsing failure
// TODO: Clean up next line:
var s1 = ((a1.length > 1) ? a1[1] : "")
// if (debug) { alert("s1:"+s1); }
// s1: ul\"\x3e\x3cdiv class=noprint\x3e\x3cdiv\x3e215\x26#160;mi \x26#8211; about 3 hours 58 mins\x3c/div\x3e\x3c/div\x3e\x3cdiv class=pw ...
var a2 = s1.split(/class\=pw/);
if (!a2.length) { return ""; }
// TODO: Clean up next line:
var s2 = ((a2.length > 1) ? a2[0] : "")
if (debug) { alert("s2:"+s2); }
// s2: ul\"\x3e\x3cdiv class=noprint\x3e\x3cdiv\x3e215\x26#160;mi \x26#8211; about 3 hours 58 mins\x3c/div\x3e\x3c/div\x3e\x3cdiv 
var a3 = s2.split(/class\=noprint/);
if (!a3.length) { return ""; }
// TODO: Clean up next line:
var s3 = ((a3.length > 1) ? a3[1] : "")
if (debug) { alert("s3:"+s3); }
// s3: \x3e\x3cdiv\x3e215\x26#160;mi \x26#8211; about 3 hours 58 mins\x3c/div\x3e\x3c/div\x3e\x3cdiv 
// TODO: Very short trips only give the distance -- not the time, such as:
// \"timedist ul\"\x3e\x3cdiv class=noprint\x3e\x3cdiv\x3e0.3\x26#160;mi\x3c/div
// in sample-google-short.html
var a4 = s3.split(/about /);
if (!a4.length) { return ""; }
// TODO: Clean up next line:
var distance = ((a4.length > 1) ? a4[0] : "")
if (debug) { alert("initial distance:"+distance); }
// distance: \x3e\x3cdiv\x3e215\x26#160;mi \x26#8211; 
distance = distance.replace(/mi .*/i, "mi");
distance = distance.replace(/km .*/i, "km");
// distance: \x3e\x3cdiv\x3e215\x26#160;mi
distance = distance.replace(/^.*div\\x3e/, "");
// distance: 215\x26#160;mi
distance = distance.replace(/\\x26\#160\;/, " ");
if (debug) { alert("final distance:"+distance); }
// distance: 215 mi
// TODO: Clean up next line:
var drivingTime = ((a4.length > 1) ? a4[1] : "")
// drivingTime: 3 hours 58 mins\x3c/div\x3e\x3c/div\x3e\x3cdiv 
drivingTime = drivingTime.replace(/\\.*/, "");
// drivingTime: 3 hours 58 mins
if (debug) { alert("distance: "+distance+" drivingTime: "+drivingTime); }
distanceAndTime = distance + " - " + drivingTime;
return(distanceAndTime);
}

// ################# ProcessMapPage ####################
// TODO: change stateSuffix and defaultStates to stateIndex
// and statesList.
function ProcessMapPage(page, location, statesList, stateIndex, gmapsURL, callback)
{
var debug = true;
if (debug) { alert("Entering ProcessMapPage"); }
var distanceAndTime = ParseDrivingTime(page);
if (!distanceAndTime.length)
	{
	// Unknown failure to recognize the gmaps page.
	// Perhaps they changed the format.
	alert("Gmaps parsing failure for location:"+location+statesList[stateIndex]); // TESTING
	return;
	}
// TODO: Make a constant for this pattern:
if (distanceAndTime.match("^"+FAILED_PREFIX))
	{ 
	alert(distanceAndTime+". Location: "+location+" stateSuffix: "+statesList[stateIndex]);
	if (stateIndex+1 >= statesList.length)
		{
		alert("No more defaultStates to try.  Location+stateSuffix: "+location+statesList[stateIndex]); // TESTING
		return;
		}
	// Try again recursively as long as we have more defaultStates.
	//
	// It actually seems to make sense to try again if we tried a
	// stateSuffix but the result is ambiguous, because town names
	// are also often street names, so using a town name with
	// the wrong state will likely cause google maps to return
	// "Did you mean:".
	//
	// I'm not sure if something like the following line is needed:
	// if (typeof place[0] != "ftp://ftp."){ ... }
	alert("Trying again with location: "+location+" suffix: "+statesList[stateIndex+1]);
	// TODO: Set gmapsURL properly?  Or pass location, statesList, 
	// stateIndex+1  to callback?
	var nextCallback = function (gmapsURL) { alert("callback called gmapsURL: "+gmapsURL); };
	RequestDrivingTime(location, statesList, stateIndex+1, nextCallback);
	}
else	{
	alert("FOUND distanceAndTime: "+distanceAndTime);
	callback(gmapsURL);
	// TODO: Build link, etc.

	// var newform = '<a href="http://maps.google.com/maps?f=q&hl=en&geocode=&q=LOCATION" target="_blank">LOCATION</a>';
	// var newform = '<a href="http://maps.google.com/maps?f=d&hl=en&geocode=&saddr=GSTART&daddr=LOCATION">LOCATION</a>';
	// var link = newform.replace("TOWN", town).replace("STATE",state).replace(/LOCATION/g,location).replace(/GSTART/g,gStart);

	}

}

// #################### MakeGMapsURL ###################
function MakeGMapsURL(location, state)
{
var separator = (state.length ? ",+" : "");
var fullLocation = location+separator+state;
var gmapsURL = gmapsURLTemplate.replace("DESTINATION", fullLocation);
return(gmapsURL);
}

// ###################  RequestDrivingTime ########################
function RequestDrivingTime(location, statesList, stateIndex, callback)
{
var debug = true;
if (debug) { alert("Entering RequestDrivingTime statesList:"+statesList.join("#")+": stateIndex: "+stateIndex+" statesList.length: "+statesList.length); }
if (stateIndex >= statesList.length) {
	// alert("error >="); // TESTING
	alert(SCRIPT_NAME+": INTERNAL ERROR: stateIndex >= statesList.length.  Please send a bug report to the maintainer listed at userscripts.org.");
	return;
	}
var gmapsURL = MakeGMapsURL(location, statesList[stateIndex]);
// gmapsURL = "file:///home/dbooth/bin/greasemonkey/simple-google-found.html"; // TESTING
var not = ""; // TESTING
// not = "NOT "; // TESTING.  Comment out this line to enable requests.
alert(not+"Requesting gmapsURL: "+gmapsURL); // TESTING
if (not.length>0) { return; } // TESTING
if (gmapsURL.length)
	{
	GM_xmlhttpRequest({ 
		method: "GET",
		url: gmapsURL, 
		onload: function ( results ) {
			alert("OnLoad location: "+location+" stateSuffix: "+statesList[stateIndex]);
		  var page = results.responseText;
		ProcessMapPage(page, location, statesList, stateIndex, gmapsURL, callback);

		  }
	    });
	}
if (debug) { alert("Exiting RequestDrivingTime gmapsURL: "+gmapsURL); }
}

// ########################  Main  ########################
// alert("started!");
// TODO: Make this script work on both kinds of pages:
//   1. The search results page, such as
//   http://boston.craigslist.org/search/sss?query=bike    
//   which will contain a string like: "Found: 62 Displaying:".
//   2. A detail page of a specific listing, which will contain
//   a string like: "Location:".
// However, at first it will only work on search results pages.
// I'm still not sure what is the best way to figure out if we
// are on a search results page, but one possibility might
// be to look for the presence of "- (" before the location.
//
// TODO: A better way to handle the screen scraping would
// be to use an actual example returned string, and then
// specify what parts of it are variable, and use that
// information to construct the appropriate pattern.

// alert("Body: "+document.body.text);
// var oldform;
// oldform = document.getElementsByTagName('li')[0].innerHTML; 
var td = document.getElementsByTagName('td');
// alert("Found td");
if (td.length>0 && td[0].innerHTML.match("search for\\:")) {
	// alert("Found search for!");
	}
var paragraphs = document.getElementsByTagName('p');
alert("Found paragrphas: "+paragraphs.length);
// TODO: Process all paragraphs (remove i<3):
for (var i=0; i<paragraphs.length && i<1; i++)
	{
	// TODO: For some reason, the pattern match does not always
	// seem to work.  See file: sample-craigslist-search-notworking.html
	// TODO: If the location seems to be only a town, then put a stateSuffix
	// on it without even trying it as a single word.  Otherwise
	// google maps thinks "Arlington" is "Arlington, VA" instead
	// of being the one outside of Boston, MA.
	// alert("innerHTML: "+paragraphs[i].innerHTML);
	// Get the last match, in case there are parenthesess in the title:
	// Red Sox Tix (Mon 4/21 vs. Tex) - $1 - (Boston) <<tickets
	// TODO: Some real estate ads contain a link to google maps.  It
	// might be nice to use that if it is there, but it means
	// (a) knowing which categories of ads have them; and (b)
	// retrieving each ad detail to scrape the link out.  So
	// I'm not sure it's worth it.
	var locationPattern = "^(.*)\\(([^\\)]+)\\)([^\\(\\)]*)$";
	var matches;
	var pre = "";
	var location = "";
	var post = "";
	if (matches = paragraphs[i].innerHTML.match(locationPattern)) {
		// alert("Found "+locationPattern+" at i="+i);
		location = (matches.length 
			? matches[matches.length-1].substr(1,matches[matches.length-1].length-2)
			: "");
		pre = matches[1];
		var dirtyLocation = matches[2];
		post = matches[3];
		// alert("Location: "+dirtyLocation+" pre: "+pre+" post: "+post);
		location = CleanLocation(dirtyLocation);
		var needsState = NeedsState(location);
		if (!needsState) {
			// Make state abbreviations more standard, so
			// that caching will have more hits: N.Y. --> NY
			// The state is not often specified, so it does
			// not seem worth comparing against all possible
			// state spellings.
			var m = location.match(/^(.*)\b([a-z])[ .]*([a-z])[ .]*$/);
			if (m) { location = m[1]+m[2]+m[3]; }
			}
		var nss = "false";
		if (needsState) { nss = "True"; }
		alert("Dirty location: "+dirtyLocation+" CleanLocation: "+location+" Needs state: "+nss);
		if (!location.length) { 
			// alert("Empty location");
			continue; 
			}
		// alert("Matches "+matches.length+": "+matches.join("|"));
		// document.getElementsByTagName('li')[0].innerHTML=("Location: "+link);
		// var fakeLink = '<a href="http://google.com">fakeLink<a>';
		// paragraphs[i].innerHTML=("Location: "+fakeLink);
		// innerHTML=("Location: "+fakeLink);
		//
		var callback = function (gmapsURL) { alert("callback called gmapsURL: "+gmapsURL); };
		RequestDrivingTime(location, (needsState ? defaultStatesListEmptyLast : defaultStatesListEmptyFirst), 0, callback);
		alert("After calling RequestDrivingTime");
		// TODO: Make links, etc
		// document.getElementsByTagName('li')[0].innerHTML=("Location: "+link);
		}
	}
alert("Finished paragraph loop");


})(); // END UNNAMED FUNCTION (which is invoked)
